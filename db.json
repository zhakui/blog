{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1494572054334},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1494572054334},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1494572054334},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1494572054334},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1494572054334},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1494572054334},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1494572054334},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1494572054334},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1494572054334},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1494572054334},{"_id":"themes/next/_config.yml","hash":"915809a267ef7a40abfe3ee345661a6d9a07672a","modified":1494902586292},{"_id":"themes/next/bower.json","hash":"be0a430362cb73a7e3cf9ecf51a67edf8214b637","modified":1494572054338},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1494572054338},{"_id":"themes/next/package.json","hash":"7e87b2621104b39a30488654c2a8a0c6a563574b","modified":1494572054338},{"_id":"source/_posts/Docker安装.md","hash":"850f8f95ebff291fa502e93764dbb2bb962278cf","modified":1504866014383},{"_id":"source/_posts/Docker常用命令 （二）.md","hash":"ca8800cbbfb303abd3aa93221ab5ca8e3eccb85b","modified":1504865997107},{"_id":"source/_posts/Docker常用命令.md","hash":"84967c06fa334b2a954b0bbfe01cc5f4663c50bc","modified":1504865974427},{"_id":"source/_posts/Good-Code-vs-Bad-Code-in-Golang.md","hash":"854893c1643e8239257d53cd26ef1ae618822d6a","modified":1542361367205},{"_id":"source/_posts/Hadoop HA配置.md","hash":"9ec624ad4f6fcb8e5a48d3bf9907d94968d01d1f","modified":1552560921098},{"_id":"source/_posts/Hadoop基础知识整理.md","hash":"98eec7a1e477ff86023d6e975337da3c8a493ec7","modified":1504865790923},{"_id":"source/_posts/Hive学习笔记.md","hash":"426de7710f57a2a4141754b830bb8c55e7444ddb","modified":1505989903861},{"_id":"source/_posts/JavaScript继承方式.md","hash":"6a7700a18be8a3073400e6a0035163b413b81bf0","modified":1504865952955},{"_id":"source/_posts/KMP算法.md","hash":"15de7af685ff6c4dd85399382185b94a68af8ec8","modified":1528445816650},{"_id":"source/_posts/Redis.md","hash":"a8a3a0b8c482712bec46c1959887c27b9028fbd5","modified":1504865931471},{"_id":"source/_posts/Redis的数据结构.md","hash":"2362584434dbfff03f8125eaf22be201e6e5e9f6","modified":1504865916383},{"_id":"source/_posts/Redis的数据结构（二）.md","hash":"85996e2673b294940cfd3fa270bb6f5c26946837","modified":1504865926047},{"_id":"source/_posts/Spring-Cloud-and-Netflix-OSS.md","hash":"bd0fdbc4c845f38d07380a6972a8072edef6fd9d","modified":1552561688334},{"_id":"source/_posts/Spring-Cloud-and-Netflix-OSS1.md","hash":"04f730c247935ae1263b3fd1b135372910097c16","modified":1552561600410},{"_id":"source/_posts/SpringCloud微服务框架搭建.md","hash":"c31102190b8e285bba64b363988db49fc526390f","modified":1525317179196},{"_id":"source/_posts/VPS搭建自己的的Hexo博客.md","hash":"b075e6a88399edd435f0bcf46aa467e7eadb2808","modified":1504865813863},{"_id":"source/_posts/pom.xml详解.md","hash":"7d569ef6ad0dc18cd42373e38dbb36f07ff47165","modified":1539246113620},{"_id":"source/_posts/【微服务-Java】Part 1: Building microservices with Spring Cloud and Netflix OSS.md","hash":"5d9ff0e6143e18d66148133cf4f4c9c0dc02c140","modified":1552561801870},{"_id":"source/_posts/大数据排重算法：布隆过滤器.md","hash":"b747b0e51b0aa4dbd10334228ef5a6b433185985","modified":1528432310463},{"_id":"source/_posts/微服务操作模型.md","hash":"5c2ae98f1b940dfb5b04f839af26313a2ff9fe7e","modified":1551753539314},{"_id":"source/_posts/软件架构.md","hash":"a33ae2a1542db432b863bd3315f3b4443443ec26","modified":1548322712971},{"_id":"source/about/index.md","hash":"0d84235ad0119e90b24630580d38c449bda9254b","modified":1494903115624},{"_id":"source/categories/index.md","hash":"1ee297fe77005600861613ba910b47aa37324d5a","modified":1494902702568},{"_id":"source/tags/index.md","hash":"0529de3936d30c83f77cdc787a3e58e6d8fb8263","modified":1494902696676},{"_id":"themes/next/languages/de.yml","hash":"306db8c865630f32c6b6260ade9d3209fbec8011","modified":1494572054338},{"_id":"themes/next/languages/default.yml","hash":"4cc6aeb1ac09a58330e494c8771773758ab354af","modified":1494572054338},{"_id":"themes/next/languages/en.yml","hash":"e7def07a709ef55684490b700a06998c67f35f39","modified":1494572054338},{"_id":"themes/next/languages/fr-FR.yml","hash":"24180322c83587a153cea110e74e96eacc3355ad","modified":1494572054338},{"_id":"themes/next/languages/id.yml","hash":"2835ea80dadf093fcf47edd957680973f1fb6b85","modified":1494572054338},{"_id":"themes/next/languages/ja.yml","hash":"1c3a05ab80a6f8be63268b66da6f19da7aa2c638","modified":1494572054338},{"_id":"themes/next/languages/ko.yml","hash":"be150543379150f78329815af427bf152c0e9431","modified":1494572054338},{"_id":"themes/next/languages/pt-BR.yml","hash":"958e49571818a34fdf4af3232a07a024050f8f4e","modified":1494572054338},{"_id":"themes/next/languages/pt.yml","hash":"36c8f60dacbe5d27d84d0e0d6974d7679f928da0","modified":1494572054338},{"_id":"themes/next/languages/ru.yml","hash":"1549a7c2fe23caa7cbedcd0aa2b77c46e57caf27","modified":1494572054338},{"_id":"themes/next/languages/zh-Hans.yml","hash":"3c0c7dfd0256457ee24df9e9879226c58cb084b5","modified":1494572054338},{"_id":"themes/next/languages/zh-hk.yml","hash":"1c917997413bf566cb79e0975789f3c9c9128ccd","modified":1494572054338},{"_id":"themes/next/languages/zh-tw.yml","hash":"0b2c18aa76570364003c8d1cd429fa158ae89022","modified":1494572054338},{"_id":"themes/next/layout/_layout.swig","hash":"9d1a23a6add6f3d0f88c2d17979956f14aaa37a4","modified":1494572054338},{"_id":"themes/next/layout/archive.swig","hash":"5de4dca06b05d99e4f6bad617a4b8f4f3592fb01","modified":1494572054338},{"_id":"themes/next/layout/category.swig","hash":"82e7bc278559b4335ad974659104eaaf04863032","modified":1494572054338},{"_id":"themes/next/layout/index.swig","hash":"03e8a2cda03bad42ac0cb827025eb81f95d496a2","modified":1494572054338},{"_id":"themes/next/layout/page.swig","hash":"2c6a78999133b991d9221f484aee2eacae894251","modified":1494572054338},{"_id":"themes/next/layout/post.swig","hash":"2d5f8d7f0a96b611e2d5a5e4d111fc17726a990f","modified":1494572054338},{"_id":"themes/next/layout/schedule.swig","hash":"f93c53f6fd5c712584f6efba6f770c30fa8a3e80","modified":1494572054338},{"_id":"themes/next/layout/tag.swig","hash":"2e73ee478e981092ea9a5d10dd472a9461db395b","modified":1494572054338},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1494572054338},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1494572054338},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1494572054358},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1494572054358},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1494572054358},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054342},{"_id":"source/_posts/Good-Code-vs-Bad-Code-in-Golang/1-yh90bW8jL4f8pOTZTvbzqw.png","hash":"069fe5c92956d43d723cc632123a26ff9d2a0454","modified":1542359718046},{"_id":"source/_posts/Good-Code-vs-Bad-Code-in-Golang/1-yh90bW8jL4f8pOTZTvbzqw.png:Zone.Identifier","hash":"d59fc84cdd5217c6cf74785703655f78da6b582b","modified":1542359767245},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1494572054338},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1494572054338},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1494572054338},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"b16fcbf0efd20c018d7545257a8533c497ea7647","modified":1494572054338},{"_id":"themes/next/layout/_macro/post.swig","hash":"c00261ee0dca8ef7d3f7753e8f8cd444f51118c4","modified":1494572054338},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1494572054338},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"911b99ba0445b2c07373128d87a4ef2eb7de341a","modified":1494572054338},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1494572054338},{"_id":"themes/next/layout/_partials/comments.swig","hash":"1c7d3c975e499b9aa3119d6724b030b7b00fc87e","modified":1494572054338},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1494572054338},{"_id":"themes/next/layout/_partials/head.swig","hash":"d4a05c51aac02f1f6248baccf2ddb8ee12b9122f","modified":1494572054338},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1494572054338},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1494572054338},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1494572054338},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1494572054338},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1494572054338},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1494572054338},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9baf90f7c40b3b10f288e9268c3191e895890cea","modified":1494572054338},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1494572054338},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1494572054338},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1494572054338},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1494572054338},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1494572054338},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1494572054338},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1494572054338},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1494572054338},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1494572054338},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1494572054338},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1494572054338},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1494572054342},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1494572054342},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1494572054342},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1494572054342},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1494572054342},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1494572054342},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1494572054342},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1494572054342},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1494572054342},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1494572054342},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1494572054342},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1494572054342},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1494572054342},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1494572054342},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1494572054342},{"_id":"source/_posts/Spring-Cloud-and-Netflix-OSS/mapping-table.png","hash":"333b9331439883c2ccf0d4bd7b40baf37fbca470","modified":1551770319861},{"_id":"source/_posts/【微服务-Java-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/mapping-table.png","hash":"333b9331439883c2ccf0d4bd7b40baf37fbca470","modified":1552561801838},{"_id":"source/_posts/微服务操作模型/microservices-1.png","hash":"c0882dace00c8dbde7e5f103cd45e56653d4afa5","modified":1548325503631},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054338},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054338},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054342},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054342},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054342},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054342},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1494572054342},{"_id":"source/_posts/Spring-Cloud-and-Netflix-OSS/system-landscape.png","hash":"b9c0a0e9c7fb857a1c4cc0a2e75e49c15d6b0359","modified":1551778786325},{"_id":"source/_posts/【微服务-Java-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/system-landscape.png","hash":"b9c0a0e9c7fb857a1c4cc0a2e75e49c15d6b0359","modified":1552561801862},{"_id":"source/_posts/微服务操作模型/microservices-1-1.png","hash":"bb60586cedfbc793bbbb0720a69e00474eec8d77","modified":1550661795566},{"_id":"source/_posts/微服务操作模型/microservices-1-2.png","hash":"5d30c0338c9aec279398d577cd715cb0da5a832c","modified":1550658357634},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1494572054338},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1494572054338},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1494572054338},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1494572054338},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1494572054338},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1494572054338},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1494572054338},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1494572054338},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1494572054338},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1494572054338},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"3358d11b9a26185a2d36c96049e4340e701646e4","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1494572054338},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1494836628215},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"abb92620197a16ed2c0775edf18a0f044a82256e","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"1d0d01aaeb7bcde3671263d736718f8837c20182","modified":1494572054338},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1494572054338},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1494572054338},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"1f349aa30dd1f7022f7d07a1f085eea5ace3f26d","modified":1494572054338},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1494572054338},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1494572054338},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1494572054342},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1494572054342},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1494572054342},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1494572054342},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1494572054342},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d6a793bcada68d4b6c58392546bc48a482e4a7d3","modified":1494572054342},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1494572054342},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1494572054342},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1494572054342},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1494572054342},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1494572054342},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1494572054342},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1494572054342},{"_id":"themes/next/source/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1494572054342},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1494572054342},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1494572054342},{"_id":"themes/next/source/js/src/utils.js","hash":"803f684fa7d0e729115a48851023a31f6fb6d0a7","modified":1494572054342},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1494572054346},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1494572054346},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"3587602ad777b031628bb5944864d1a4fcfea4ac","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1494572054346},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1494572054346},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1494572054346},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1494572054346},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1494572054346},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1494572054350},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1494572054354},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1494572054354},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1494572054354},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1494572054354},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1494572054354},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1494572054354},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1494572054354},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1494572054354},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1494572054354},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1494572054354},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1494572054358},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1494572054358},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1494572054358},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1494572054358},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1494572054358},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1494572054354},{"_id":"source/_posts/微服务操作模型/microservices-architecture.png","hash":"d05c4a49296f46c3dae530c5aecad26a63574dc1","modified":1550657701914},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1494572054338},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1494572054342},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1494572054342},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1494572054342},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1494572054342},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1494572054342},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1494572054342},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1494572054342},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1494572054342},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1494572054346},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1494572054346},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1494572054350},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1494572054350},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1494572054358},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1494572054358},{"_id":"source/_posts/微服务操作模型/microservices-operations-reference-model.png","hash":"b77b78e8cff29898a5d2cb4307911e33660232f2","modified":1551753344858},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1494572054346},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1494572054346},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1494572054354},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1494572054354},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1494572054358},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"740d37f428b8f4574a76fc95cc25e50e0565f45e","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1494572054338},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"dbc07ec641a537df5918b41ce40a6466712a44f6","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"88c7d75646b66b168213190ee4cd874609afd5e3","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"c089419916988d0f51d89b225460fe11b631e0a3","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8c0276883398651336853d5ec0e9da267a00dd86","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"5f6ea57aabfa30a437059bf8352f1ad829dbd4ff","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"dd310c2d999185e881db007360176ee2f811df10","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1494572054342},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"bb3be8374c31c372ed0995bd8030d2b920d581de","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1494572054342},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1494572054342},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1494572054342},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1494572054342},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1494572054342},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1494572054342},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1494572054346},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1494572054346},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1494572054350},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1494572054354},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1494572054346},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1494572054358},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1494572054354},{"_id":"public/about/index.html","hash":"742b6ca2df26ab886f9311b1da591c06aabf1777","modified":1552561922277},{"_id":"public/categories/index.html","hash":"1e589d5e9a28db8765326f52ec724f8bd5557110","modified":1552561922277},{"_id":"public/tags/index.html","hash":"5943b6ca52ed0a7bcfb3e5b6ae6eff080799418d","modified":1552561922278},{"_id":"public/2017/06/11/Docker安装/index.html","hash":"5c1187b487ecf25662a79db063eb5523d1ff69a2","modified":1552562104697},{"_id":"public/archives/index.html","hash":"7cf2fee8f93a6ec9a3c1115a0e42f0e5eea11156","modified":1552562104698},{"_id":"public/archives/page/2/index.html","hash":"6ec3b8f37fd10f0ec00cc40a8e68855a05c24e10","modified":1552561922278},{"_id":"public/archives/2013/index.html","hash":"a58944d06666273c17a7cdb78b43d47725c31fe2","modified":1552561922278},{"_id":"public/archives/2013/05/index.html","hash":"369e208e286d9fe0be85df9cbdaf47d3ea9a0ded","modified":1552561922278},{"_id":"public/archives/2013/06/index.html","hash":"b3d88165ce06e5d05af69f5ef7155821d1621dce","modified":1552561922278},{"_id":"public/archives/2016/index.html","hash":"be9741c28b916d23ce97f5879dcaba8f3c5a6668","modified":1552561922278},{"_id":"public/archives/2016/03/index.html","hash":"9184eae0d1c659d488bccbf10437a6c0c866f11f","modified":1552561922278},{"_id":"public/archives/2016/06/index.html","hash":"acf1aef72434095234046fdaa0031241083b101e","modified":1552561922278},{"_id":"public/archives/2017/index.html","hash":"4c9d7e613fbf270625f2d6c9aed4809d631aa44e","modified":1552562104698},{"_id":"public/archives/2017/01/index.html","hash":"ee8f34952fc165bcc090000c9b5b02348fa2e7cd","modified":1552561922278},{"_id":"public/archives/2017/06/index.html","hash":"d10fdaa75f1bc32bf898daf95db0697212828271","modified":1552562104698},{"_id":"public/archives/2017/08/index.html","hash":"bba3c37028f4baf25407b810cb17f079c6c5f176","modified":1552561922278},{"_id":"public/archives/2018/index.html","hash":"2503447ea55f070159f62b768bfbf1d540c8a04d","modified":1552562104698},{"_id":"public/archives/2018/03/index.html","hash":"8f5349bbf615ed99ea414b18029fa6073807f7cf","modified":1552561922278},{"_id":"public/archives/2018/05/index.html","hash":"149cc11d32d43154f559408387f3068ec16d9929","modified":1552562104698},{"_id":"public/archives/2018/11/index.html","hash":"11e67a5b383591d3d6ee53a223465957231ad688","modified":1552561922278},{"_id":"public/categories/Server/index.html","hash":"dd01b88563e2581c45cbd3a59f22b629fcc496ad","modified":1552561922278},{"_id":"public/categories/BigData/index.html","hash":"3695cfb97edf8adc15202d4343080240b805f14f","modified":1552561922279},{"_id":"public/categories/Golang/index.html","hash":"3eb21220b8576042888b07c90e58e7b3636bd2ee","modified":1552561922279},{"_id":"public/categories/前端/index.html","hash":"f19511b3ec056d54358239e04a9036ae90de8cd0","modified":1552561922279},{"_id":"public/categories/算法/index.html","hash":"93f4ebada92f451547c2ed9fff4971d17ac0c95b","modified":1552561922279},{"_id":"public/categories/Spring-Boot/index.html","hash":"57f0b1a53eb61d356610b56e5825c18ed35d48b6","modified":1552561922279},{"_id":"public/categories/杂记/index.html","hash":"5910758993baddb2b1504c88586fb5eef06f547b","modified":1552561922279},{"_id":"public/categories/Maven-POM/index.html","hash":"55ee9260a3ff4b9a42411142f3bd64a725d0b68e","modified":1552561922279},{"_id":"public/categories/【微服务-Java】/index.html","hash":"8a5d9070c1ec749a474d03a3846006ec0f0208a0","modified":1552562104698},{"_id":"public/categories/大数据/index.html","hash":"f7ed6c826406342be258679b989cf5a4451a6e08","modified":1552561922279},{"_id":"public/categories/Microservices/index.html","hash":"23d626b6ecc3ca8206036c2319156a83904173ca","modified":1552561922279},{"_id":"public/categories/软件架构设计/index.html","hash":"697da697f2b79b5e22763c6ef9e051092ddf9d82","modified":1552561922279},{"_id":"public/tags/Docker/index.html","hash":"2013a4cdc1640a0ccb161d30544ccd3ce71c9399","modified":1552561922279},{"_id":"public/tags/Technology/index.html","hash":"8ae721498716599a78b8b577e2cf6adae67ef6f8","modified":1552561922279},{"_id":"public/tags/Hadoop/index.html","hash":"9a3343a248ef8407a5ac02252ed80ae44ada03dc","modified":1552561922279},{"_id":"public/tags/Server/index.html","hash":"bb98b6e18b722cc0a57fdac95c1b28e40fb83181","modified":1552561922279},{"_id":"public/tags/Golang/index.html","hash":"79e792d2075f9552cc2f4d8fad61300fb7828e52","modified":1552561922279},{"_id":"public/tags/Go/index.html","hash":"0e802bc1da900814df568c15cc339c842655cbd9","modified":1552561922279},{"_id":"public/tags/Hive/index.html","hash":"4d045cdb1da9d4adb71b16a3d6fd8c2697a11f0d","modified":1552561922279},{"_id":"public/tags/JavaScript/index.html","hash":"98ffef133e4ee743242675ee436fcaf2ea295eed","modified":1552561922279},{"_id":"public/tags/算法/index.html","hash":"01d583ef3f6633fbae7458ac091b2f296a329b60","modified":1552561922279},{"_id":"public/tags/Rides/index.html","hash":"78dc781acf8e227e4cd73c676fd48428c512d764","modified":1552561922279},{"_id":"public/tags/SpringCloud/index.html","hash":"20807ef35b1685f760facebb785c6220b46d20bc","modified":1552561922280},{"_id":"public/tags/Hexo/index.html","hash":"d19912f7852adf21a13f7dd91e0809edc8cbdcc1","modified":1552561922280},{"_id":"public/tags/Maven/index.html","hash":"b7b76d3e45e2ddc23da4ed1328ef9723a9745be5","modified":1552561922280},{"_id":"public/tags/Microservices/index.html","hash":"edb74e29334031fe5cc4f9a719b2ba2072853bfa","modified":1552562104698},{"_id":"public/tags/Java/index.html","hash":"6ca2c6ac901a9fcd51072f51e3ac60c34b9d3c82","modified":1552562104698},{"_id":"public/tags/Netflix/index.html","hash":"cedc137aede00845797a2cb0d38ef754b08fa259","modified":1552562104698},{"_id":"public/tags/Eureka/index.html","hash":"5b563b01852a2ef7e7811cfd8fda6956954d7e21","modified":1552562104698},{"_id":"public/tags/Ribbon/index.html","hash":"0dac9c01eaf8022414704ecee63980d6b3f6d5fc","modified":1552562104698},{"_id":"public/tags/Zuul/index.html","hash":"98d12eb252cd26207ca3d33cb084ef7f815fbb2b","modified":1552562104699},{"_id":"public/tags/架构设计/index.html","hash":"74d5fb7e93e4772d0f8724585d3a164470f027ae","modified":1552561922280},{"_id":"public/2018/11/16/Good-Code-vs-Bad-Code-in-Golang/index.html","hash":"f6c4f73c9d5b5770e130dcd6d6d2e9df3f499cb4","modified":1552562104699},{"_id":"public/2018/05/01/【微服务-Java】Part 1: Building microservices with Spring Cloud and Netflix OSS/index.html","hash":"1839aebffe9d7105661093dbf0fd311a163d0b63","modified":1552561922280},{"_id":"public/2018/03/11/软件架构/index.html","hash":"4aa4c6a1371945c80cbdec5a42e3dfc3d0f886f5","modified":1552562104699},{"_id":"public/2017/08/12/Hive学习笔记/index.html","hash":"13c008fa6ddb3097eeaed243f3a4d3627f434c39","modified":1552561922280},{"_id":"public/2017/08/11/Hadoop HA配置/index.html","hash":"1bde6aad9116059225b63cf94815e52f722cbf8f","modified":1552561922280},{"_id":"public/2017/08/11/Hadoop基础知识整理/index.html","hash":"8a2ad6d3a56d038c98bf808415917b9f6b6e2cb2","modified":1552562104699},{"_id":"public/2017/06/11/微服务操作模型/index.html","hash":"03f879936bb72463aecd76efe113d59c04cd1535","modified":1552562104701},{"_id":"public/2017/06/11/Docker常用命令/index.html","hash":"d29e8acaed99d8aab69e7e3ddd769a59056bc5ef","modified":1552562104701},{"_id":"public/2017/06/11/Docker常用命令 （二）/index.html","hash":"ddbeab393cf75aa58023a15356e526c15cbbbfbe","modified":1552561922280},{"_id":"public/2017/01/12/KMP算法/index.html","hash":"05d8c5d78ba6e2b10eee731c33517a1566161e2c","modified":1552561922280},{"_id":"public/2017/01/11/大数据排重算法：布隆过滤器/index.html","hash":"2f9b13ca732777460efccfc76c6dff5fb8b5fdaf","modified":1552561922280},{"_id":"public/2016/06/20/SpringCloud微服务框架搭建/index.html","hash":"2554a6879013b444f374c60097c50ea2d55f9c33","modified":1552561922281},{"_id":"public/2016/06/20/VPS搭建自己的的Hexo博客/index.html","hash":"82147d62818cf315542120480cc590dc3d7b03f3","modified":1552561922281},{"_id":"public/2016/03/12/pom.xml详解/index.html","hash":"239687c7a957ea4c01ef245af192d4013afc049b","modified":1552561922281},{"_id":"public/2013/06/20/JavaScript继承方式/index.html","hash":"96d3381f6bdc526e23ac4aeaae2075869fca0c0d","modified":1552561922281},{"_id":"public/2013/05/16/Redis的数据结构（二）/index.html","hash":"9a2e00b7e98dacf94a9ed281ac43510461fad761","modified":1552561922281},{"_id":"public/2013/05/15/Redis的数据结构/index.html","hash":"245c8d8f5cb229781c7fe0d55fc41fc289529eb1","modified":1552561922281},{"_id":"public/2013/05/12/Redis/index.html","hash":"7eed7374b7d7c9d9d67ba4f459dc1595eadcf5a9","modified":1552561922281},{"_id":"public/index.html","hash":"9c5f7b3b506ce455d5e2a4f9df7623b0f1fb6c59","modified":1552562104701},{"_id":"public/page/2/index.html","hash":"8a90a61a1d3333a6a8c6637962280e53d9dd649a","modified":1552562104701},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1552561922292},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1552561922292},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1552561922292},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1552561922292},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1552561922292},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1552561922292},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1552561922292},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1552561922292},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1552561922292},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1552561922292},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1552561922292},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1552561922292},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1552561922292},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1552561922292},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1552561922292},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1552561922293},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1552561922293},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1552561922293},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1552561922293},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1552561922293},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1552561922293},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1552561922293},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1552561922293},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1552561922293},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1552561922293},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1552561922293},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1552561922293},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1552561922293},{"_id":"public/2018/11/16/Good-Code-vs-Bad-Code-in-Golang/1-yh90bW8jL4f8pOTZTvbzqw.png:Zone.Identifier","hash":"d59fc84cdd5217c6cf74785703655f78da6b582b","modified":1552561922293},{"_id":"public/2018/11/16/Good-Code-vs-Bad-Code-in-Golang/1-yh90bW8jL4f8pOTZTvbzqw.png","hash":"069fe5c92956d43d723cc632123a26ff9d2a0454","modified":1552561922293},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1552561922972},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1552561922979},{"_id":"public/2017/06/11/微服务操作模型/microservices-1.png","hash":"c0882dace00c8dbde7e5f103cd45e56653d4afa5","modified":1552561922982},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1552561922990},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1552561922990},{"_id":"public/js/src/bootstrap.js","hash":"aab7be0a6e2724b3faa9338db93c19556c559625","modified":1552561922990},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1552561922990},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1552561922990},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1552561922990},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1552561922991},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1552561922991},{"_id":"public/js/src/post-details.js","hash":"af7a417dd1cb02465a7b98211653e7c6192e6d55","modified":1552561922991},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1552561922991},{"_id":"public/js/src/utils.js","hash":"803f684fa7d0e729115a48851023a31f6fb6d0a7","modified":1552561922991},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1552561922991},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"3587602ad777b031628bb5944864d1a4fcfea4ac","modified":1552561922991},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1552561922991},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1552561922991},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1552561922991},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1552561922991},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1552561922991},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1552561922991},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1552561922991},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1552561922991},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1552561922991},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1552561922991},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1552561922991},{"_id":"public/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1552561922991},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1552561922991},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1552561922991},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1552561922991},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1552561922992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1552561922992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1552561922992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1552561922992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1552561922992},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1552561922993},{"_id":"public/css/main.css","hash":"d04bd9359d09f564ea0799c9448234fadadc0a1e","modified":1552561922993},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1552561922993},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1552561922993},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1552561922993},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1552561922993},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1552561922993},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1552561922993},{"_id":"public/lib/Han/dist/han.min.css","hash":"d9c0b3dc9158e717fde36f554709e6c3a22b5f85","modified":1552561922993},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1552561922993},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1552561922993},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1552561922993},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1552561922993},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1552561922993},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1552561922993},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1552561922993},{"_id":"public/lib/Han/dist/han.css","hash":"38e48f275ad00daa9dcdcb8d9b44e576acda4707","modified":1552561922993},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1552561922993},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1552561922994},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1552561922994},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1552561922994},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1552561922994},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1552561922994},{"_id":"public/2017/06/11/微服务操作模型/microservices-1-1.png","hash":"bb60586cedfbc793bbbb0720a69e00474eec8d77","modified":1552561922994},{"_id":"public/2017/06/11/微服务操作模型/microservices-1-2.png","hash":"5d30c0338c9aec279398d577cd715cb0da5a832c","modified":1552561922994},{"_id":"public/2017/06/11/微服务操作模型/microservices-architecture.png","hash":"d05c4a49296f46c3dae530c5aecad26a63574dc1","modified":1552561923003},{"_id":"public/2017/06/11/微服务操作模型/microservices-operations-reference-model.png","hash":"b77b78e8cff29898a5d2cb4307911e33660232f2","modified":1552561923006},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1552561923009},{"_id":"source/_posts/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS.md","hash":"5d9ff0e6143e18d66148133cf4f4c9c0dc02c140","modified":1552561801870},{"_id":"source/_posts/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/mapping-table.png","hash":"333b9331439883c2ccf0d4bd7b40baf37fbca470","modified":1552561801838},{"_id":"source/_posts/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/system-landscape.png","hash":"b9c0a0e9c7fb857a1c4cc0a2e75e49c15d6b0359","modified":1552561801862},{"_id":"public/2018/05/01/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/index.html","hash":"832daf719c8089cd5270d4ea92927de64896e0a1","modified":1552562104704},{"_id":"public/2018/05/01/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/mapping-table.png","hash":"333b9331439883c2ccf0d4bd7b40baf37fbca470","modified":1552562104706},{"_id":"public/2018/05/01/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/system-landscape.png","hash":"b9c0a0e9c7fb857a1c4cc0a2e75e49c15d6b0359","modified":1552562104707}],"Category":[{"name":"Server","_id":"cjt8ja38l000444eicovjtl5y"},{"name":"BigData","_id":"cjt8ja38y000e44eicttnvcsw"},{"name":"Golang","_id":"cjt8ja392000l44eifegyfsxw"},{"name":"前端","_id":"cjt8ja39q001544eigb4z8adp"},{"name":"算法","_id":"cjt8ja39u001c44eizlmyfava"},{"name":"Spring Boot","_id":"cjt8ja39x001k44eiu6c0vsyb"},{"name":"杂记","_id":"cjt8ja39y001o44eignyoifz5"},{"name":"Maven POM","_id":"cjt8ja3a0001u44eizdu4gaf4"},{"name":"【微服务-Java】","_id":"cjt8ja3a1001x44eifcmm09in"},{"name":"大数据","_id":"cjt8ja3a2002044eijub4j8xn"},{"name":"Microservices","_id":"cjt8ja3a2002644eie0h0hgmh"},{"name":"软件架构设计","_id":"cjt8ja3a4002944eiy3d2kbdm"}],"Data":[],"Page":[{"date":"2013-05-16T02:43:38.000Z","type":"about","comments":0,"_content":"\n\n\n# About Me\n\nName : ZhangKui\nWebSite : zhkui.com\nE-Mail : zhkui@zhkui.com","source":"about/index.md","raw":"---\ndate: 2013-05-16 10:43:38\ntype: \"about\"\ncomments: false\n---\n\n\n\n# About Me\n\nName : ZhangKui\nWebSite : zhkui.com\nE-Mail : zhkui@zhkui.com","updated":"2017-05-16T02:51:55.624Z","path":"about/index.html","title":"","layout":"page","_id":"cjt8ja38e000144eipbtkk8qh","content":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><p>Name : ZhangKui<br>WebSite : zhkui.com<br>E-Mail : zhkui@zhkui.com</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"About-Me\"><a href=\"#About-Me\" class=\"headerlink\" title=\"About Me\"></a>About Me</h1><p>Name : ZhangKui<br>WebSite : zhkui.com<br>E-Mail : zhkui@zhkui.com</p>\n"},{"title":"categories","date":"2013-05-12T09:57:29.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2013-05-12 17:57:29\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-05-16T02:45:02.568Z","path":"categories/index.html","layout":"page","_id":"cjt8ja38k000344eidtq8id3n","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2013-05-12T09:55:56.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2013-05-12 17:55:56\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-05-16T02:44:56.676Z","path":"tags/index.html","layout":"page","_id":"cjt8ja3es003n44ei5w47i9ir","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Docker安装","date":"2017-06-11T09:28:43.000Z","_content":"\n# 1.Docker安装\n1. 在ubuntu上安装Docker，用下面命令：\n```bash\n$ sudo apt-get install apt-transport-https\n$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9\n$ sudo bash -c \"echo deb https://get.docker.io/ubuntu docker main > /etc/apt/sources.list.d/docker.list\"\n$ sudo apt-get update\n$ sudo apt-get install lxc-docker\n```\n2. 查看Docker版本\n```bash\n$ sudo docker version\n```\n3. 查看镜像\n```bash\n$ sudo docker images\n```\n4. 运行容器：\n```bash\n$ sudo docker hello-world\n```","source":"_posts/Docker安装.md","raw":"---\ntitle: Docker安装\ndate: 2017-06-11 17:28:43\ncategories:\n  Server\ntags: \n  - Docker\n  - Technology\n---\n\n# 1.Docker安装\n1. 在ubuntu上安装Docker，用下面命令：\n```bash\n$ sudo apt-get install apt-transport-https\n$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9\n$ sudo bash -c \"echo deb https://get.docker.io/ubuntu docker main > /etc/apt/sources.list.d/docker.list\"\n$ sudo apt-get update\n$ sudo apt-get install lxc-docker\n```\n2. 查看Docker版本\n```bash\n$ sudo docker version\n```\n3. 查看镜像\n```bash\n$ sudo docker images\n```\n4. 运行容器：\n```bash\n$ sudo docker hello-world\n```","slug":"Docker安装","published":1,"updated":"2017-09-08T10:20:14.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja389000044eik16m6yqo","content":"<h1 id=\"1-Docker安装\"><a href=\"#1-Docker安装\" class=\"headerlink\" title=\"1.Docker安装\"></a>1.Docker安装</h1><ol>\n<li><p>在ubuntu上安装Docker，用下面命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get install apt-transport-https</div><div class=\"line\">$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9</div><div class=\"line\">$ sudo bash -c <span class=\"string\">\"echo deb https://get.docker.io/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list\"</span></div><div class=\"line\">$ sudo apt-get update</div><div class=\"line\">$ sudo apt-get install lxc-docker</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看Docker版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker version</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker images</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker hello-world</div></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-Docker安装\"><a href=\"#1-Docker安装\" class=\"headerlink\" title=\"1.Docker安装\"></a>1.Docker安装</h1><ol>\n<li><p>在ubuntu上安装Docker，用下面命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo apt-get install apt-transport-https</div><div class=\"line\">$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9</div><div class=\"line\">$ sudo bash -c <span class=\"string\">\"echo deb https://get.docker.io/ubuntu docker main &gt; /etc/apt/sources.list.d/docker.list\"</span></div><div class=\"line\">$ sudo apt-get update</div><div class=\"line\">$ sudo apt-get install lxc-docker</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看Docker版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker version</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker images</div></pre></td></tr></table></figure>\n</li>\n<li><p>运行容器：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo docker hello-world</div></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"Docker常用命令(二)","date":"2017-06-11T09:28:43.000Z","_content":"\n# ps 命令\n> ps命令用于输出容器列表\n> docker ps <选项>\n\n-a、--all=false 列出所有容器。不带 -a 只输出在运行的容器\n--before=\"\" 列出特定容器创建前的容器，包含停止的容器。\n-f、--filter=[] 设置输出过滤。如 \"exited=0\"\n-l、--latest=false 列出最后创建的容器，包含停止的容器\n-q、--quiet=false 只输出容器的id\n\n# push 命令\n> push命令用于将镜像推送到Docker注册服务器\n> docker push <注册名>/<镜像名>:<标签>\n\n注册名中既可以设置Docker Hub 的用户名，也可以设置注册地址\n若不设置标签，则推送所有标签的镜像\n```sh\n$ docker pull user/hello:latest\n```\n如下推送到个人仓库\n```sh\n$ docker pull 192.168.0.33:6666/hello:latest\n$ docker pull yourset.com:6666/hello:latest\n```\n# restart 命令\n> restart命令用户重启容器\n> docker restart <选项><容器名称，id>\n\n-t、time=10 设置从容器停止到重启的等待时间，单位为秒\n```sh\n$ docker restart hello\n```\n# rm 命令\n> rm 命令用于删除容器\n> docker rm <选项><容器名称，id>\n\n-f、--force=false 强制停止容器后删除（使用SIGKILL信号）\n-l、--link=false 在docker run 命令中使用--link 选项，只删除连接，不删除容器。\n-v、--volumes=false 删除连接到容器的数据卷\n若要一次删除所有容器，可在docker ps：命令中使用 -a -q 选项获取容器id只有传给docker rm 命令\n```sh\n$ docker rm `docker ps -aq`\n$ docker rm $(docker ps -aq)\n```\n# rmi 命令\n> rmi命令用于删除镜像。若不指定标签，则删除latest标签\n> docker rim <注册名称>/<镜像名称，id>:<标签>\n\n-f、--force=false 强制删除镜像\n--no-prune=false 不删除不带标签的父级镜像\n```sh\n$ docker rmi hello\n$ docker rmi user/hello:latest\n$ docker rmi 192.168.0.33:6666/hello:latest  #远程仓库镜像\n$ docker pull yourset.com:6666/hello:latest  #远程仓库镜像\n```\n删除所有镜像与删除容器类似\n```sh\n$ docker rmi `docker images -aq`\n```\n\n# run 命令\n> run命令用于指定镜像创建容器\n> docker run <选项><镜像名称，id><命令><参数>\n\ndocker run 命令 与 docker create 基本类似 唯一的不同是 run命令在创建容器后会启动容器，所以参数基本类似，只是多了关于启动后的设置，一下是多出来的命令：\n-d、--detach Detach模式，一般为守护进程模式，容器以后台方式运行\n--rm=false 若容器内的进程终止，则自动删除容器，此选项不能与-d选项一起使用\n--sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样），但不传递SIGCHLD、SIGKILL、SIGSTOP信号\n# save 命令\n> save命令用于将镜像保存为tar包文件\n> docker save <选项><镜像名称>:<标签>\n\n-o、--output=\"\" 设置保存的文件名\n若不设置-o选项，tar文件会输出到标准输出，所以必须设置重定向。如果仅指定镜像名称而未指定标签，则将所有标签保存到一个tar文件。\n# search 命令\n> search命令用与在docker hub 中搜索镜像\n> docker search <选项><搜索词>\n\n--automated=false 只显示由docker hub 的automated build 创建的镜像\n--no-trunc=false 显示所有因因为内容过长而省略的部分\n-s、--stars=0 显示滴啊有特定星级以上的镜像\n# start 命令\n> start命令用于启动容器\n>docker start <选项><容器名称，id>\n\n-a、--attrch=false 将标准输入、标准输出、标准错误连接到容器，传递所有信号\n-i、--interactive=false 激活标准输入\n# stop 命令\n> stop命令用于终止容器\n> docker stop <选项><容器名称，id>\n\n-t、--time=10 设置终止容器前的等待时间，单位为秒\n# tag 命令\n> tag命令用于设置镜标签\n> docker tag <选项><镜像名称>:<标签><注册地址，用户名>/<镜像名称>:<标签>\n\n-f、--force=false 即使已拥有标签也强制设置\n如将远程仓库设置标签\n```sh\n$ docker tag hello:latest user/hello:0.1  #设置docker hub上的\n$ docker tag hello:latest youset:6666/hello:0.1  #私人仓库\n```\n# top 命令\n> top命令用于显示容器中正在运行的进程信息\n> docker top <容器名称，id><ps选项>\n\n在<ps选项>中设置 Linux ps 命令的选项\n```sh\n$ docker top hello aux\n```\n# unpause 命令\n> unpause命令用于重启 pause 命令暂停的容器\n> docker unpause <容器名称，id>\n\n# version 命令\n> version命令用于输出docker的版本信息\n\n```sh\ndocker version\n```\n# wait 命令\n> wait 命令等待容器终止，然后输出 Exit Code\n> docker wait <容器名称，id>\n\n# 后记\n单一的容器一般不能满足业务需要，需要一个编排的工具。Docker Compose和Docker Swarm 正是负责快速在集群中部署分布式应用。漫漫长路，学的还有好多，工作虽不是负责这方面的，我想做的只是将自己的想法运行在代码是而已。\n","source":"_posts/Docker常用命令 （二）.md","raw":"---\ntitle: Docker常用命令(二)\ndate: 2017-06-11 17:28:43\ncategories:\n  Server\ntags: \n  - Docker\n  - Technology\n---\n\n# ps 命令\n> ps命令用于输出容器列表\n> docker ps <选项>\n\n-a、--all=false 列出所有容器。不带 -a 只输出在运行的容器\n--before=\"\" 列出特定容器创建前的容器，包含停止的容器。\n-f、--filter=[] 设置输出过滤。如 \"exited=0\"\n-l、--latest=false 列出最后创建的容器，包含停止的容器\n-q、--quiet=false 只输出容器的id\n\n# push 命令\n> push命令用于将镜像推送到Docker注册服务器\n> docker push <注册名>/<镜像名>:<标签>\n\n注册名中既可以设置Docker Hub 的用户名，也可以设置注册地址\n若不设置标签，则推送所有标签的镜像\n```sh\n$ docker pull user/hello:latest\n```\n如下推送到个人仓库\n```sh\n$ docker pull 192.168.0.33:6666/hello:latest\n$ docker pull yourset.com:6666/hello:latest\n```\n# restart 命令\n> restart命令用户重启容器\n> docker restart <选项><容器名称，id>\n\n-t、time=10 设置从容器停止到重启的等待时间，单位为秒\n```sh\n$ docker restart hello\n```\n# rm 命令\n> rm 命令用于删除容器\n> docker rm <选项><容器名称，id>\n\n-f、--force=false 强制停止容器后删除（使用SIGKILL信号）\n-l、--link=false 在docker run 命令中使用--link 选项，只删除连接，不删除容器。\n-v、--volumes=false 删除连接到容器的数据卷\n若要一次删除所有容器，可在docker ps：命令中使用 -a -q 选项获取容器id只有传给docker rm 命令\n```sh\n$ docker rm `docker ps -aq`\n$ docker rm $(docker ps -aq)\n```\n# rmi 命令\n> rmi命令用于删除镜像。若不指定标签，则删除latest标签\n> docker rim <注册名称>/<镜像名称，id>:<标签>\n\n-f、--force=false 强制删除镜像\n--no-prune=false 不删除不带标签的父级镜像\n```sh\n$ docker rmi hello\n$ docker rmi user/hello:latest\n$ docker rmi 192.168.0.33:6666/hello:latest  #远程仓库镜像\n$ docker pull yourset.com:6666/hello:latest  #远程仓库镜像\n```\n删除所有镜像与删除容器类似\n```sh\n$ docker rmi `docker images -aq`\n```\n\n# run 命令\n> run命令用于指定镜像创建容器\n> docker run <选项><镜像名称，id><命令><参数>\n\ndocker run 命令 与 docker create 基本类似 唯一的不同是 run命令在创建容器后会启动容器，所以参数基本类似，只是多了关于启动后的设置，一下是多出来的命令：\n-d、--detach Detach模式，一般为守护进程模式，容器以后台方式运行\n--rm=false 若容器内的进程终止，则自动删除容器，此选项不能与-d选项一起使用\n--sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样），但不传递SIGCHLD、SIGKILL、SIGSTOP信号\n# save 命令\n> save命令用于将镜像保存为tar包文件\n> docker save <选项><镜像名称>:<标签>\n\n-o、--output=\"\" 设置保存的文件名\n若不设置-o选项，tar文件会输出到标准输出，所以必须设置重定向。如果仅指定镜像名称而未指定标签，则将所有标签保存到一个tar文件。\n# search 命令\n> search命令用与在docker hub 中搜索镜像\n> docker search <选项><搜索词>\n\n--automated=false 只显示由docker hub 的automated build 创建的镜像\n--no-trunc=false 显示所有因因为内容过长而省略的部分\n-s、--stars=0 显示滴啊有特定星级以上的镜像\n# start 命令\n> start命令用于启动容器\n>docker start <选项><容器名称，id>\n\n-a、--attrch=false 将标准输入、标准输出、标准错误连接到容器，传递所有信号\n-i、--interactive=false 激活标准输入\n# stop 命令\n> stop命令用于终止容器\n> docker stop <选项><容器名称，id>\n\n-t、--time=10 设置终止容器前的等待时间，单位为秒\n# tag 命令\n> tag命令用于设置镜标签\n> docker tag <选项><镜像名称>:<标签><注册地址，用户名>/<镜像名称>:<标签>\n\n-f、--force=false 即使已拥有标签也强制设置\n如将远程仓库设置标签\n```sh\n$ docker tag hello:latest user/hello:0.1  #设置docker hub上的\n$ docker tag hello:latest youset:6666/hello:0.1  #私人仓库\n```\n# top 命令\n> top命令用于显示容器中正在运行的进程信息\n> docker top <容器名称，id><ps选项>\n\n在<ps选项>中设置 Linux ps 命令的选项\n```sh\n$ docker top hello aux\n```\n# unpause 命令\n> unpause命令用于重启 pause 命令暂停的容器\n> docker unpause <容器名称，id>\n\n# version 命令\n> version命令用于输出docker的版本信息\n\n```sh\ndocker version\n```\n# wait 命令\n> wait 命令等待容器终止，然后输出 Exit Code\n> docker wait <容器名称，id>\n\n# 后记\n单一的容器一般不能满足业务需要，需要一个编排的工具。Docker Compose和Docker Swarm 正是负责快速在集群中部署分布式应用。漫漫长路，学的还有好多，工作虽不是负责这方面的，我想做的只是将自己的想法运行在代码是而已。\n","slug":"Docker常用命令 （二）","published":1,"updated":"2017-09-08T10:19:57.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja38i000244ei1akj5jud","content":"<h1 id=\"ps-命令\"><a href=\"#ps-命令\" class=\"headerlink\" title=\"ps 命令\"></a>ps 命令</h1><blockquote>\n<p>ps命令用于输出容器列表<br>docker ps &lt;选项&gt;</p>\n</blockquote>\n<p>-a、–all=false 列出所有容器。不带 -a 只输出在运行的容器<br>–before=”” 列出特定容器创建前的容器，包含停止的容器。<br>-f、–filter=[] 设置输出过滤。如 “exited=0”<br>-l、–latest=false 列出最后创建的容器，包含停止的容器<br>-q、–quiet=false 只输出容器的id</p>\n<h1 id=\"push-命令\"><a href=\"#push-命令\" class=\"headerlink\" title=\"push 命令\"></a>push 命令</h1><blockquote>\n<p>push命令用于将镜像推送到Docker注册服务器<br>docker push &lt;注册名&gt;/&lt;镜像名&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>注册名中既可以设置Docker Hub 的用户名，也可以设置注册地址<br>若不设置标签，则推送所有标签的镜像<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker pull user/hello:latest</div></pre></td></tr></table></figure></p>\n<p>如下推送到个人仓库<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker pull 192.168.0.33:6666/hello:latest</div><div class=\"line\">$ docker pull yourset.com:6666/hello:latest</div></pre></td></tr></table></figure></p>\n<h1 id=\"restart-命令\"><a href=\"#restart-命令\" class=\"headerlink\" title=\"restart 命令\"></a>restart 命令</h1><blockquote>\n<p>restart命令用户重启容器<br>docker restart &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-t、time=10 设置从容器停止到重启的等待时间，单位为秒<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker restart hello</div></pre></td></tr></table></figure></p>\n<h1 id=\"rm-命令\"><a href=\"#rm-命令\" class=\"headerlink\" title=\"rm 命令\"></a>rm 命令</h1><blockquote>\n<p>rm 命令用于删除容器<br>docker rm &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-f、–force=false 强制停止容器后删除（使用SIGKILL信号）<br>-l、–link=false 在docker run 命令中使用–link 选项，只删除连接，不删除容器。<br>-v、–volumes=false 删除连接到容器的数据卷<br>若要一次删除所有容器，可在docker ps：命令中使用 -a -q 选项获取容器id只有传给docker rm 命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker rm `docker ps -aq`</div><div class=\"line\">$ docker rm $(docker ps -aq)</div></pre></td></tr></table></figure></p>\n<h1 id=\"rmi-命令\"><a href=\"#rmi-命令\" class=\"headerlink\" title=\"rmi 命令\"></a>rmi 命令</h1><blockquote>\n<p>rmi命令用于删除镜像。若不指定标签，则删除latest标签<br>docker rim &lt;注册名称&gt;/&lt;镜像名称，id&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-f、–force=false 强制删除镜像<br>–no-prune=false 不删除不带标签的父级镜像<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker rmi hello</div><div class=\"line\">$ docker rmi user/hello:latest</div><div class=\"line\">$ docker rmi 192.168.0.33:6666/hello:latest  <span class=\"comment\">#远程仓库镜像</span></div><div class=\"line\">$ docker pull yourset.com:6666/hello:latest  <span class=\"comment\">#远程仓库镜像</span></div></pre></td></tr></table></figure></p>\n<p>删除所有镜像与删除容器类似<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker rmi `docker images -aq`</div></pre></td></tr></table></figure></p>\n<h1 id=\"run-命令\"><a href=\"#run-命令\" class=\"headerlink\" title=\"run 命令\"></a>run 命令</h1><blockquote>\n<p>run命令用于指定镜像创建容器<br>docker run &lt;选项&gt;&lt;镜像名称，id&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p>docker run 命令 与 docker create 基本类似 唯一的不同是 run命令在创建容器后会启动容器，所以参数基本类似，只是多了关于启动后的设置，一下是多出来的命令：<br>-d、–detach Detach模式，一般为守护进程模式，容器以后台方式运行<br>–rm=false 若容器内的进程终止，则自动删除容器，此选项不能与-d选项一起使用<br>–sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样），但不传递SIGCHLD、SIGKILL、SIGSTOP信号</p>\n<h1 id=\"save-命令\"><a href=\"#save-命令\" class=\"headerlink\" title=\"save 命令\"></a>save 命令</h1><blockquote>\n<p>save命令用于将镜像保存为tar包文件<br>docker save &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-o、–output=”” 设置保存的文件名<br>若不设置-o选项，tar文件会输出到标准输出，所以必须设置重定向。如果仅指定镜像名称而未指定标签，则将所有标签保存到一个tar文件。</p>\n<h1 id=\"search-命令\"><a href=\"#search-命令\" class=\"headerlink\" title=\"search 命令\"></a>search 命令</h1><blockquote>\n<p>search命令用与在docker hub 中搜索镜像<br>docker search &lt;选项&gt;&lt;搜索词&gt;</p>\n</blockquote>\n<p>–automated=false 只显示由docker hub 的automated build 创建的镜像<br>–no-trunc=false 显示所有因因为内容过长而省略的部分<br>-s、–stars=0 显示滴啊有特定星级以上的镜像</p>\n<h1 id=\"start-命令\"><a href=\"#start-命令\" class=\"headerlink\" title=\"start 命令\"></a>start 命令</h1><blockquote>\n<p>start命令用于启动容器<br>docker start &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-a、–attrch=false 将标准输入、标准输出、标准错误连接到容器，传递所有信号<br>-i、–interactive=false 激活标准输入</p>\n<h1 id=\"stop-命令\"><a href=\"#stop-命令\" class=\"headerlink\" title=\"stop 命令\"></a>stop 命令</h1><blockquote>\n<p>stop命令用于终止容器<br>docker stop &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-t、–time=10 设置终止容器前的等待时间，单位为秒</p>\n<h1 id=\"tag-命令\"><a href=\"#tag-命令\" class=\"headerlink\" title=\"tag 命令\"></a>tag 命令</h1><blockquote>\n<p>tag命令用于设置镜标签<br>docker tag &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;&lt;注册地址，用户名&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-f、–force=false 即使已拥有标签也强制设置<br>如将远程仓库设置标签<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker tag hello:latest user/hello:0.1  <span class=\"comment\">#设置docker hub上的</span></div><div class=\"line\">$ docker tag hello:latest youset:6666/hello:0.1  <span class=\"comment\">#私人仓库</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"top-命令\"><a href=\"#top-命令\" class=\"headerlink\" title=\"top 命令\"></a>top 命令</h1><blockquote>\n<p>top命令用于显示容器中正在运行的进程信息<br>docker top &lt;容器名称，id&gt;<ps选项></ps选项></p>\n</blockquote>\n<p>在<ps选项>中设置 Linux ps 命令的选项<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker top hello aux</div></pre></td></tr></table></figure></ps选项></p>\n<h1 id=\"unpause-命令\"><a href=\"#unpause-命令\" class=\"headerlink\" title=\"unpause 命令\"></a>unpause 命令</h1><blockquote>\n<p>unpause命令用于重启 pause 命令暂停的容器<br>docker unpause &lt;容器名称，id&gt;</p>\n</blockquote>\n<h1 id=\"version-命令\"><a href=\"#version-命令\" class=\"headerlink\" title=\"version 命令\"></a>version 命令</h1><blockquote>\n<p>version命令用于输出docker的版本信息</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker version</div></pre></td></tr></table></figure>\n<h1 id=\"wait-命令\"><a href=\"#wait-命令\" class=\"headerlink\" title=\"wait 命令\"></a>wait 命令</h1><blockquote>\n<p>wait 命令等待容器终止，然后输出 Exit Code<br>docker wait &lt;容器名称，id&gt;</p>\n</blockquote>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>单一的容器一般不能满足业务需要，需要一个编排的工具。Docker Compose和Docker Swarm 正是负责快速在集群中部署分布式应用。漫漫长路，学的还有好多，工作虽不是负责这方面的，我想做的只是将自己的想法运行在代码是而已。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ps-命令\"><a href=\"#ps-命令\" class=\"headerlink\" title=\"ps 命令\"></a>ps 命令</h1><blockquote>\n<p>ps命令用于输出容器列表<br>docker ps &lt;选项&gt;</p>\n</blockquote>\n<p>-a、–all=false 列出所有容器。不带 -a 只输出在运行的容器<br>–before=”” 列出特定容器创建前的容器，包含停止的容器。<br>-f、–filter=[] 设置输出过滤。如 “exited=0”<br>-l、–latest=false 列出最后创建的容器，包含停止的容器<br>-q、–quiet=false 只输出容器的id</p>\n<h1 id=\"push-命令\"><a href=\"#push-命令\" class=\"headerlink\" title=\"push 命令\"></a>push 命令</h1><blockquote>\n<p>push命令用于将镜像推送到Docker注册服务器<br>docker push &lt;注册名&gt;/&lt;镜像名&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>注册名中既可以设置Docker Hub 的用户名，也可以设置注册地址<br>若不设置标签，则推送所有标签的镜像<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker pull user/hello:latest</div></pre></td></tr></table></figure></p>\n<p>如下推送到个人仓库<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker pull 192.168.0.33:6666/hello:latest</div><div class=\"line\">$ docker pull yourset.com:6666/hello:latest</div></pre></td></tr></table></figure></p>\n<h1 id=\"restart-命令\"><a href=\"#restart-命令\" class=\"headerlink\" title=\"restart 命令\"></a>restart 命令</h1><blockquote>\n<p>restart命令用户重启容器<br>docker restart &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-t、time=10 设置从容器停止到重启的等待时间，单位为秒<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker restart hello</div></pre></td></tr></table></figure></p>\n<h1 id=\"rm-命令\"><a href=\"#rm-命令\" class=\"headerlink\" title=\"rm 命令\"></a>rm 命令</h1><blockquote>\n<p>rm 命令用于删除容器<br>docker rm &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-f、–force=false 强制停止容器后删除（使用SIGKILL信号）<br>-l、–link=false 在docker run 命令中使用–link 选项，只删除连接，不删除容器。<br>-v、–volumes=false 删除连接到容器的数据卷<br>若要一次删除所有容器，可在docker ps：命令中使用 -a -q 选项获取容器id只有传给docker rm 命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker rm `docker ps -aq`</div><div class=\"line\">$ docker rm $(docker ps -aq)</div></pre></td></tr></table></figure></p>\n<h1 id=\"rmi-命令\"><a href=\"#rmi-命令\" class=\"headerlink\" title=\"rmi 命令\"></a>rmi 命令</h1><blockquote>\n<p>rmi命令用于删除镜像。若不指定标签，则删除latest标签<br>docker rim &lt;注册名称&gt;/&lt;镜像名称，id&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-f、–force=false 强制删除镜像<br>–no-prune=false 不删除不带标签的父级镜像<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker rmi hello</div><div class=\"line\">$ docker rmi user/hello:latest</div><div class=\"line\">$ docker rmi 192.168.0.33:6666/hello:latest  <span class=\"comment\">#远程仓库镜像</span></div><div class=\"line\">$ docker pull yourset.com:6666/hello:latest  <span class=\"comment\">#远程仓库镜像</span></div></pre></td></tr></table></figure></p>\n<p>删除所有镜像与删除容器类似<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker rmi `docker images -aq`</div></pre></td></tr></table></figure></p>\n<h1 id=\"run-命令\"><a href=\"#run-命令\" class=\"headerlink\" title=\"run 命令\"></a>run 命令</h1><blockquote>\n<p>run命令用于指定镜像创建容器<br>docker run &lt;选项&gt;&lt;镜像名称，id&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p>docker run 命令 与 docker create 基本类似 唯一的不同是 run命令在创建容器后会启动容器，所以参数基本类似，只是多了关于启动后的设置，一下是多出来的命令：<br>-d、–detach Detach模式，一般为守护进程模式，容器以后台方式运行<br>–rm=false 若容器内的进程终止，则自动删除容器，此选项不能与-d选项一起使用<br>–sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样），但不传递SIGCHLD、SIGKILL、SIGSTOP信号</p>\n<h1 id=\"save-命令\"><a href=\"#save-命令\" class=\"headerlink\" title=\"save 命令\"></a>save 命令</h1><blockquote>\n<p>save命令用于将镜像保存为tar包文件<br>docker save &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-o、–output=”” 设置保存的文件名<br>若不设置-o选项，tar文件会输出到标准输出，所以必须设置重定向。如果仅指定镜像名称而未指定标签，则将所有标签保存到一个tar文件。</p>\n<h1 id=\"search-命令\"><a href=\"#search-命令\" class=\"headerlink\" title=\"search 命令\"></a>search 命令</h1><blockquote>\n<p>search命令用与在docker hub 中搜索镜像<br>docker search &lt;选项&gt;&lt;搜索词&gt;</p>\n</blockquote>\n<p>–automated=false 只显示由docker hub 的automated build 创建的镜像<br>–no-trunc=false 显示所有因因为内容过长而省略的部分<br>-s、–stars=0 显示滴啊有特定星级以上的镜像</p>\n<h1 id=\"start-命令\"><a href=\"#start-命令\" class=\"headerlink\" title=\"start 命令\"></a>start 命令</h1><blockquote>\n<p>start命令用于启动容器<br>docker start &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-a、–attrch=false 将标准输入、标准输出、标准错误连接到容器，传递所有信号<br>-i、–interactive=false 激活标准输入</p>\n<h1 id=\"stop-命令\"><a href=\"#stop-命令\" class=\"headerlink\" title=\"stop 命令\"></a>stop 命令</h1><blockquote>\n<p>stop命令用于终止容器<br>docker stop &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-t、–time=10 设置终止容器前的等待时间，单位为秒</p>\n<h1 id=\"tag-命令\"><a href=\"#tag-命令\" class=\"headerlink\" title=\"tag 命令\"></a>tag 命令</h1><blockquote>\n<p>tag命令用于设置镜标签<br>docker tag &lt;选项&gt;&lt;镜像名称&gt;:&lt;标签&gt;&lt;注册地址，用户名&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-f、–force=false 即使已拥有标签也强制设置<br>如将远程仓库设置标签<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker tag hello:latest user/hello:0.1  <span class=\"comment\">#设置docker hub上的</span></div><div class=\"line\">$ docker tag hello:latest youset:6666/hello:0.1  <span class=\"comment\">#私人仓库</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"top-命令\"><a href=\"#top-命令\" class=\"headerlink\" title=\"top 命令\"></a>top 命令</h1><blockquote>\n<p>top命令用于显示容器中正在运行的进程信息<br>docker top &lt;容器名称，id&gt;<ps选项></ps选项></p>\n</blockquote>\n<p>在<ps选项>中设置 Linux ps 命令的选项<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker top hello aux</div></pre></td></tr></table></figure></ps选项></p>\n<h1 id=\"unpause-命令\"><a href=\"#unpause-命令\" class=\"headerlink\" title=\"unpause 命令\"></a>unpause 命令</h1><blockquote>\n<p>unpause命令用于重启 pause 命令暂停的容器<br>docker unpause &lt;容器名称，id&gt;</p>\n</blockquote>\n<h1 id=\"version-命令\"><a href=\"#version-命令\" class=\"headerlink\" title=\"version 命令\"></a>version 命令</h1><blockquote>\n<p>version命令用于输出docker的版本信息</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker version</div></pre></td></tr></table></figure>\n<h1 id=\"wait-命令\"><a href=\"#wait-命令\" class=\"headerlink\" title=\"wait 命令\"></a>wait 命令</h1><blockquote>\n<p>wait 命令等待容器终止，然后输出 Exit Code<br>docker wait &lt;容器名称，id&gt;</p>\n</blockquote>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h1><p>单一的容器一般不能满足业务需要，需要一个编排的工具。Docker Compose和Docker Swarm 正是负责快速在集群中部署分布式应用。漫漫长路，学的还有好多，工作虽不是负责这方面的，我想做的只是将自己的想法运行在代码是而已。</p>\n"},{"title":"Hadoop HA配置","date":"2017-08-11T09:28:43.000Z","_content":"\n# 集群时间同步\n如果集群节点时间不同步，可能会出现节点宕机或引发其它异常问题，所以在生产环境中一般通过配置NTP服务器实现集群时间同步。本集群在master节点设置ntp服务器\n```\n//切换root用户\n$ su root\n# yum install -y ntp\n// 配置时间服务器\n# vim /etc/ntp.conf\n# 禁止所有机器连接ntp服务器\nrestrict default ignore\n# 允许局域网内的所有机器连接ntp服务器\nrestrict 172.16.20.0 mask 255.255.255.0 nomodify notrap\n# 使用本机作为时间服务器\nserver 127.127.1.0\n// 启动ntp服务器\n# service ntpd start\n// 设置ntp服务器开机自动启动\n# chkconfig ntpd on\n```\n集群其它节点通过执行crontab定时任务，每天在指定时间向ntp服务器进行时间同步\n```\n// 切换root用户\n$ su root\n// 执行定时任务，每天00:00向服务器同步时间，并写入日志\n# crontab -e\n00-59  * * * /usr/sbin/ntpdate hadoop-master1>> /home/hadoop/ntpd.log\n// 查看任务\n# crontab -l\n```\n# Zookeeper集群安装\nZookeeper是一个开源分布式协调服务,zookeeper服务可用于：统一命名服务、配置管理、锁服务、选举。大数据应用中主要使用Zookeeper的集群管理功能\n首先下载zookeeper,我这里下载的是zookeeper-3.4.10，\n```\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz\n//解压zookeeper\ntar  -xvf  zookeeper-3.4.10.tar.gz\n// 配置用户环境变量\n$ vi  ~/.bashrc\nexport ZOOKEEPER_HOME=/root/zookeeper-3.4.10\nexport PATH=$PATH:$ZOOKEEPER_HOME/bin\n// 使修改的环境变量生效\n$ source  ~/.bashrc\n// 修改zookeeper的配置文件\n$ cd  /root/zookeeper-3.4.10/conf/\n$ cp  zoo_sample.cfg  zoo.cfg\n$ vi  zoo.cfg\n# 客户端心跳时间(毫秒)\ntickTime=2000\n# 允许心跳间隔的最大时间\ninitLimit=10\n# 同步时限\nsyncLimit=5\n# 数据存储目录\ndataDir=/root/zookeeper-3.4.10/data\n# 数据日志存储目录\ndataLogDir=/root/zookeeper-3.4.10/data/log\n# 端口号\nclientPort=2181\n# 集群节点和服务端口配置\nserver.1=master:2888:3888\nserver.2=slave1:2888:3888\nserver.3=slave2:2888:3888\n# 到每个节点的dataDir目录下创建一个myid文件，在文件里面写如对应服务名称：\n例如节点master\nserver.1=master:2888:3888\nmyid文件里面写而入1\n// 启动\n$ zkServer.sh start\n// 查看状态\n$ zkServer.sh status\n// 关闭\n$ zkServer.sh stop\n```\n# Hadoop HA配置\n## 配置core-site.xml文件\n```\n$ vi  core-site.xml\n\n<configuration>\n  <!-- 指定hdfs的nameservices名称为mycluster，与hdfs-site.xml的HA配置相同 -->\n  <property>\n    <name>fs.defaultFS</name>\n    <value>hdfs://mycluster</value>\n  </property>\n\t\n  <!-- 指定缓存文件存储的路径 -->\n  <property>\n    <name>hadoop.tmp.dir</name>\n    <value>/root/hadoop-2.8.1/tmp</value>\n  </property>\n\n <!-- 配置hdfs文件被永久删除前保留的时间（单位：分钟），默认值为0表明垃圾回收站功能关闭 -->\n  <property>\n    <name>fs.trash.interval</name>\n    <value>1440</value>\n  </property>\n  \n  <!-- 指定zookeeper地址，配置HA时需要 -->\n  <property>\n    <name>ha.zookeeper.quorum</name>\n    <value>master:2181,slave1:2181,slave2:2181</value>\n  </property>\n</configuration>\n```\n## 配置hdfs-site.xml文件\n```\n$ vi  hdfs-site.xml\n\n<configuration>\n  <!-- 指定hdfs元数据存储的路径 -->\n  <property>\n    <name>dfs.namenode.name.dir</name>\n    <value>/root/hadoop-2.8.1/namenode</value>\n  </property>\n\n  <!-- 指定hdfs数据存储的路径 -->\n  <property>\n    <name>dfs.datanode.data.dir</name>\n    <value>/root/hadoop-2.8.1/datanode</value>\n  </property>\n  \n  <!-- 数据备份的个数 -->\n  <property>\n    <name>dfs.replication</name>\n    <value>3</value>\n  </property>\n\n  <!-- 关闭权限验证 -->\n  <property>\n    <name>dfs.permissions.enabled</name>\n    <value>false</value>\n  </property>\n  \n  <!-- 开启WebHDFS功能（基于REST的接口服务） -->\n  <property>\n    <name>dfs.webhdfs.enabled</name>\n    <value>true</value>\n  </property>\n  \n  ### 以下为HDFS HA的配置\n  <!-- 指定hdfs的nameservices名称为mycluster -->\n  <property>\n    <name>dfs.nameservices</name>\n    <value>mycluster</value>\n  </property>\n\n  <!-- 指定mycluster的两个namenode的名称分别为nn1,nn2 -->\n  <property>\n    <name>dfs.ha.namenodes.mycluster</name>\n    <value>nn1,nn2</value>\n  </property>\n\n  <!-- 配置nn1,nn2的rpc通信端口 -->\n  <property>\n    <name>dfs.namenode.rpc-address.mycluster.nn1</name>\n    <value>master:8020</value>\n  </property>\n  <property>\n    <name>dfs.namenode.rpc-address.mycluster.nn2</name>\n    <value>slave1:8020</value>\n  </property>\n\n  <!-- 配置nn1,nn2的http通信端口 -->\n  <property>\n    <name>dfs.namenode.http-address.mycluster.nn1</name>\n    <value>master:50070</value>\n  </property>\n  <property>\n    <name>dfs.namenode.http-address.mycluster.nn2</name>\n    <value>slave1:50070</value>\n  </property>\n\n  <!-- 指定namenode元数据存储在journalnode中的路径 -->\n  <property>\n    <name>dfs.namenode.shared.edits.dir</name>\n<value>qjournal://master:8485;slave1:8485;slave2:8485/mycluste</value>\n  </property>\n  \n  <!-- 指定journalnode日志文件存储的路径 -->\n  <property>\n    <name>dfs.journalnode.edits.dir</name>\n    <value>/root/hadoop-2.8.1/journal</value>\n  </property>\n\n  <!-- 指定HDFS客户端连接active namenode的java类 -->\n  <property>\n<name>dfs.client.failover.proxy.provider.mycluster</name>\n<value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>\n  </property>\n\n  <!-- 配置隔离机制为ssh -->\n  <property>\n    <name>dfs.ha.fencing.methods</name>\n    <value>sshfence</value>\n  </property>\n\n  <!-- 指定秘钥的位置 -->\n  <property>\n    <name>dfs.ha.fencing.ssh.private-key-files</name>\n    <value>/root/.ssh/id_rsa</value>\n  </property>\n  \n  <!-- 开启自动故障转移 -->\n  <property>\n    <name>dfs.ha.automatic-failover.enabled</name>\n    <value>true</value>\n  </property>\n</configuration>\n```\n## 配置mapred-site.xml文件\n```\n$ vim mapred-site.xml\n\n<configuration>\n  <!-- 指定MapReduce计算框架使用YARN -->\n  <property>\n    <name>mapreduce.framework.name</name>\n    <value>yarn</value>\n  </property>\n\n  <!-- 指定jobhistory server的rpc地址 -->\n  <property>\n    <name>mapreduce.jobhistory.address</name>\n    <value>master:10020</value>\n  </property>\n\n  <!-- 指定jobhistory server的http地址 -->\n  <property>\n    <name>mapreduce.jobhistory.webapp.address</name>\n    <value>master:19888</value>\n  </property>\n\n  <!-- 开启uber模式（针对小作业的优化） -->\n  <property>\n    <name>mapreduce.job.ubertask.enable</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置启动uber模式的最大map数 -->\n  <property>\n    <name>mapreduce.job.ubertask.maxmaps</name>\n    <value>9</value>\n  </property>\n\n  <!-- 配置启动uber模式的最大reduce数 -->\n  <property>\n    <name>mapreduce.job.ubertask.maxreduces</name>\n    <value>1</value>\n  </property>\n</configuration>\n```\n## 配置yarn-site.xml文件\n```\n$ vim yarn-site.xml\n\n<configuration>\n  <!-- NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序 -->\n  <property>\n    <name>yarn.nodemanager.aux-services</name>\n    <value>mapreduce_shuffle</value>\n  </property>\n\n  <!-- 配置Web Application Proxy安全代理（防止yarn被攻击） -->\n  <property>\n    <name>yarn.web-proxy.address</name>\n    <value>master:8888</value>\n  </property>\n  \n  <!-- 开启日志 -->\n  <property>\n    <name>yarn.log-aggregation-enable</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置日志删除时间为7天，-1为禁用，单位为秒 -->\n  <property>\n    <name>yarn.log-aggregation.retain-seconds</name>\n    <value>604800</value>\n  </property>\n\n  <!-- 修改日志目录 -->\n  <property>\n    <name>yarn.nodemanager.remote-app-log-dir</name>\n    <value>/logs</value>\n  </property>\n\n  <!-- 配置nodemanager可用的资源内存 -->\n  <property>\n    <name>yarn.nodemanager.resource.memory-mb</name>\n    <value>2048</value>\n  </property>\n\n  <!-- 配置nodemanager可用的资源CPU -->\n  <property>\n    <name>yarn.nodemanager.resource.cpu-vcores</name>\n    <value>2</value>\n  </property>\n\n``` \n\n# YARN HA的配置\n```\n  <!-- 开启YARN HA -->\n  <property>\n    <name>yarn.resourcemanager.ha.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 启用自动故障转移 -->\n  <property>\n    <name>yarn.resourcemanager.ha.automatic-failover.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 指定YARN HA的名称 -->\n  <property>\n    <name>yarn.resourcemanager.cluster-id</name>\n    <value>yarncluster</value>\n  </property>\n\n  <!-- 指定两个resourcemanager的名称 -->\n  <property>\n    <name>yarn.resourcemanager.ha.rm-ids</name>\n    <value>rm1,rm2</value>\n  </property>\n\n  <!-- 配置rm1，rm2的主机 -->\n  <property>\n    <name>yarn.resourcemanager.hostname.rm1</name>\n    <value>slave1</value>\n  </property>\n  <property>\n    <name>yarn.resourcemanager.hostname.rm2</name>\n    <value>slave2</value>\n  </property>\n\n  <!-- 配置YARN的http端口 -->\n  <property>\n    <name>yarn.resourcemanager.webapp.address.rm1</name>\n    <value>slave1:8088</value>\n  </property>\t\n  <property>\n    <name>yarn.resourcemanager.webapp.address.rm2</name>\n    <value>slave2:8088</value>\n  </property>\n\n  <!-- 配置zookeeper的地址 -->\n  <property>\n    <name>yarn.resourcemanager.zk-address</name>\n    <value>master:2181,slave1:2181,slave2:2181</value>\n  </property>\n\n  <!-- 配置zookeeper的存储位置 -->\n  <property>\n    <name>yarn.resourcemanager.zk-state-store.parent-path</name>\n    <value>/rmstore</value>\n  </property>\n\n  <!-- 开启yarn resourcemanager restart -->\n  <property>\n    <name>yarn.resourcemanager.recovery.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置resourcemanager的状态存储到zookeeper中 -->\n  <property>\n    <name>yarn.resourcemanager.store.class</name>\n    <value>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore</value>\n  </property>\n\n  <!-- 开启yarn nodemanager restart -->\n  <property>\n    <name>yarn.nodemanager.recovery.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置nodemanager IPC的通信端口 -->\n  <property>\n    <name>yarn.nodemanager.address</name>\n    <value>0.0.0.0:45454</value>\n  </property>\n</configuration>\n```\n# Hadoop集群的初始化\n启动zookeeper集群（分别在master、slave1和slave2上执行）\n```\n$ zkServer.shstart\n```\n格式化ZKFC（在master上执行）\n```\n$ hdfs  zkfc  -formatZK\n```\n// 启动journalnode（分别在master、slave1和slave2上执行）\n```\n$ hadoop-daemon.shstart  journalnode\n```\n// 格式化HDFS（在master上执行）\n```\n$ hdfs namenode  -format\n```\n// 将格式化后master节点hadoop工作目录中的元数据目录复制到slave1节点\n```\n$scp-r /root/hadoop-2.8.1/namenode/*  slave1:/root/hadoop-2.8.1/namenode/\n```\n// 初始化完毕后可关闭journalnode（分别在slave1、slave2和slave3上执行）\n```\n$ hadoop-daemon.sh  stop  journalnode\n\n# Hadoop集群的启动\n启动zookeeper集群（分别在master、slave和slave2执行）\n```\n$ zkServer. shstart\n```\n启动HDFS（在master执行）\n```\n$ start-dfs.sh\n```\n启动YARN（在slave1执行）\n```\n$ start-yarn.sh\n```\n启动YARN的另一个ResourceManager（在master执行，用于容灾）\n```\n$ yarn-daemon.sh start resourcemanager\n\n启动YARN的历史任务服务（在master1执行）\n```\n$ mr-jobhistory-daemon.sh starthistoryserver\n```","source":"_posts/Hadoop HA配置.md","raw":"---\ntitle: Hadoop HA配置\ndate: 2017-08-11 17:28:43\ncategories:\n  BigData\ntags: \n  - Hadoop\n  - Server\n  - Technology\n---\n\n# 集群时间同步\n如果集群节点时间不同步，可能会出现节点宕机或引发其它异常问题，所以在生产环境中一般通过配置NTP服务器实现集群时间同步。本集群在master节点设置ntp服务器\n```\n//切换root用户\n$ su root\n# yum install -y ntp\n// 配置时间服务器\n# vim /etc/ntp.conf\n# 禁止所有机器连接ntp服务器\nrestrict default ignore\n# 允许局域网内的所有机器连接ntp服务器\nrestrict 172.16.20.0 mask 255.255.255.0 nomodify notrap\n# 使用本机作为时间服务器\nserver 127.127.1.0\n// 启动ntp服务器\n# service ntpd start\n// 设置ntp服务器开机自动启动\n# chkconfig ntpd on\n```\n集群其它节点通过执行crontab定时任务，每天在指定时间向ntp服务器进行时间同步\n```\n// 切换root用户\n$ su root\n// 执行定时任务，每天00:00向服务器同步时间，并写入日志\n# crontab -e\n00-59  * * * /usr/sbin/ntpdate hadoop-master1>> /home/hadoop/ntpd.log\n// 查看任务\n# crontab -l\n```\n# Zookeeper集群安装\nZookeeper是一个开源分布式协调服务,zookeeper服务可用于：统一命名服务、配置管理、锁服务、选举。大数据应用中主要使用Zookeeper的集群管理功能\n首先下载zookeeper,我这里下载的是zookeeper-3.4.10，\n```\nwget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz\n//解压zookeeper\ntar  -xvf  zookeeper-3.4.10.tar.gz\n// 配置用户环境变量\n$ vi  ~/.bashrc\nexport ZOOKEEPER_HOME=/root/zookeeper-3.4.10\nexport PATH=$PATH:$ZOOKEEPER_HOME/bin\n// 使修改的环境变量生效\n$ source  ~/.bashrc\n// 修改zookeeper的配置文件\n$ cd  /root/zookeeper-3.4.10/conf/\n$ cp  zoo_sample.cfg  zoo.cfg\n$ vi  zoo.cfg\n# 客户端心跳时间(毫秒)\ntickTime=2000\n# 允许心跳间隔的最大时间\ninitLimit=10\n# 同步时限\nsyncLimit=5\n# 数据存储目录\ndataDir=/root/zookeeper-3.4.10/data\n# 数据日志存储目录\ndataLogDir=/root/zookeeper-3.4.10/data/log\n# 端口号\nclientPort=2181\n# 集群节点和服务端口配置\nserver.1=master:2888:3888\nserver.2=slave1:2888:3888\nserver.3=slave2:2888:3888\n# 到每个节点的dataDir目录下创建一个myid文件，在文件里面写如对应服务名称：\n例如节点master\nserver.1=master:2888:3888\nmyid文件里面写而入1\n// 启动\n$ zkServer.sh start\n// 查看状态\n$ zkServer.sh status\n// 关闭\n$ zkServer.sh stop\n```\n# Hadoop HA配置\n## 配置core-site.xml文件\n```\n$ vi  core-site.xml\n\n<configuration>\n  <!-- 指定hdfs的nameservices名称为mycluster，与hdfs-site.xml的HA配置相同 -->\n  <property>\n    <name>fs.defaultFS</name>\n    <value>hdfs://mycluster</value>\n  </property>\n\t\n  <!-- 指定缓存文件存储的路径 -->\n  <property>\n    <name>hadoop.tmp.dir</name>\n    <value>/root/hadoop-2.8.1/tmp</value>\n  </property>\n\n <!-- 配置hdfs文件被永久删除前保留的时间（单位：分钟），默认值为0表明垃圾回收站功能关闭 -->\n  <property>\n    <name>fs.trash.interval</name>\n    <value>1440</value>\n  </property>\n  \n  <!-- 指定zookeeper地址，配置HA时需要 -->\n  <property>\n    <name>ha.zookeeper.quorum</name>\n    <value>master:2181,slave1:2181,slave2:2181</value>\n  </property>\n</configuration>\n```\n## 配置hdfs-site.xml文件\n```\n$ vi  hdfs-site.xml\n\n<configuration>\n  <!-- 指定hdfs元数据存储的路径 -->\n  <property>\n    <name>dfs.namenode.name.dir</name>\n    <value>/root/hadoop-2.8.1/namenode</value>\n  </property>\n\n  <!-- 指定hdfs数据存储的路径 -->\n  <property>\n    <name>dfs.datanode.data.dir</name>\n    <value>/root/hadoop-2.8.1/datanode</value>\n  </property>\n  \n  <!-- 数据备份的个数 -->\n  <property>\n    <name>dfs.replication</name>\n    <value>3</value>\n  </property>\n\n  <!-- 关闭权限验证 -->\n  <property>\n    <name>dfs.permissions.enabled</name>\n    <value>false</value>\n  </property>\n  \n  <!-- 开启WebHDFS功能（基于REST的接口服务） -->\n  <property>\n    <name>dfs.webhdfs.enabled</name>\n    <value>true</value>\n  </property>\n  \n  ### 以下为HDFS HA的配置\n  <!-- 指定hdfs的nameservices名称为mycluster -->\n  <property>\n    <name>dfs.nameservices</name>\n    <value>mycluster</value>\n  </property>\n\n  <!-- 指定mycluster的两个namenode的名称分别为nn1,nn2 -->\n  <property>\n    <name>dfs.ha.namenodes.mycluster</name>\n    <value>nn1,nn2</value>\n  </property>\n\n  <!-- 配置nn1,nn2的rpc通信端口 -->\n  <property>\n    <name>dfs.namenode.rpc-address.mycluster.nn1</name>\n    <value>master:8020</value>\n  </property>\n  <property>\n    <name>dfs.namenode.rpc-address.mycluster.nn2</name>\n    <value>slave1:8020</value>\n  </property>\n\n  <!-- 配置nn1,nn2的http通信端口 -->\n  <property>\n    <name>dfs.namenode.http-address.mycluster.nn1</name>\n    <value>master:50070</value>\n  </property>\n  <property>\n    <name>dfs.namenode.http-address.mycluster.nn2</name>\n    <value>slave1:50070</value>\n  </property>\n\n  <!-- 指定namenode元数据存储在journalnode中的路径 -->\n  <property>\n    <name>dfs.namenode.shared.edits.dir</name>\n<value>qjournal://master:8485;slave1:8485;slave2:8485/mycluste</value>\n  </property>\n  \n  <!-- 指定journalnode日志文件存储的路径 -->\n  <property>\n    <name>dfs.journalnode.edits.dir</name>\n    <value>/root/hadoop-2.8.1/journal</value>\n  </property>\n\n  <!-- 指定HDFS客户端连接active namenode的java类 -->\n  <property>\n<name>dfs.client.failover.proxy.provider.mycluster</name>\n<value>org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider</value>\n  </property>\n\n  <!-- 配置隔离机制为ssh -->\n  <property>\n    <name>dfs.ha.fencing.methods</name>\n    <value>sshfence</value>\n  </property>\n\n  <!-- 指定秘钥的位置 -->\n  <property>\n    <name>dfs.ha.fencing.ssh.private-key-files</name>\n    <value>/root/.ssh/id_rsa</value>\n  </property>\n  \n  <!-- 开启自动故障转移 -->\n  <property>\n    <name>dfs.ha.automatic-failover.enabled</name>\n    <value>true</value>\n  </property>\n</configuration>\n```\n## 配置mapred-site.xml文件\n```\n$ vim mapred-site.xml\n\n<configuration>\n  <!-- 指定MapReduce计算框架使用YARN -->\n  <property>\n    <name>mapreduce.framework.name</name>\n    <value>yarn</value>\n  </property>\n\n  <!-- 指定jobhistory server的rpc地址 -->\n  <property>\n    <name>mapreduce.jobhistory.address</name>\n    <value>master:10020</value>\n  </property>\n\n  <!-- 指定jobhistory server的http地址 -->\n  <property>\n    <name>mapreduce.jobhistory.webapp.address</name>\n    <value>master:19888</value>\n  </property>\n\n  <!-- 开启uber模式（针对小作业的优化） -->\n  <property>\n    <name>mapreduce.job.ubertask.enable</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置启动uber模式的最大map数 -->\n  <property>\n    <name>mapreduce.job.ubertask.maxmaps</name>\n    <value>9</value>\n  </property>\n\n  <!-- 配置启动uber模式的最大reduce数 -->\n  <property>\n    <name>mapreduce.job.ubertask.maxreduces</name>\n    <value>1</value>\n  </property>\n</configuration>\n```\n## 配置yarn-site.xml文件\n```\n$ vim yarn-site.xml\n\n<configuration>\n  <!-- NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序 -->\n  <property>\n    <name>yarn.nodemanager.aux-services</name>\n    <value>mapreduce_shuffle</value>\n  </property>\n\n  <!-- 配置Web Application Proxy安全代理（防止yarn被攻击） -->\n  <property>\n    <name>yarn.web-proxy.address</name>\n    <value>master:8888</value>\n  </property>\n  \n  <!-- 开启日志 -->\n  <property>\n    <name>yarn.log-aggregation-enable</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置日志删除时间为7天，-1为禁用，单位为秒 -->\n  <property>\n    <name>yarn.log-aggregation.retain-seconds</name>\n    <value>604800</value>\n  </property>\n\n  <!-- 修改日志目录 -->\n  <property>\n    <name>yarn.nodemanager.remote-app-log-dir</name>\n    <value>/logs</value>\n  </property>\n\n  <!-- 配置nodemanager可用的资源内存 -->\n  <property>\n    <name>yarn.nodemanager.resource.memory-mb</name>\n    <value>2048</value>\n  </property>\n\n  <!-- 配置nodemanager可用的资源CPU -->\n  <property>\n    <name>yarn.nodemanager.resource.cpu-vcores</name>\n    <value>2</value>\n  </property>\n\n``` \n\n# YARN HA的配置\n```\n  <!-- 开启YARN HA -->\n  <property>\n    <name>yarn.resourcemanager.ha.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 启用自动故障转移 -->\n  <property>\n    <name>yarn.resourcemanager.ha.automatic-failover.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 指定YARN HA的名称 -->\n  <property>\n    <name>yarn.resourcemanager.cluster-id</name>\n    <value>yarncluster</value>\n  </property>\n\n  <!-- 指定两个resourcemanager的名称 -->\n  <property>\n    <name>yarn.resourcemanager.ha.rm-ids</name>\n    <value>rm1,rm2</value>\n  </property>\n\n  <!-- 配置rm1，rm2的主机 -->\n  <property>\n    <name>yarn.resourcemanager.hostname.rm1</name>\n    <value>slave1</value>\n  </property>\n  <property>\n    <name>yarn.resourcemanager.hostname.rm2</name>\n    <value>slave2</value>\n  </property>\n\n  <!-- 配置YARN的http端口 -->\n  <property>\n    <name>yarn.resourcemanager.webapp.address.rm1</name>\n    <value>slave1:8088</value>\n  </property>\t\n  <property>\n    <name>yarn.resourcemanager.webapp.address.rm2</name>\n    <value>slave2:8088</value>\n  </property>\n\n  <!-- 配置zookeeper的地址 -->\n  <property>\n    <name>yarn.resourcemanager.zk-address</name>\n    <value>master:2181,slave1:2181,slave2:2181</value>\n  </property>\n\n  <!-- 配置zookeeper的存储位置 -->\n  <property>\n    <name>yarn.resourcemanager.zk-state-store.parent-path</name>\n    <value>/rmstore</value>\n  </property>\n\n  <!-- 开启yarn resourcemanager restart -->\n  <property>\n    <name>yarn.resourcemanager.recovery.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置resourcemanager的状态存储到zookeeper中 -->\n  <property>\n    <name>yarn.resourcemanager.store.class</name>\n    <value>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore</value>\n  </property>\n\n  <!-- 开启yarn nodemanager restart -->\n  <property>\n    <name>yarn.nodemanager.recovery.enabled</name>\n    <value>true</value>\n  </property>\n\n  <!-- 配置nodemanager IPC的通信端口 -->\n  <property>\n    <name>yarn.nodemanager.address</name>\n    <value>0.0.0.0:45454</value>\n  </property>\n</configuration>\n```\n# Hadoop集群的初始化\n启动zookeeper集群（分别在master、slave1和slave2上执行）\n```\n$ zkServer.shstart\n```\n格式化ZKFC（在master上执行）\n```\n$ hdfs  zkfc  -formatZK\n```\n// 启动journalnode（分别在master、slave1和slave2上执行）\n```\n$ hadoop-daemon.shstart  journalnode\n```\n// 格式化HDFS（在master上执行）\n```\n$ hdfs namenode  -format\n```\n// 将格式化后master节点hadoop工作目录中的元数据目录复制到slave1节点\n```\n$scp-r /root/hadoop-2.8.1/namenode/*  slave1:/root/hadoop-2.8.1/namenode/\n```\n// 初始化完毕后可关闭journalnode（分别在slave1、slave2和slave3上执行）\n```\n$ hadoop-daemon.sh  stop  journalnode\n\n# Hadoop集群的启动\n启动zookeeper集群（分别在master、slave和slave2执行）\n```\n$ zkServer. shstart\n```\n启动HDFS（在master执行）\n```\n$ start-dfs.sh\n```\n启动YARN（在slave1执行）\n```\n$ start-yarn.sh\n```\n启动YARN的另一个ResourceManager（在master执行，用于容灾）\n```\n$ yarn-daemon.sh start resourcemanager\n\n启动YARN的历史任务服务（在master1执行）\n```\n$ mr-jobhistory-daemon.sh starthistoryserver\n```","slug":"Hadoop HA配置","published":1,"updated":"2019-03-14T10:55:21.098Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja38o000644eino97qway","content":"<h1 id=\"集群时间同步\"><a href=\"#集群时间同步\" class=\"headerlink\" title=\"集群时间同步\"></a>集群时间同步</h1><p>如果集群节点时间不同步，可能会出现节点宕机或引发其它异常问题，所以在生产环境中一般通过配置NTP服务器实现集群时间同步。本集群在master节点设置ntp服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//切换root用户</div><div class=\"line\">$ su root</div><div class=\"line\"># yum install -y ntp</div><div class=\"line\">// 配置时间服务器</div><div class=\"line\"># vim /etc/ntp.conf</div><div class=\"line\"># 禁止所有机器连接ntp服务器</div><div class=\"line\">restrict default ignore</div><div class=\"line\"># 允许局域网内的所有机器连接ntp服务器</div><div class=\"line\">restrict 172.16.20.0 mask 255.255.255.0 nomodify notrap</div><div class=\"line\"># 使用本机作为时间服务器</div><div class=\"line\">server 127.127.1.0</div><div class=\"line\">// 启动ntp服务器</div><div class=\"line\"># service ntpd start</div><div class=\"line\">// 设置ntp服务器开机自动启动</div><div class=\"line\"># chkconfig ntpd on</div></pre></td></tr></table></figure></p>\n<p>集群其它节点通过执行crontab定时任务，每天在指定时间向ntp服务器进行时间同步<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 切换root用户</div><div class=\"line\">$ su root</div><div class=\"line\">// 执行定时任务，每天00:00向服务器同步时间，并写入日志</div><div class=\"line\"># crontab -e</div><div class=\"line\">00-59  * * * /usr/sbin/ntpdate hadoop-master1&gt;&gt; /home/hadoop/ntpd.log</div><div class=\"line\">// 查看任务</div><div class=\"line\"># crontab -l</div></pre></td></tr></table></figure></p>\n<h1 id=\"Zookeeper集群安装\"><a href=\"#Zookeeper集群安装\" class=\"headerlink\" title=\"Zookeeper集群安装\"></a>Zookeeper集群安装</h1><p>Zookeeper是一个开源分布式协调服务,zookeeper服务可用于：统一命名服务、配置管理、锁服务、选举。大数据应用中主要使用Zookeeper的集群管理功能<br>首先下载zookeeper,我这里下载的是zookeeper-3.4.10，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</div><div class=\"line\">//解压zookeeper</div><div class=\"line\">tar  -xvf  zookeeper-3.4.10.tar.gz</div><div class=\"line\">// 配置用户环境变量</div><div class=\"line\">$ vi  ~/.bashrc</div><div class=\"line\">export ZOOKEEPER_HOME=/root/zookeeper-3.4.10</div><div class=\"line\">export PATH=$PATH:$ZOOKEEPER_HOME/bin</div><div class=\"line\">// 使修改的环境变量生效</div><div class=\"line\">$ source  ~/.bashrc</div><div class=\"line\">// 修改zookeeper的配置文件</div><div class=\"line\">$ cd  /root/zookeeper-3.4.10/conf/</div><div class=\"line\">$ cp  zoo_sample.cfg  zoo.cfg</div><div class=\"line\">$ vi  zoo.cfg</div><div class=\"line\"># 客户端心跳时间(毫秒)</div><div class=\"line\">tickTime=2000</div><div class=\"line\"># 允许心跳间隔的最大时间</div><div class=\"line\">initLimit=10</div><div class=\"line\"># 同步时限</div><div class=\"line\">syncLimit=5</div><div class=\"line\"># 数据存储目录</div><div class=\"line\">dataDir=/root/zookeeper-3.4.10/data</div><div class=\"line\"># 数据日志存储目录</div><div class=\"line\">dataLogDir=/root/zookeeper-3.4.10/data/log</div><div class=\"line\"># 端口号</div><div class=\"line\">clientPort=2181</div><div class=\"line\"># 集群节点和服务端口配置</div><div class=\"line\">server.1=master:2888:3888</div><div class=\"line\">server.2=slave1:2888:3888</div><div class=\"line\">server.3=slave2:2888:3888</div><div class=\"line\"># 到每个节点的dataDir目录下创建一个myid文件，在文件里面写如对应服务名称：</div><div class=\"line\">例如节点master</div><div class=\"line\">server.1=master:2888:3888</div><div class=\"line\">myid文件里面写而入1</div><div class=\"line\">// 启动</div><div class=\"line\">$ zkServer.sh start</div><div class=\"line\">// 查看状态</div><div class=\"line\">$ zkServer.sh status</div><div class=\"line\">// 关闭</div><div class=\"line\">$ zkServer.sh stop</div></pre></td></tr></table></figure></p>\n<h1 id=\"Hadoop-HA配置\"><a href=\"#Hadoop-HA配置\" class=\"headerlink\" title=\"Hadoop HA配置\"></a>Hadoop HA配置</h1><h2 id=\"配置core-site-xml文件\"><a href=\"#配置core-site-xml文件\" class=\"headerlink\" title=\"配置core-site.xml文件\"></a>配置core-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vi  core-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- 指定hdfs的nameservices名称为mycluster，与hdfs-site.xml的HA配置相同 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;hdfs://mycluster&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">\t</div><div class=\"line\">  &lt;!-- 指定缓存文件存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/tmp&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\"> &lt;!-- 配置hdfs文件被永久删除前保留的时间（单位：分钟），默认值为0表明垃圾回收站功能关闭 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;fs.trash.interval&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;1440&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 指定zookeeper地址，配置HA时需要 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:2181,slave1:2181,slave2:2181&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"配置hdfs-site-xml文件\"><a href=\"#配置hdfs-site-xml文件\" class=\"headerlink\" title=\"配置hdfs-site.xml文件\"></a>配置hdfs-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vi  hdfs-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- 指定hdfs元数据存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/namenode&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定hdfs数据存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/datanode&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 数据备份的个数 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;3&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 关闭权限验证 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.permissions.enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;false&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 开启WebHDFS功能（基于REST的接口服务） --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  ### 以下为HDFS HA的配置</div><div class=\"line\">  &lt;!-- 指定hdfs的nameservices名称为mycluster --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.nameservices&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;mycluster&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定mycluster的两个namenode的名称分别为nn1,nn2 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.namenodes.mycluster&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;nn1,nn2&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nn1,nn2的rpc通信端口 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn1&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:8020&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn2&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;slave1:8020&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nn1,nn2的http通信端口 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.http-address.mycluster.nn1&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:50070&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.http-address.mycluster.nn2&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;slave1:50070&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定namenode元数据存储在journalnode中的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;</div><div class=\"line\">&lt;value&gt;qjournal://master:8485;slave1:8485;slave2:8485/mycluste&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 指定journalnode日志文件存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/journal&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定HDFS客户端连接active namenode的java类 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">&lt;name&gt;dfs.client.failover.proxy.provider.mycluster&lt;/name&gt;</div><div class=\"line\">&lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置隔离机制为ssh --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;sshfence&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定秘钥的位置 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 开启自动故障转移 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"配置mapred-site-xml文件\"><a href=\"#配置mapred-site-xml文件\" class=\"headerlink\" title=\"配置mapred-site.xml文件\"></a>配置mapred-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim mapred-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- 指定MapReduce计算框架使用YARN --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;yarn&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定jobhistory server的rpc地址 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:10020&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定jobhistory server的http地址 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:19888&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 开启uber模式（针对小作业的优化） --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.job.ubertask.enable&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置启动uber模式的最大map数 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.job.ubertask.maxmaps&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;9&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置启动uber模式的最大reduce数 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.job.ubertask.maxreduces&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;1&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"配置yarn-site-xml文件\"><a href=\"#配置yarn-site-xml文件\" class=\"headerlink\" title=\"配置yarn-site.xml文件\"></a>配置yarn-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim yarn-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置Web Application Proxy安全代理（防止yarn被攻击） --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.web-proxy.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:8888&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 开启日志 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置日志删除时间为7天，-1为禁用，单位为秒 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;604800&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 修改日志目录 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/logs&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nodemanager可用的资源内存 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;2048&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nodemanager可用的资源CPU --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;2&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\"># YARN HA的配置</div></pre></td></tr></table></figure>\n  <!-- 开启YARN HA -->\n  <property><br>    <name>yarn.resourcemanager.ha.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 启用自动故障转移 -->\n  <property><br>    <name>yarn.resourcemanager.ha.automatic-failover.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 指定YARN HA的名称 -->\n  <property><br>    <name>yarn.resourcemanager.cluster-id</name><br>    <value>yarncluster</value><br>  </property>\n\n  <!-- 指定两个resourcemanager的名称 -->\n  <property><br>    <name>yarn.resourcemanager.ha.rm-ids</name><br>    <value>rm1,rm2</value><br>  </property>\n\n  <!-- 配置rm1，rm2的主机 -->\n  <property><br>    <name>yarn.resourcemanager.hostname.rm1</name><br>    <value>slave1</value><br>  </property><br>  <property><br>    <name>yarn.resourcemanager.hostname.rm2</name><br>    <value>slave2</value><br>  </property>\n\n  <!-- 配置YARN的http端口 -->\n  <property><br>    <name>yarn.resourcemanager.webapp.address.rm1</name><br>    <value>slave1:8088</value><br>  </property><br>  <property><br>    <name>yarn.resourcemanager.webapp.address.rm2</name><br>    <value>slave2:8088</value><br>  </property>\n\n  <!-- 配置zookeeper的地址 -->\n  <property><br>    <name>yarn.resourcemanager.zk-address</name><br>    <value>master:2181,slave1:2181,slave2:2181</value><br>  </property>\n\n  <!-- 配置zookeeper的存储位置 -->\n  <property><br>    <name>yarn.resourcemanager.zk-state-store.parent-path</name><br>    <value>/rmstore</value><br>  </property>\n\n  <!-- 开启yarn resourcemanager restart -->\n  <property><br>    <name>yarn.resourcemanager.recovery.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 配置resourcemanager的状态存储到zookeeper中 -->\n  <property><br>    <name>yarn.resourcemanager.store.class</name><br>    <value>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore</value><br>  </property>\n\n  <!-- 开启yarn nodemanager restart -->\n  <property><br>    <name>yarn.nodemanager.recovery.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 配置nodemanager IPC的通信端口 -->\n<p>  <property><br>    <name>yarn.nodemanager.address</name><br>    <value>0.0.0.0:45454</value><br>  </property><br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hadoop集群的初始化</div><div class=\"line\">启动zookeeper集群（分别在master、slave1和slave2上执行）</div></pre></td></tr></table></figure></p>\n<p>$ zkServer.shstart<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">格式化ZKFC（在master上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hdfs  zkfc  -formatZK<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 启动journalnode（分别在master、slave1和slave2上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hadoop-daemon.shstart  journalnode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 格式化HDFS（在master上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hdfs namenode  -format<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将格式化后master节点hadoop工作目录中的元数据目录复制到slave1节点</div></pre></td></tr></table></figure></p>\n<p>$scp-r /root/hadoop-2.8.1/namenode/*  slave1:/root/hadoop-2.8.1/namenode/<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 初始化完毕后可关闭journalnode（分别在slave1、slave2和slave3上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hadoop-daemon.sh  stop  journalnode</p>\n<h1 id=\"Hadoop集群的启动\"><a href=\"#Hadoop集群的启动\" class=\"headerlink\" title=\"Hadoop集群的启动\"></a>Hadoop集群的启动</h1><p>启动zookeeper集群（分别在master、slave和slave2执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ zkServer. shstart</div></pre></td></tr></table></figure></p>\n<p>启动HDFS（在master执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ start-dfs.sh</div></pre></td></tr></table></figure></p>\n<p>启动YARN（在slave1执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ start-yarn.sh</div></pre></td></tr></table></figure></p>\n<p>启动YARN的另一个ResourceManager（在master执行，用于容灾）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn-daemon.sh start resourcemanager</div><div class=\"line\"></div><div class=\"line\">启动YARN的历史任务服务（在master1执行）</div></pre></td></tr></table></figure></p>\n<p>$ mr-jobhistory-daemon.sh starthistoryserver<br>```</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"集群时间同步\"><a href=\"#集群时间同步\" class=\"headerlink\" title=\"集群时间同步\"></a>集群时间同步</h1><p>如果集群节点时间不同步，可能会出现节点宕机或引发其它异常问题，所以在生产环境中一般通过配置NTP服务器实现集群时间同步。本集群在master节点设置ntp服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//切换root用户</div><div class=\"line\">$ su root</div><div class=\"line\"># yum install -y ntp</div><div class=\"line\">// 配置时间服务器</div><div class=\"line\"># vim /etc/ntp.conf</div><div class=\"line\"># 禁止所有机器连接ntp服务器</div><div class=\"line\">restrict default ignore</div><div class=\"line\"># 允许局域网内的所有机器连接ntp服务器</div><div class=\"line\">restrict 172.16.20.0 mask 255.255.255.0 nomodify notrap</div><div class=\"line\"># 使用本机作为时间服务器</div><div class=\"line\">server 127.127.1.0</div><div class=\"line\">// 启动ntp服务器</div><div class=\"line\"># service ntpd start</div><div class=\"line\">// 设置ntp服务器开机自动启动</div><div class=\"line\"># chkconfig ntpd on</div></pre></td></tr></table></figure></p>\n<p>集群其它节点通过执行crontab定时任务，每天在指定时间向ntp服务器进行时间同步<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 切换root用户</div><div class=\"line\">$ su root</div><div class=\"line\">// 执行定时任务，每天00:00向服务器同步时间，并写入日志</div><div class=\"line\"># crontab -e</div><div class=\"line\">00-59  * * * /usr/sbin/ntpdate hadoop-master1&gt;&gt; /home/hadoop/ntpd.log</div><div class=\"line\">// 查看任务</div><div class=\"line\"># crontab -l</div></pre></td></tr></table></figure></p>\n<h1 id=\"Zookeeper集群安装\"><a href=\"#Zookeeper集群安装\" class=\"headerlink\" title=\"Zookeeper集群安装\"></a>Zookeeper集群安装</h1><p>Zookeeper是一个开源分布式协调服务,zookeeper服务可用于：统一命名服务、配置管理、锁服务、选举。大数据应用中主要使用Zookeeper的集群管理功能<br>首先下载zookeeper,我这里下载的是zookeeper-3.4.10，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</div><div class=\"line\">//解压zookeeper</div><div class=\"line\">tar  -xvf  zookeeper-3.4.10.tar.gz</div><div class=\"line\">// 配置用户环境变量</div><div class=\"line\">$ vi  ~/.bashrc</div><div class=\"line\">export ZOOKEEPER_HOME=/root/zookeeper-3.4.10</div><div class=\"line\">export PATH=$PATH:$ZOOKEEPER_HOME/bin</div><div class=\"line\">// 使修改的环境变量生效</div><div class=\"line\">$ source  ~/.bashrc</div><div class=\"line\">// 修改zookeeper的配置文件</div><div class=\"line\">$ cd  /root/zookeeper-3.4.10/conf/</div><div class=\"line\">$ cp  zoo_sample.cfg  zoo.cfg</div><div class=\"line\">$ vi  zoo.cfg</div><div class=\"line\"># 客户端心跳时间(毫秒)</div><div class=\"line\">tickTime=2000</div><div class=\"line\"># 允许心跳间隔的最大时间</div><div class=\"line\">initLimit=10</div><div class=\"line\"># 同步时限</div><div class=\"line\">syncLimit=5</div><div class=\"line\"># 数据存储目录</div><div class=\"line\">dataDir=/root/zookeeper-3.4.10/data</div><div class=\"line\"># 数据日志存储目录</div><div class=\"line\">dataLogDir=/root/zookeeper-3.4.10/data/log</div><div class=\"line\"># 端口号</div><div class=\"line\">clientPort=2181</div><div class=\"line\"># 集群节点和服务端口配置</div><div class=\"line\">server.1=master:2888:3888</div><div class=\"line\">server.2=slave1:2888:3888</div><div class=\"line\">server.3=slave2:2888:3888</div><div class=\"line\"># 到每个节点的dataDir目录下创建一个myid文件，在文件里面写如对应服务名称：</div><div class=\"line\">例如节点master</div><div class=\"line\">server.1=master:2888:3888</div><div class=\"line\">myid文件里面写而入1</div><div class=\"line\">// 启动</div><div class=\"line\">$ zkServer.sh start</div><div class=\"line\">// 查看状态</div><div class=\"line\">$ zkServer.sh status</div><div class=\"line\">// 关闭</div><div class=\"line\">$ zkServer.sh stop</div></pre></td></tr></table></figure></p>\n<h1 id=\"Hadoop-HA配置\"><a href=\"#Hadoop-HA配置\" class=\"headerlink\" title=\"Hadoop HA配置\"></a>Hadoop HA配置</h1><h2 id=\"配置core-site-xml文件\"><a href=\"#配置core-site-xml文件\" class=\"headerlink\" title=\"配置core-site.xml文件\"></a>配置core-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vi  core-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- 指定hdfs的nameservices名称为mycluster，与hdfs-site.xml的HA配置相同 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;hdfs://mycluster&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">\t</div><div class=\"line\">  &lt;!-- 指定缓存文件存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/tmp&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\"> &lt;!-- 配置hdfs文件被永久删除前保留的时间（单位：分钟），默认值为0表明垃圾回收站功能关闭 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;fs.trash.interval&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;1440&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 指定zookeeper地址，配置HA时需要 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;ha.zookeeper.quorum&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:2181,slave1:2181,slave2:2181&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"配置hdfs-site-xml文件\"><a href=\"#配置hdfs-site-xml文件\" class=\"headerlink\" title=\"配置hdfs-site.xml文件\"></a>配置hdfs-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vi  hdfs-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- 指定hdfs元数据存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/namenode&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定hdfs数据存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/datanode&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 数据备份的个数 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;3&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 关闭权限验证 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.permissions.enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;false&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 开启WebHDFS功能（基于REST的接口服务） --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.webhdfs.enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  ### 以下为HDFS HA的配置</div><div class=\"line\">  &lt;!-- 指定hdfs的nameservices名称为mycluster --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.nameservices&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;mycluster&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定mycluster的两个namenode的名称分别为nn1,nn2 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.namenodes.mycluster&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;nn1,nn2&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nn1,nn2的rpc通信端口 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn1&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:8020&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.rpc-address.mycluster.nn2&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;slave1:8020&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nn1,nn2的http通信端口 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.http-address.mycluster.nn1&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:50070&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.http-address.mycluster.nn2&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;slave1:50070&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定namenode元数据存储在journalnode中的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.namenode.shared.edits.dir&lt;/name&gt;</div><div class=\"line\">&lt;value&gt;qjournal://master:8485;slave1:8485;slave2:8485/mycluste&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 指定journalnode日志文件存储的路径 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.journalnode.edits.dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/hadoop-2.8.1/journal&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定HDFS客户端连接active namenode的java类 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">&lt;name&gt;dfs.client.failover.proxy.provider.mycluster&lt;/name&gt;</div><div class=\"line\">&lt;value&gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置隔离机制为ssh --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.fencing.methods&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;sshfence&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定秘钥的位置 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.fencing.ssh.private-key-files&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/root/.ssh/id_rsa&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 开启自动故障转移 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;dfs.ha.automatic-failover.enabled&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"配置mapred-site-xml文件\"><a href=\"#配置mapred-site-xml文件\" class=\"headerlink\" title=\"配置mapred-site.xml文件\"></a>配置mapred-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim mapred-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- 指定MapReduce计算框架使用YARN --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;yarn&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定jobhistory server的rpc地址 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:10020&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 指定jobhistory server的http地址 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:19888&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 开启uber模式（针对小作业的优化） --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.job.ubertask.enable&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置启动uber模式的最大map数 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.job.ubertask.maxmaps&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;9&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置启动uber模式的最大reduce数 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;mapreduce.job.ubertask.maxreduces&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;1&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">&lt;/configuration&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"配置yarn-site-xml文件\"><a href=\"#配置yarn-site-xml文件\" class=\"headerlink\" title=\"配置yarn-site.xml文件\"></a>配置yarn-site.xml文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ vim yarn-site.xml</div><div class=\"line\"></div><div class=\"line\">&lt;configuration&gt;</div><div class=\"line\">  &lt;!-- NodeManager上运行的附属服务，需配置成mapreduce_shuffle才可运行MapReduce程序 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置Web Application Proxy安全代理（防止yarn被攻击） --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.web-proxy.address&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;master:8888&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\">  </div><div class=\"line\">  &lt;!-- 开启日志 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置日志删除时间为7天，-1为禁用，单位为秒 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;604800&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 修改日志目录 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.remote-app-log-dir&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;/logs&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nodemanager可用的资源内存 --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;2048&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;!-- 配置nodemanager可用的资源CPU --&gt;</div><div class=\"line\">  &lt;property&gt;</div><div class=\"line\">    &lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;2&lt;/value&gt;</div><div class=\"line\">  &lt;/property&gt;</div><div class=\"line\"></div><div class=\"line\">``` </div><div class=\"line\"></div><div class=\"line\"># YARN HA的配置</div></pre></td></tr></table></figure>\n  <!-- 开启YARN HA -->\n  <property><br>    <name>yarn.resourcemanager.ha.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 启用自动故障转移 -->\n  <property><br>    <name>yarn.resourcemanager.ha.automatic-failover.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 指定YARN HA的名称 -->\n  <property><br>    <name>yarn.resourcemanager.cluster-id</name><br>    <value>yarncluster</value><br>  </property>\n\n  <!-- 指定两个resourcemanager的名称 -->\n  <property><br>    <name>yarn.resourcemanager.ha.rm-ids</name><br>    <value>rm1,rm2</value><br>  </property>\n\n  <!-- 配置rm1，rm2的主机 -->\n  <property><br>    <name>yarn.resourcemanager.hostname.rm1</name><br>    <value>slave1</value><br>  </property><br>  <property><br>    <name>yarn.resourcemanager.hostname.rm2</name><br>    <value>slave2</value><br>  </property>\n\n  <!-- 配置YARN的http端口 -->\n  <property><br>    <name>yarn.resourcemanager.webapp.address.rm1</name><br>    <value>slave1:8088</value><br>  </property><br>  <property><br>    <name>yarn.resourcemanager.webapp.address.rm2</name><br>    <value>slave2:8088</value><br>  </property>\n\n  <!-- 配置zookeeper的地址 -->\n  <property><br>    <name>yarn.resourcemanager.zk-address</name><br>    <value>master:2181,slave1:2181,slave2:2181</value><br>  </property>\n\n  <!-- 配置zookeeper的存储位置 -->\n  <property><br>    <name>yarn.resourcemanager.zk-state-store.parent-path</name><br>    <value>/rmstore</value><br>  </property>\n\n  <!-- 开启yarn resourcemanager restart -->\n  <property><br>    <name>yarn.resourcemanager.recovery.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 配置resourcemanager的状态存储到zookeeper中 -->\n  <property><br>    <name>yarn.resourcemanager.store.class</name><br>    <value>org.apache.hadoop.yarn.server.resourcemanager.recovery.ZKRMStateStore</value><br>  </property>\n\n  <!-- 开启yarn nodemanager restart -->\n  <property><br>    <name>yarn.nodemanager.recovery.enabled</name><br>    <value>true</value><br>  </property>\n\n  <!-- 配置nodemanager IPC的通信端口 -->\n<p>  <property><br>    <name>yarn.nodemanager.address</name><br>    <value>0.0.0.0:45454</value><br>  </property><br><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Hadoop集群的初始化</div><div class=\"line\">启动zookeeper集群（分别在master、slave1和slave2上执行）</div></pre></td></tr></table></figure></p>\n<p>$ zkServer.shstart<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">格式化ZKFC（在master上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hdfs  zkfc  -formatZK<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 启动journalnode（分别在master、slave1和slave2上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hadoop-daemon.shstart  journalnode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 格式化HDFS（在master上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hdfs namenode  -format<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将格式化后master节点hadoop工作目录中的元数据目录复制到slave1节点</div></pre></td></tr></table></figure></p>\n<p>$scp-r /root/hadoop-2.8.1/namenode/*  slave1:/root/hadoop-2.8.1/namenode/<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 初始化完毕后可关闭journalnode（分别在slave1、slave2和slave3上执行）</div></pre></td></tr></table></figure></p>\n<p>$ hadoop-daemon.sh  stop  journalnode</p>\n<h1 id=\"Hadoop集群的启动\"><a href=\"#Hadoop集群的启动\" class=\"headerlink\" title=\"Hadoop集群的启动\"></a>Hadoop集群的启动</h1><p>启动zookeeper集群（分别在master、slave和slave2执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ zkServer. shstart</div></pre></td></tr></table></figure></p>\n<p>启动HDFS（在master执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ start-dfs.sh</div></pre></td></tr></table></figure></p>\n<p>启动YARN（在slave1执行）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ start-yarn.sh</div></pre></td></tr></table></figure></p>\n<p>启动YARN的另一个ResourceManager（在master执行，用于容灾）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ yarn-daemon.sh start resourcemanager</div><div class=\"line\"></div><div class=\"line\">启动YARN的历史任务服务（在master1执行）</div></pre></td></tr></table></figure></p>\n<p>$ mr-jobhistory-daemon.sh starthistoryserver<br>```</p>\n"},{"title":"Good Code vs Bad Code in Golang","date":"2018-11-16T06:53:57.000Z","_content":"`This article was transferred from @teivah` [Original](https://medium.com/@teivah/good-code-vs-bad-code-in-golang-84cb3c5da49d)\n![](./1-yh90bW8jL4f8pOTZTvbzqw.png)\n\nRecently, I was asked to detail what makes a good code or a bad code in Golang. I found this exercice very interesting. Actually, interesting enough to write a post about that. To illustrate my answer, I have taken a concrete use cases I faced in the Air Traffic Management (ATM) domain. The project is available in [Github](https://github.com/teivah/golang-good-code-bad-code).\n\n# Context\nFirst, few words to explain the context of the implementation.\nEurocontrol is the organization managing the air traffic across Europe countries. The common network for exchanging data between Eurocontrol and an Air Navigation Service Provider (ANSP) is called AFTN. This network is mainly used to exchange two different message types: ADEXP and ICAO messages. Each message type has its own syntax but in terms of semantic, both types are equivalent (more or less). Given the context, performance must be a key element for the implementation.\nThis project has to provide two implementations for parsing ADEXP messages (ICAO is not managed in the frame of this exercise) based on Go:\n* A bad implementation (package name: [bad](https://github.com/teivah/golang-good-code-bad-code/tree/master/bad))\n* A refactored implementation (package name: [good](https://github.com/teivah/golang-good-code-bad-code/tree/master/good)).\nAn example of an ADEXP message can be found [here](https://raw.githubusercontent.com/teivah/golang-good-code-bad-code/master/resources/tests/adexp.txt).\nIn the frame of this exercise, the parsers handle only a subset of the fields we can find in an ADEXP message. Yet, It is still relevant to illustrate common Go mistakes.\n\n# Parsing\nIn a nutshell, an ADEXP message is a set of tokens. A token type can be either:\n````\n-ARCID ACA878\n````\nMeaning the ARCID (aircraft identifier) is ACA878.\n````\n-EETFIR EHAA 0853\n-EETFIR EBBU 0908\n````\nThis example is a list of FIR (Flight Information Region). The first FIR is EHAA 0853 whereas the second one is EBBU 0908.\n````\n-GEO -GEOID GEO01 -LATTD 490000N -LONGTD 0500000W\n-GEO -GEOID GEO02 -LATTD 500000N -LONGTD 0400000W\n````\nA repeating list of tokens. Each line contains a sublist of tokens (in this example GEOID, LATTD, LONGTD).\nGiven the context, it is important to implement a version leveraging parallelization. So the algorithm is the following one:\n* A preprocessing step to clean and rearrange the input message (we have to clean the potential white spaces, rearrange the tokens which are multi-lined like COMMENT etc.)\n* Then splitting each line in a given goroutine. Each goroutine will be in charge to process one line and to return the result.\n* Last but not least, gathering the results and returning a Message structure. This structure is a common one regardless of the message type (ADEXP or ICAO).\nEach package contains an adexp.go file exposing the main function ParseAdexpMessage().\n\n# Step-by-step comparison\nLet’s now see step by step what I consider as a bad code and how I refactored it.\n\n# String vs []byte\nThe bad implementation handles only string inputs. As Go offers a strong support for bytes operations (basic operation like trim, regexp etc.) and that the input will most likely by a []byte (considering AFTN messages are received through TCP), there’s actually no good reason to force a string input.\n\n# Error management\nThe error management is kind of terrible the bad implementation.We can find some cases where potential errors returned in the second argument are not even managed:\n````\npreprocessed, _ := preprocess(string)\n````\nThe good implementation deals with each potential error:\n````\npreprocessed, err := preprocess(bytes)\nif err != nil {\n  return Message{}, err\n}\n````\nWe can also find some mistakes in the bad implementation like in the following code:\n````\nif len(in) == 0 {\n  return \"\", fmt.Errorf(\"Input is empty\")\n}\n````\nThe first mistake is a syntax one. An error string shall neither be capitalized nor end with a punctuation according to Go standards. The second mistake is due to the fact that if an error string is a simple constant (no formatting is required), a call to errors.New() is slightly more performant.\nThe good implementation looks like:\n````\nif len(in) == 0 {\n\treturn nil, errors.New(\"input is empty\")\n}\n````\n\n# Avoid nesting\nThe mapLine() function is a good example of avoidable nesting calls. The bad implementation:\n````\nfunc mapLine(msg *Message, in string, ch chan string) {\n    if !startWith(in, stringComment) {\n        token, value := parseLine(in)\n        if token != \"\" {\n            f, contains := factory[string(token)]\n            if !contains {\n                ch <- \"ok\"\n            } else {\n                data := f(token, value)\n                enrichMessage(msg, data)\n                ch <- \"ok\"\n            }\n        } else {\n            ch <- \"ok\"\n            return\n        }\n    } else {\n        ch <- \"ok\"\n        return\n    }\n}\n````\nOn the opposite, the good implementation is a flat representation:\n````\nfunc mapLine(in []byte, ch chan interface{}) {\n    // Filter empty lines and comment lines\n    if len(in) == 0 || startWith(in, bytesComment) {\n        ch <- nil\n        return\n    }\n\n    token, value := parseLine(in)\n    if token == nil {\n        ch <- nil\n        log.Warnf(\"Token name is empty on line %v\", string(in))\n        return\n    }\n\n    sToken := string(token)\n    if f, contains := factory[sToken]; contains {\n        ch <- f(sToken, value)\n        return\n    }\n\n    log.Warnf(\"Token %v is not managed by the parser\", string(in))\n    ch <- nil\n}\n````\nThis makes the code easier to read in my opinion. Furthermore, this flat representation must also be applied to errors management. As an example:\n````\na, err := f1()\nif err == nil {\n    b, err := f2()\n    if err == nil {\n        return b, nil\n    } else {\n        return nil, err\n    }\n} else {\n    return nil, err\n}\n````\nShould be replaced by:\n````\na, err := f1()\nif err != nil {\n    return nil, err\n}\nb, err := f2()\nif err != nil {\n    return nil, err\n}\nreturn b, nil\n````\nOnce again, the second code version is easier to read.\n\n# Passing data by reference or by value\nThe signature of the preprocessing function in the bad implementation is:\n````\nfunc preprocess(in container) (container, error) {\n}\n````\nGiven the context of this project (performance does matter) and considering a message can potentially be quite heavy, a better option was to pass a pointer to the container structure instead. Otherwise, in the previous example the container value will be copied during each call.The good implementation does not face this problem as it deals with slices (a simple 24-byte structure regardless of the underlying data):\n````\nfunc preprocess(in []byte) ([][]byte, error) {\n}\n````\nMore generally speaking, passing data either by reference or by value must not be an idiomatic choice.\nPassing data by value could also help to make sure a function will not cause any side effect (like mutating the data passed in the function input). This has several benefits like unit testing or refactoring a code for parallelization for example (otherwise we need to check each subfunction to see if a mutation is made).\nI do believe such choice must really be done carefully depending on the project context.\n\n# Parallelization\nThe bad implementation is based on a good initial idea: leveraging goroutines to parallelize the data processing (one goroutine per line).\nThis is achieved in the bad implementation by iterating over the number of lines and spawning a mapLine() call in a goroutine.\n````\nfor i := 0; i < len(lines); i++ {\n    go mapLine(&msg, lines[i], ch)\n}\n````\nThe mapLine() function takes in arguments three parameters:\n* A pointer to the final Message structure to be returned. It means each mapLine() will enrich the same variable.\n* The current line\n* A channel used for sending a notification once the processing of the line is done\n\nSending a pointer to a shared Message variable breaks one of the main Go principles:\nDon’t communicate by sharing memory, share memory by communicating.\nThere are two main drawbacks to passing this shared variable:\n* Drawback #1: Slices concurrent modifications\n\nBecause the structure contains some slices which can be modified concurrently (by two or more goroutine at the same time), in the bad implementation we had to deal with mutexes.\nFor example, the Message structure contains a Estdata []estdata.\nModifying the slice by appending another estdata must be done this way:\n````\nmutexEstdata.Lock()\nfor _, v := range value {\n    fl := extractFlightLevel(v[subtokenFl])\n    msg.Estdata = append(msg.Estdata, estdata{v[subtokenPtid], v[subtokenEto], fl})\n}\nmutexEstdata.Unlock()\n````\nActually, except very specific use cases, having to use a mutex in a goroutine might be a code smell.\n* Drawback #2: False sharing\n\nSharing memory across threads/goroutines is not a good idea due to potential false sharing (a cache line in a given CPU core cache can be invalidated by another CPU core cache). This means we should avoid as much as possible sharing the same variable across threads/goroutines if they intend to mutate it.\nIn this very example, though, I don’t think false sharing has a huge impact as the input file is quite light (running a performance test with padding fields in the Message structure gives more or less the same result). Yet, that’s always something important to bear in mind in my opinion.\nLet’s see now how is the good implementation dealing with the parallelization:\n````\nfor _, line := range in {\n    go mapLine(line, ch)\n}\n````\nNow, the mapLine() takes only two inputs:\n* The current line\n* A channel. This time this channel is not used to simply send a notification once a line processing is done but also to send the actual result. It means it is not up to the goroutines to modify the final Message structure.\n\nGathering the results is done this way by the parent goroutine (the one spawning the mapLine() calls in separate goroutines):\n````\nmsg := Message{}\n\nfor range in {\n    data := <-ch\n\n    switch data.(type) {\n        // Modify msg variable\n    }\n}\n````\nThis implementation is more aligned, in my opinion, with Go principles to share memory only by communicating. The Message variable is modified by a single goroutine to prevent potential concurrent slices modifications and false sharing.\nOne potential criticism even with the good code is to spawn a goroutine for each line. Such implementation will work because an ADEXP message will not contain thousands of lines. Yet, the simple implementation one request triggering one goroutine does not scale very much under very high throughput. A better option would have been to create a pool of reusable goroutines for example.\n`Edit`: This assumption (one line = one goroutine) was definitely not a good idea as it leads to way too much context switches. For additional information, please take a look at the link in the further reading chapter (at the end of the post).\nLine processing notification\nIn the bad implementation, as described above, once a line processing is achieved by a mapLine() we should indicate it to the parent goroutine. This is done using a chan string channel and a call using:\n````\nch <- \"ok\"\n````\nAs the parent does not actually check the value sent by the channel, a better option would have been to use chan struct{} with a ch <- struct{}{} or even better (GC wise) to use a chan interface{} with a ch <- nil.\nAnother approach (even cleaner in my opinion) would have been to use a sync.WaitGroup as the parent goroutine just need to continue its execution once every mapLine() is done.\n\n# If\nThe Go if statement allows passing a statement before the condition.\nAn improved version of:\n````\nf, contains := factory[string(token)]\nif contains {\n    // Do something\n}\n````\nCan be the following implementation:\n````\nif f, contains := factory[sToken]; contains {\n    // Do something\n}\n````\nIt slightly improves the code readability.\n\n# Switch\nAnother mistake with the bad implementation is to forget the default case in the following switch:\n````\nswitch simpleToken.token {\ncase tokenTitle:\n    msg.Title = value\ncase tokenAdep:\n    msg.Adep = value\ncase tokenAltnz:\n    msg.Alternate = value \n// Other cases\n}\n````\nThe default can be optional if the developer thought about all the different cases. Yet, it is definitely better to catch this specific case like in the following example:\n````\nswitch simpleToken.token {\ncase tokenTitle:\n    msg.Title = value\ncase tokenAdep:\n    msg.Adep = value\ncase tokenAltnz:\n    msg.Alternate = value\n// Other cases    \ndefault:\n    log.Errorf(\"unexpected token type %v\", simpleToken.token)\n    return Message{}, fmt.Errorf(\"unexpected token type %v\", simpleToken.token)\n}\n````\nHandling the default case would help in catching potential bugs made by developers as soon as possible in the development process.\n\n# Recursion\nThe parseComplexLines() is a function to parse a complex token. The algorithm in the bad code is done using recursion:\n````\nfunc parseComplexLines(in string, currentMap map[string]string, \n\tout []map[string]string) []map[string]string {\n\n    match := regexpSubfield.Find([]byte(in))\n\n    if match == nil {\n        out = append(out, currentMap)\n        return out\n    }\n\n    sub := string(match)\n\n    h, l := parseLine(sub)\n\n    _, contains := currentMap[string(h)]\n\n    if contains {\n        out = append(out, currentMap)\n        currentMap = make(map[string]string)\n    }\n\n    currentMap[string(h)] = string(strings.Trim(l, stringEmpty))\n\n    return parseComplexLines(in[len(sub):], currentMap, out)\n}\n````\nYet, Go does not support tail-call elimination to optimize sub-function calls. The good code produces the exact same result but using an iterative algorithm:\n````\nfunc parseComplexToken(token string, value []byte) interface{} {\n    if value == nil {\n        log.Warnf(\"Empty value\")\n        return complexToken{token, nil}\n    }\n\n    var v []map[string]string\n    currentMap := make(map[string]string)\n\n    matches := regexpSubfield.FindAll(value, -1)\n\n    for _, sub := range matches {\n        h, l := parseLine(sub)\n\n        if _, contains := currentMap[string(h)]; contains {\n            v = append(v, currentMap)\n            currentMap = make(map[string]string)\n        }\n\n        currentMap[string(h)] = string(bytes.Trim(l, stringEmpty))\n    }\n    v = append(v, currentMap)\n\n    return complexToken{token, v}\n}\n````\nThe second code will be then more performant than the first one.\n\n# Constants management\nWe must manage a constant value to dissociate ADEXP and ICAO messages. The bad code is doing it this way:\n````\nconst (\n    AdexpType = 0 // TODO constant\n    IcaoType  = 1\n)\n````\nWhereas the good code is a more elegant solution based on Go (elegant) iota:\n````\nconst (\n    AdexpType = iota\n    IcaoType \n)\n````\nIt produces exactly the same result but it reduces potential developer mistakes.\n\n# Receiver functions\nEach parser provides a function to determine whether a message concerns the upper level (at least one route point above the level 350).\nThe bad code implements it this way:\n````\nfunc IsUpperLevel(m Message) bool {\n    for _, r := range m.RoutePoints {\n        if r.FlightLevel > upperLevel {\n            return true\n        }\n    }\n\n    return false\n}\n````\nMeaning we have to pass a Message as an input of the function.\nWhereas the good code is simply a function with a Message receiver:\n````\nfunc (m *Message) IsUpperLevel() bool {\n    for _, r := range m.RoutePoints {\n        if r.FlightLevel > upperLevel {\n            return true\n        }\n    }\n\n    return false\n}\n````\nThe second approach is preferable. We simply indicate the Message struct implements a specific behavior.\nIt might also be a first step to using Go interfaces. For example, if someday we need to create another structure with the same behavior (IsUpperLevel()), the initial code does not even need to be refactored (as Message already implements this behavior).\n\n# Comments\nThis one is pretty obvious but the bad comment is poorly commented.\nOn the other side, I tried to comment the good code as I would do in a real project. Even though I’m not the kind of developer who likes to comment every single line, I still believe it is important to comment at least each function and the main steps in a complex function.\nAs an example:\n````\n// Split each line in a goroutine\nfor _, line := range in {\n    go mapLine(line, ch)\n}\n\nmsg := Message{}\n\n// Gather the goroutine results\nfor range in {\n    // ...\n}\n````\nOne concrete example in addition of a function comment might also be very useful:\n````\n// Parse a line by returning the header (token name) and the value. \n// Example: -COMMENT TEST must returns COMMENT and TEST (in byte slices)\nfunc parseLine(in []byte) ([]byte, []byte) {\n    // ...\n}\n````\nSuch concrete examples can really help another developer in better understanding an existing project.\nLast but not least, according to Go best practices the package itself is also commented.\n````\n/*\nPackage good is a library for parsing the ADEXP messages.\nAn intermediate format Message is built by the parser.\n*/\n\npackage good\n````\n\n# Logging\nAnother obvious example is the lack of logs produced in the bad code. As I’m not a fan of the standard log package, I used an external library called logrus in this project.\n\n# go fmt\nGo provides a set of powerful tools like go fmt. Unfortunately, we forgot to apply it to the bad code whereas it was done on the good code.\n\n# DDD\nDDD brings the concept of ubiquitous language to emphasize the importance of a shared language between all the project stakeholders (business experts, dev, testers etc.).\n This cannot be really measured here in this example, but keeping a simple structure like Message compliant with the language spoken inside of a bounded context is also a good point for the overall project maintainability.\n\n# Performance results\nOn an i7–7700 4x 3.60Ghz, I ran a benchmark test to compare both parsers:\n* Bad implementation: 60430 ns/op\n* Good implementation: 45996 ns/op\nThe bad code is more than 30% slower than the good one.\n\n# Conclusion\nIt is pretty difficult in my opinion to give a general definition of what is a bad and a good code. A code in one context might be considered as good whereas in another context it might be considered as bad.\nThe first obvious characteristic of a good code is to provide a correct solution according to given functional requirements. A code can be performant if it does not fit the requirements, it is pretty useless.\nMeanwhile, it is important for a developer to care about simple, maintainable and performant code.\nThe performance improvement does not materialize from the air, it comes with code complexity increase.\nA good developer is someone able to find the right balance between these characteristics according to a given context.\nJust like in DDD, context is key :)\n\n# Further reading\n[Go code refactoring: the 23x performance hunt](https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7)\n","source":"_posts/Good-Code-vs-Bad-Code-in-Golang.md","raw":"---\ntitle: Good Code vs Bad Code in Golang\ndate: 2018-11-16 14:53:57\ncategories:\n- Golang\ntags:\n- Golang\n- Go\n---\n`This article was transferred from @teivah` [Original](https://medium.com/@teivah/good-code-vs-bad-code-in-golang-84cb3c5da49d)\n![](./1-yh90bW8jL4f8pOTZTvbzqw.png)\n\nRecently, I was asked to detail what makes a good code or a bad code in Golang. I found this exercice very interesting. Actually, interesting enough to write a post about that. To illustrate my answer, I have taken a concrete use cases I faced in the Air Traffic Management (ATM) domain. The project is available in [Github](https://github.com/teivah/golang-good-code-bad-code).\n\n# Context\nFirst, few words to explain the context of the implementation.\nEurocontrol is the organization managing the air traffic across Europe countries. The common network for exchanging data between Eurocontrol and an Air Navigation Service Provider (ANSP) is called AFTN. This network is mainly used to exchange two different message types: ADEXP and ICAO messages. Each message type has its own syntax but in terms of semantic, both types are equivalent (more or less). Given the context, performance must be a key element for the implementation.\nThis project has to provide two implementations for parsing ADEXP messages (ICAO is not managed in the frame of this exercise) based on Go:\n* A bad implementation (package name: [bad](https://github.com/teivah/golang-good-code-bad-code/tree/master/bad))\n* A refactored implementation (package name: [good](https://github.com/teivah/golang-good-code-bad-code/tree/master/good)).\nAn example of an ADEXP message can be found [here](https://raw.githubusercontent.com/teivah/golang-good-code-bad-code/master/resources/tests/adexp.txt).\nIn the frame of this exercise, the parsers handle only a subset of the fields we can find in an ADEXP message. Yet, It is still relevant to illustrate common Go mistakes.\n\n# Parsing\nIn a nutshell, an ADEXP message is a set of tokens. A token type can be either:\n````\n-ARCID ACA878\n````\nMeaning the ARCID (aircraft identifier) is ACA878.\n````\n-EETFIR EHAA 0853\n-EETFIR EBBU 0908\n````\nThis example is a list of FIR (Flight Information Region). The first FIR is EHAA 0853 whereas the second one is EBBU 0908.\n````\n-GEO -GEOID GEO01 -LATTD 490000N -LONGTD 0500000W\n-GEO -GEOID GEO02 -LATTD 500000N -LONGTD 0400000W\n````\nA repeating list of tokens. Each line contains a sublist of tokens (in this example GEOID, LATTD, LONGTD).\nGiven the context, it is important to implement a version leveraging parallelization. So the algorithm is the following one:\n* A preprocessing step to clean and rearrange the input message (we have to clean the potential white spaces, rearrange the tokens which are multi-lined like COMMENT etc.)\n* Then splitting each line in a given goroutine. Each goroutine will be in charge to process one line and to return the result.\n* Last but not least, gathering the results and returning a Message structure. This structure is a common one regardless of the message type (ADEXP or ICAO).\nEach package contains an adexp.go file exposing the main function ParseAdexpMessage().\n\n# Step-by-step comparison\nLet’s now see step by step what I consider as a bad code and how I refactored it.\n\n# String vs []byte\nThe bad implementation handles only string inputs. As Go offers a strong support for bytes operations (basic operation like trim, regexp etc.) and that the input will most likely by a []byte (considering AFTN messages are received through TCP), there’s actually no good reason to force a string input.\n\n# Error management\nThe error management is kind of terrible the bad implementation.We can find some cases where potential errors returned in the second argument are not even managed:\n````\npreprocessed, _ := preprocess(string)\n````\nThe good implementation deals with each potential error:\n````\npreprocessed, err := preprocess(bytes)\nif err != nil {\n  return Message{}, err\n}\n````\nWe can also find some mistakes in the bad implementation like in the following code:\n````\nif len(in) == 0 {\n  return \"\", fmt.Errorf(\"Input is empty\")\n}\n````\nThe first mistake is a syntax one. An error string shall neither be capitalized nor end with a punctuation according to Go standards. The second mistake is due to the fact that if an error string is a simple constant (no formatting is required), a call to errors.New() is slightly more performant.\nThe good implementation looks like:\n````\nif len(in) == 0 {\n\treturn nil, errors.New(\"input is empty\")\n}\n````\n\n# Avoid nesting\nThe mapLine() function is a good example of avoidable nesting calls. The bad implementation:\n````\nfunc mapLine(msg *Message, in string, ch chan string) {\n    if !startWith(in, stringComment) {\n        token, value := parseLine(in)\n        if token != \"\" {\n            f, contains := factory[string(token)]\n            if !contains {\n                ch <- \"ok\"\n            } else {\n                data := f(token, value)\n                enrichMessage(msg, data)\n                ch <- \"ok\"\n            }\n        } else {\n            ch <- \"ok\"\n            return\n        }\n    } else {\n        ch <- \"ok\"\n        return\n    }\n}\n````\nOn the opposite, the good implementation is a flat representation:\n````\nfunc mapLine(in []byte, ch chan interface{}) {\n    // Filter empty lines and comment lines\n    if len(in) == 0 || startWith(in, bytesComment) {\n        ch <- nil\n        return\n    }\n\n    token, value := parseLine(in)\n    if token == nil {\n        ch <- nil\n        log.Warnf(\"Token name is empty on line %v\", string(in))\n        return\n    }\n\n    sToken := string(token)\n    if f, contains := factory[sToken]; contains {\n        ch <- f(sToken, value)\n        return\n    }\n\n    log.Warnf(\"Token %v is not managed by the parser\", string(in))\n    ch <- nil\n}\n````\nThis makes the code easier to read in my opinion. Furthermore, this flat representation must also be applied to errors management. As an example:\n````\na, err := f1()\nif err == nil {\n    b, err := f2()\n    if err == nil {\n        return b, nil\n    } else {\n        return nil, err\n    }\n} else {\n    return nil, err\n}\n````\nShould be replaced by:\n````\na, err := f1()\nif err != nil {\n    return nil, err\n}\nb, err := f2()\nif err != nil {\n    return nil, err\n}\nreturn b, nil\n````\nOnce again, the second code version is easier to read.\n\n# Passing data by reference or by value\nThe signature of the preprocessing function in the bad implementation is:\n````\nfunc preprocess(in container) (container, error) {\n}\n````\nGiven the context of this project (performance does matter) and considering a message can potentially be quite heavy, a better option was to pass a pointer to the container structure instead. Otherwise, in the previous example the container value will be copied during each call.The good implementation does not face this problem as it deals with slices (a simple 24-byte structure regardless of the underlying data):\n````\nfunc preprocess(in []byte) ([][]byte, error) {\n}\n````\nMore generally speaking, passing data either by reference or by value must not be an idiomatic choice.\nPassing data by value could also help to make sure a function will not cause any side effect (like mutating the data passed in the function input). This has several benefits like unit testing or refactoring a code for parallelization for example (otherwise we need to check each subfunction to see if a mutation is made).\nI do believe such choice must really be done carefully depending on the project context.\n\n# Parallelization\nThe bad implementation is based on a good initial idea: leveraging goroutines to parallelize the data processing (one goroutine per line).\nThis is achieved in the bad implementation by iterating over the number of lines and spawning a mapLine() call in a goroutine.\n````\nfor i := 0; i < len(lines); i++ {\n    go mapLine(&msg, lines[i], ch)\n}\n````\nThe mapLine() function takes in arguments three parameters:\n* A pointer to the final Message structure to be returned. It means each mapLine() will enrich the same variable.\n* The current line\n* A channel used for sending a notification once the processing of the line is done\n\nSending a pointer to a shared Message variable breaks one of the main Go principles:\nDon’t communicate by sharing memory, share memory by communicating.\nThere are two main drawbacks to passing this shared variable:\n* Drawback #1: Slices concurrent modifications\n\nBecause the structure contains some slices which can be modified concurrently (by two or more goroutine at the same time), in the bad implementation we had to deal with mutexes.\nFor example, the Message structure contains a Estdata []estdata.\nModifying the slice by appending another estdata must be done this way:\n````\nmutexEstdata.Lock()\nfor _, v := range value {\n    fl := extractFlightLevel(v[subtokenFl])\n    msg.Estdata = append(msg.Estdata, estdata{v[subtokenPtid], v[subtokenEto], fl})\n}\nmutexEstdata.Unlock()\n````\nActually, except very specific use cases, having to use a mutex in a goroutine might be a code smell.\n* Drawback #2: False sharing\n\nSharing memory across threads/goroutines is not a good idea due to potential false sharing (a cache line in a given CPU core cache can be invalidated by another CPU core cache). This means we should avoid as much as possible sharing the same variable across threads/goroutines if they intend to mutate it.\nIn this very example, though, I don’t think false sharing has a huge impact as the input file is quite light (running a performance test with padding fields in the Message structure gives more or less the same result). Yet, that’s always something important to bear in mind in my opinion.\nLet’s see now how is the good implementation dealing with the parallelization:\n````\nfor _, line := range in {\n    go mapLine(line, ch)\n}\n````\nNow, the mapLine() takes only two inputs:\n* The current line\n* A channel. This time this channel is not used to simply send a notification once a line processing is done but also to send the actual result. It means it is not up to the goroutines to modify the final Message structure.\n\nGathering the results is done this way by the parent goroutine (the one spawning the mapLine() calls in separate goroutines):\n````\nmsg := Message{}\n\nfor range in {\n    data := <-ch\n\n    switch data.(type) {\n        // Modify msg variable\n    }\n}\n````\nThis implementation is more aligned, in my opinion, with Go principles to share memory only by communicating. The Message variable is modified by a single goroutine to prevent potential concurrent slices modifications and false sharing.\nOne potential criticism even with the good code is to spawn a goroutine for each line. Such implementation will work because an ADEXP message will not contain thousands of lines. Yet, the simple implementation one request triggering one goroutine does not scale very much under very high throughput. A better option would have been to create a pool of reusable goroutines for example.\n`Edit`: This assumption (one line = one goroutine) was definitely not a good idea as it leads to way too much context switches. For additional information, please take a look at the link in the further reading chapter (at the end of the post).\nLine processing notification\nIn the bad implementation, as described above, once a line processing is achieved by a mapLine() we should indicate it to the parent goroutine. This is done using a chan string channel and a call using:\n````\nch <- \"ok\"\n````\nAs the parent does not actually check the value sent by the channel, a better option would have been to use chan struct{} with a ch <- struct{}{} or even better (GC wise) to use a chan interface{} with a ch <- nil.\nAnother approach (even cleaner in my opinion) would have been to use a sync.WaitGroup as the parent goroutine just need to continue its execution once every mapLine() is done.\n\n# If\nThe Go if statement allows passing a statement before the condition.\nAn improved version of:\n````\nf, contains := factory[string(token)]\nif contains {\n    // Do something\n}\n````\nCan be the following implementation:\n````\nif f, contains := factory[sToken]; contains {\n    // Do something\n}\n````\nIt slightly improves the code readability.\n\n# Switch\nAnother mistake with the bad implementation is to forget the default case in the following switch:\n````\nswitch simpleToken.token {\ncase tokenTitle:\n    msg.Title = value\ncase tokenAdep:\n    msg.Adep = value\ncase tokenAltnz:\n    msg.Alternate = value \n// Other cases\n}\n````\nThe default can be optional if the developer thought about all the different cases. Yet, it is definitely better to catch this specific case like in the following example:\n````\nswitch simpleToken.token {\ncase tokenTitle:\n    msg.Title = value\ncase tokenAdep:\n    msg.Adep = value\ncase tokenAltnz:\n    msg.Alternate = value\n// Other cases    \ndefault:\n    log.Errorf(\"unexpected token type %v\", simpleToken.token)\n    return Message{}, fmt.Errorf(\"unexpected token type %v\", simpleToken.token)\n}\n````\nHandling the default case would help in catching potential bugs made by developers as soon as possible in the development process.\n\n# Recursion\nThe parseComplexLines() is a function to parse a complex token. The algorithm in the bad code is done using recursion:\n````\nfunc parseComplexLines(in string, currentMap map[string]string, \n\tout []map[string]string) []map[string]string {\n\n    match := regexpSubfield.Find([]byte(in))\n\n    if match == nil {\n        out = append(out, currentMap)\n        return out\n    }\n\n    sub := string(match)\n\n    h, l := parseLine(sub)\n\n    _, contains := currentMap[string(h)]\n\n    if contains {\n        out = append(out, currentMap)\n        currentMap = make(map[string]string)\n    }\n\n    currentMap[string(h)] = string(strings.Trim(l, stringEmpty))\n\n    return parseComplexLines(in[len(sub):], currentMap, out)\n}\n````\nYet, Go does not support tail-call elimination to optimize sub-function calls. The good code produces the exact same result but using an iterative algorithm:\n````\nfunc parseComplexToken(token string, value []byte) interface{} {\n    if value == nil {\n        log.Warnf(\"Empty value\")\n        return complexToken{token, nil}\n    }\n\n    var v []map[string]string\n    currentMap := make(map[string]string)\n\n    matches := regexpSubfield.FindAll(value, -1)\n\n    for _, sub := range matches {\n        h, l := parseLine(sub)\n\n        if _, contains := currentMap[string(h)]; contains {\n            v = append(v, currentMap)\n            currentMap = make(map[string]string)\n        }\n\n        currentMap[string(h)] = string(bytes.Trim(l, stringEmpty))\n    }\n    v = append(v, currentMap)\n\n    return complexToken{token, v}\n}\n````\nThe second code will be then more performant than the first one.\n\n# Constants management\nWe must manage a constant value to dissociate ADEXP and ICAO messages. The bad code is doing it this way:\n````\nconst (\n    AdexpType = 0 // TODO constant\n    IcaoType  = 1\n)\n````\nWhereas the good code is a more elegant solution based on Go (elegant) iota:\n````\nconst (\n    AdexpType = iota\n    IcaoType \n)\n````\nIt produces exactly the same result but it reduces potential developer mistakes.\n\n# Receiver functions\nEach parser provides a function to determine whether a message concerns the upper level (at least one route point above the level 350).\nThe bad code implements it this way:\n````\nfunc IsUpperLevel(m Message) bool {\n    for _, r := range m.RoutePoints {\n        if r.FlightLevel > upperLevel {\n            return true\n        }\n    }\n\n    return false\n}\n````\nMeaning we have to pass a Message as an input of the function.\nWhereas the good code is simply a function with a Message receiver:\n````\nfunc (m *Message) IsUpperLevel() bool {\n    for _, r := range m.RoutePoints {\n        if r.FlightLevel > upperLevel {\n            return true\n        }\n    }\n\n    return false\n}\n````\nThe second approach is preferable. We simply indicate the Message struct implements a specific behavior.\nIt might also be a first step to using Go interfaces. For example, if someday we need to create another structure with the same behavior (IsUpperLevel()), the initial code does not even need to be refactored (as Message already implements this behavior).\n\n# Comments\nThis one is pretty obvious but the bad comment is poorly commented.\nOn the other side, I tried to comment the good code as I would do in a real project. Even though I’m not the kind of developer who likes to comment every single line, I still believe it is important to comment at least each function and the main steps in a complex function.\nAs an example:\n````\n// Split each line in a goroutine\nfor _, line := range in {\n    go mapLine(line, ch)\n}\n\nmsg := Message{}\n\n// Gather the goroutine results\nfor range in {\n    // ...\n}\n````\nOne concrete example in addition of a function comment might also be very useful:\n````\n// Parse a line by returning the header (token name) and the value. \n// Example: -COMMENT TEST must returns COMMENT and TEST (in byte slices)\nfunc parseLine(in []byte) ([]byte, []byte) {\n    // ...\n}\n````\nSuch concrete examples can really help another developer in better understanding an existing project.\nLast but not least, according to Go best practices the package itself is also commented.\n````\n/*\nPackage good is a library for parsing the ADEXP messages.\nAn intermediate format Message is built by the parser.\n*/\n\npackage good\n````\n\n# Logging\nAnother obvious example is the lack of logs produced in the bad code. As I’m not a fan of the standard log package, I used an external library called logrus in this project.\n\n# go fmt\nGo provides a set of powerful tools like go fmt. Unfortunately, we forgot to apply it to the bad code whereas it was done on the good code.\n\n# DDD\nDDD brings the concept of ubiquitous language to emphasize the importance of a shared language between all the project stakeholders (business experts, dev, testers etc.).\n This cannot be really measured here in this example, but keeping a simple structure like Message compliant with the language spoken inside of a bounded context is also a good point for the overall project maintainability.\n\n# Performance results\nOn an i7–7700 4x 3.60Ghz, I ran a benchmark test to compare both parsers:\n* Bad implementation: 60430 ns/op\n* Good implementation: 45996 ns/op\nThe bad code is more than 30% slower than the good one.\n\n# Conclusion\nIt is pretty difficult in my opinion to give a general definition of what is a bad and a good code. A code in one context might be considered as good whereas in another context it might be considered as bad.\nThe first obvious characteristic of a good code is to provide a correct solution according to given functional requirements. A code can be performant if it does not fit the requirements, it is pretty useless.\nMeanwhile, it is important for a developer to care about simple, maintainable and performant code.\nThe performance improvement does not materialize from the air, it comes with code complexity increase.\nA good developer is someone able to find the right balance between these characteristics according to a given context.\nJust like in DDD, context is key :)\n\n# Further reading\n[Go code refactoring: the 23x performance hunt](https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7)\n","slug":"Good-Code-vs-Bad-Code-in-Golang","published":1,"updated":"2018-11-16T09:42:47.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja38r000744eidybqpir0","content":"<p><code>This article was transferred from @teivah</code> <a href=\"https://medium.com/@teivah/good-code-vs-bad-code-in-golang-84cb3c5da49d\" target=\"_blank\" rel=\"external\">Original</a><br><img src=\"./1-yh90bW8jL4f8pOTZTvbzqw.png\" alt=\"\"></p>\n<p>Recently, I was asked to detail what makes a good code or a bad code in Golang. I found this exercice very interesting. Actually, interesting enough to write a post about that. To illustrate my answer, I have taken a concrete use cases I faced in the Air Traffic Management (ATM) domain. The project is available in <a href=\"https://github.com/teivah/golang-good-code-bad-code\" target=\"_blank\" rel=\"external\">Github</a>.</p>\n<h1 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h1><p>First, few words to explain the context of the implementation.<br>Eurocontrol is the organization managing the air traffic across Europe countries. The common network for exchanging data between Eurocontrol and an Air Navigation Service Provider (ANSP) is called AFTN. This network is mainly used to exchange two different message types: ADEXP and ICAO messages. Each message type has its own syntax but in terms of semantic, both types are equivalent (more or less). Given the context, performance must be a key element for the implementation.<br>This project has to provide two implementations for parsing ADEXP messages (ICAO is not managed in the frame of this exercise) based on Go:</p>\n<ul>\n<li>A bad implementation (package name: <a href=\"https://github.com/teivah/golang-good-code-bad-code/tree/master/bad\" target=\"_blank\" rel=\"external\">bad</a>)</li>\n<li>A refactored implementation (package name: <a href=\"https://github.com/teivah/golang-good-code-bad-code/tree/master/good\" target=\"_blank\" rel=\"external\">good</a>).<br>An example of an ADEXP message can be found <a href=\"https://raw.githubusercontent.com/teivah/golang-good-code-bad-code/master/resources/tests/adexp.txt\" target=\"_blank\" rel=\"external\">here</a>.<br>In the frame of this exercise, the parsers handle only a subset of the fields we can find in an ADEXP message. Yet, It is still relevant to illustrate common Go mistakes.</li>\n</ul>\n<h1 id=\"Parsing\"><a href=\"#Parsing\" class=\"headerlink\" title=\"Parsing\"></a>Parsing</h1><p>In a nutshell, an ADEXP message is a set of tokens. A token type can be either:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-ARCID ACA878</div></pre></td></tr></table></figure></p>\n<p>Meaning the ARCID (aircraft identifier) is ACA878.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-EETFIR EHAA 0853</div><div class=\"line\">-EETFIR EBBU 0908</div></pre></td></tr></table></figure></p>\n<p>This example is a list of FIR (Flight Information Region). The first FIR is EHAA 0853 whereas the second one is EBBU 0908.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-GEO -GEOID GEO01 -LATTD 490000N -LONGTD 0500000W</div><div class=\"line\">-GEO -GEOID GEO02 -LATTD 500000N -LONGTD 0400000W</div></pre></td></tr></table></figure></p>\n<p>A repeating list of tokens. Each line contains a sublist of tokens (in this example GEOID, LATTD, LONGTD).<br>Given the context, it is important to implement a version leveraging parallelization. So the algorithm is the following one:</p>\n<ul>\n<li>A preprocessing step to clean and rearrange the input message (we have to clean the potential white spaces, rearrange the tokens which are multi-lined like COMMENT etc.)</li>\n<li>Then splitting each line in a given goroutine. Each goroutine will be in charge to process one line and to return the result.</li>\n<li>Last but not least, gathering the results and returning a Message structure. This structure is a common one regardless of the message type (ADEXP or ICAO).<br>Each package contains an adexp.go file exposing the main function ParseAdexpMessage().</li>\n</ul>\n<h1 id=\"Step-by-step-comparison\"><a href=\"#Step-by-step-comparison\" class=\"headerlink\" title=\"Step-by-step comparison\"></a>Step-by-step comparison</h1><p>Let’s now see step by step what I consider as a bad code and how I refactored it.</p>\n<h1 id=\"String-vs-byte\"><a href=\"#String-vs-byte\" class=\"headerlink\" title=\"String vs []byte\"></a>String vs []byte</h1><p>The bad implementation handles only string inputs. As Go offers a strong support for bytes operations (basic operation like trim, regexp etc.) and that the input will most likely by a []byte (considering AFTN messages are received through TCP), there’s actually no good reason to force a string input.</p>\n<h1 id=\"Error-management\"><a href=\"#Error-management\" class=\"headerlink\" title=\"Error management\"></a>Error management</h1><p>The error management is kind of terrible the bad implementation.We can find some cases where potential errors returned in the second argument are not even managed:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">preprocessed, _ := preprocess(string)</div></pre></td></tr></table></figure></p>\n<p>The good implementation deals with each potential error:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">preprocessed, err := preprocess(bytes)</div><div class=\"line\">if err != nil &#123;</div><div class=\"line\">  return Message&#123;&#125;, err</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>We can also find some mistakes in the bad implementation like in the following code:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if len(in) == 0 &#123;</div><div class=\"line\">  return &quot;&quot;, fmt.Errorf(&quot;Input is empty&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The first mistake is a syntax one. An error string shall neither be capitalized nor end with a punctuation according to Go standards. The second mistake is due to the fact that if an error string is a simple constant (no formatting is required), a call to errors.New() is slightly more performant.<br>The good implementation looks like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if len(in) == 0 &#123;</div><div class=\"line\">\treturn nil, errors.New(&quot;input is empty&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"Avoid-nesting\"><a href=\"#Avoid-nesting\" class=\"headerlink\" title=\"Avoid nesting\"></a>Avoid nesting</h1><p>The mapLine() function is a good example of avoidable nesting calls. The bad implementation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">func mapLine(msg *Message, in string, ch chan string) &#123;</div><div class=\"line\">    if !startWith(in, stringComment) &#123;</div><div class=\"line\">        token, value := parseLine(in)</div><div class=\"line\">        if token != &quot;&quot; &#123;</div><div class=\"line\">            f, contains := factory[string(token)]</div><div class=\"line\">            if !contains &#123;</div><div class=\"line\">                ch &lt;- &quot;ok&quot;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                data := f(token, value)</div><div class=\"line\">                enrichMessage(msg, data)</div><div class=\"line\">                ch &lt;- &quot;ok&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ch &lt;- &quot;ok&quot;</div><div class=\"line\">            return</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ch &lt;- &quot;ok&quot;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>On the opposite, the good implementation is a flat representation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func mapLine(in []byte, ch chan interface&#123;&#125;) &#123;</div><div class=\"line\">    // Filter empty lines and comment lines</div><div class=\"line\">    if len(in) == 0 || startWith(in, bytesComment) &#123;</div><div class=\"line\">        ch &lt;- nil</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    token, value := parseLine(in)</div><div class=\"line\">    if token == nil &#123;</div><div class=\"line\">        ch &lt;- nil</div><div class=\"line\">        log.Warnf(&quot;Token name is empty on line %v&quot;, string(in))</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sToken := string(token)</div><div class=\"line\">    if f, contains := factory[sToken]; contains &#123;</div><div class=\"line\">        ch &lt;- f(sToken, value)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    log.Warnf(&quot;Token %v is not managed by the parser&quot;, string(in))</div><div class=\"line\">    ch &lt;- nil</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>This makes the code easier to read in my opinion. Furthermore, this flat representation must also be applied to errors management. As an example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">a, err := f1()</div><div class=\"line\">if err == nil &#123;</div><div class=\"line\">    b, err := f2()</div><div class=\"line\">    if err == nil &#123;</div><div class=\"line\">        return b, nil</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return nil, err</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    return nil, err</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Should be replaced by:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">a, err := f1()</div><div class=\"line\">if err != nil &#123;</div><div class=\"line\">    return nil, err</div><div class=\"line\">&#125;</div><div class=\"line\">b, err := f2()</div><div class=\"line\">if err != nil &#123;</div><div class=\"line\">    return nil, err</div><div class=\"line\">&#125;</div><div class=\"line\">return b, nil</div></pre></td></tr></table></figure></p>\n<p>Once again, the second code version is easier to read.</p>\n<h1 id=\"Passing-data-by-reference-or-by-value\"><a href=\"#Passing-data-by-reference-or-by-value\" class=\"headerlink\" title=\"Passing data by reference or by value\"></a>Passing data by reference or by value</h1><p>The signature of the preprocessing function in the bad implementation is:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">func preprocess(in container) (container, error) &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Given the context of this project (performance does matter) and considering a message can potentially be quite heavy, a better option was to pass a pointer to the container structure instead. Otherwise, in the previous example the container value will be copied during each call.The good implementation does not face this problem as it deals with slices (a simple 24-byte structure regardless of the underlying data):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">func preprocess(in []byte) ([][]byte, error) &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>More generally speaking, passing data either by reference or by value must not be an idiomatic choice.<br>Passing data by value could also help to make sure a function will not cause any side effect (like mutating the data passed in the function input). This has several benefits like unit testing or refactoring a code for parallelization for example (otherwise we need to check each subfunction to see if a mutation is made).<br>I do believe such choice must really be done carefully depending on the project context.</p>\n<h1 id=\"Parallelization\"><a href=\"#Parallelization\" class=\"headerlink\" title=\"Parallelization\"></a>Parallelization</h1><p>The bad implementation is based on a good initial idea: leveraging goroutines to parallelize the data processing (one goroutine per line).<br>This is achieved in the bad implementation by iterating over the number of lines and spawning a mapLine() call in a goroutine.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i := 0; i &lt; len(lines); i++ &#123;</div><div class=\"line\">    go mapLine(&amp;msg, lines[i], ch)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The mapLine() function takes in arguments three parameters:</p>\n<ul>\n<li>A pointer to the final Message structure to be returned. It means each mapLine() will enrich the same variable.</li>\n<li>The current line</li>\n<li>A channel used for sending a notification once the processing of the line is done</li>\n</ul>\n<p>Sending a pointer to a shared Message variable breaks one of the main Go principles:<br>Don’t communicate by sharing memory, share memory by communicating.<br>There are two main drawbacks to passing this shared variable:</p>\n<ul>\n<li>Drawback #1: Slices concurrent modifications</li>\n</ul>\n<p>Because the structure contains some slices which can be modified concurrently (by two or more goroutine at the same time), in the bad implementation we had to deal with mutexes.<br>For example, the Message structure contains a Estdata []estdata.<br>Modifying the slice by appending another estdata must be done this way:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">mutexEstdata.Lock()</div><div class=\"line\">for _, v := range value &#123;</div><div class=\"line\">    fl := extractFlightLevel(v[subtokenFl])</div><div class=\"line\">    msg.Estdata = append(msg.Estdata, estdata&#123;v[subtokenPtid], v[subtokenEto], fl&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">mutexEstdata.Unlock()</div></pre></td></tr></table></figure></p>\n<p>Actually, except very specific use cases, having to use a mutex in a goroutine might be a code smell.</p>\n<ul>\n<li>Drawback #2: False sharing</li>\n</ul>\n<p>Sharing memory across threads/goroutines is not a good idea due to potential false sharing (a cache line in a given CPU core cache can be invalidated by another CPU core cache). This means we should avoid as much as possible sharing the same variable across threads/goroutines if they intend to mutate it.<br>In this very example, though, I don’t think false sharing has a huge impact as the input file is quite light (running a performance test with padding fields in the Message structure gives more or less the same result). Yet, that’s always something important to bear in mind in my opinion.<br>Let’s see now how is the good implementation dealing with the parallelization:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for _, line := range in &#123;</div><div class=\"line\">    go mapLine(line, ch)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Now, the mapLine() takes only two inputs:</p>\n<ul>\n<li>The current line</li>\n<li>A channel. This time this channel is not used to simply send a notification once a line processing is done but also to send the actual result. It means it is not up to the goroutines to modify the final Message structure.</li>\n</ul>\n<p>Gathering the results is done this way by the parent goroutine (the one spawning the mapLine() calls in separate goroutines):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">msg := Message&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">for range in &#123;</div><div class=\"line\">    data := &lt;-ch</div><div class=\"line\"></div><div class=\"line\">    switch data.(type) &#123;</div><div class=\"line\">        // Modify msg variable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>This implementation is more aligned, in my opinion, with Go principles to share memory only by communicating. The Message variable is modified by a single goroutine to prevent potential concurrent slices modifications and false sharing.<br>One potential criticism even with the good code is to spawn a goroutine for each line. Such implementation will work because an ADEXP message will not contain thousands of lines. Yet, the simple implementation one request triggering one goroutine does not scale very much under very high throughput. A better option would have been to create a pool of reusable goroutines for example.<br><code>Edit</code>: This assumption (one line = one goroutine) was definitely not a good idea as it leads to way too much context switches. For additional information, please take a look at the link in the further reading chapter (at the end of the post).<br>Line processing notification<br>In the bad implementation, as described above, once a line processing is achieved by a mapLine() we should indicate it to the parent goroutine. This is done using a chan string channel and a call using:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch &lt;- &quot;ok&quot;</div></pre></td></tr></table></figure></p>\n<p>As the parent does not actually check the value sent by the channel, a better option would have been to use chan struct{} with a ch &lt;- struct{}{} or even better (GC wise) to use a chan interface{} with a ch &lt;- nil.<br>Another approach (even cleaner in my opinion) would have been to use a sync.WaitGroup as the parent goroutine just need to continue its execution once every mapLine() is done.</p>\n<h1 id=\"If\"><a href=\"#If\" class=\"headerlink\" title=\"If\"></a>If</h1><p>The Go if statement allows passing a statement before the condition.<br>An improved version of:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">f, contains := factory[string(token)]</div><div class=\"line\">if contains &#123;</div><div class=\"line\">    // Do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Can be the following implementation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if f, contains := factory[sToken]; contains &#123;</div><div class=\"line\">    // Do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>It slightly improves the code readability.</p>\n<h1 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h1><p>Another mistake with the bad implementation is to forget the default case in the following switch:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">switch simpleToken.token &#123;</div><div class=\"line\">case tokenTitle:</div><div class=\"line\">    msg.Title = value</div><div class=\"line\">case tokenAdep:</div><div class=\"line\">    msg.Adep = value</div><div class=\"line\">case tokenAltnz:</div><div class=\"line\">    msg.Alternate = value </div><div class=\"line\">// Other cases</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The default can be optional if the developer thought about all the different cases. Yet, it is definitely better to catch this specific case like in the following example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">switch simpleToken.token &#123;</div><div class=\"line\">case tokenTitle:</div><div class=\"line\">    msg.Title = value</div><div class=\"line\">case tokenAdep:</div><div class=\"line\">    msg.Adep = value</div><div class=\"line\">case tokenAltnz:</div><div class=\"line\">    msg.Alternate = value</div><div class=\"line\">// Other cases    </div><div class=\"line\">default:</div><div class=\"line\">    log.Errorf(&quot;unexpected token type %v&quot;, simpleToken.token)</div><div class=\"line\">    return Message&#123;&#125;, fmt.Errorf(&quot;unexpected token type %v&quot;, simpleToken.token)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Handling the default case would help in catching potential bugs made by developers as soon as possible in the development process.</p>\n<h1 id=\"Recursion\"><a href=\"#Recursion\" class=\"headerlink\" title=\"Recursion\"></a>Recursion</h1><p>The parseComplexLines() is a function to parse a complex token. The algorithm in the bad code is done using recursion:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func parseComplexLines(in string, currentMap map[string]string, </div><div class=\"line\">\tout []map[string]string) []map[string]string &#123;</div><div class=\"line\"></div><div class=\"line\">    match := regexpSubfield.Find([]byte(in))</div><div class=\"line\"></div><div class=\"line\">    if match == nil &#123;</div><div class=\"line\">        out = append(out, currentMap)</div><div class=\"line\">        return out</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sub := string(match)</div><div class=\"line\"></div><div class=\"line\">    h, l := parseLine(sub)</div><div class=\"line\"></div><div class=\"line\">    _, contains := currentMap[string(h)]</div><div class=\"line\"></div><div class=\"line\">    if contains &#123;</div><div class=\"line\">        out = append(out, currentMap)</div><div class=\"line\">        currentMap = make(map[string]string)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    currentMap[string(h)] = string(strings.Trim(l, stringEmpty))</div><div class=\"line\"></div><div class=\"line\">    return parseComplexLines(in[len(sub):], currentMap, out)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Yet, Go does not support tail-call elimination to optimize sub-function calls. The good code produces the exact same result but using an iterative algorithm:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func parseComplexToken(token string, value []byte) interface&#123;&#125; &#123;</div><div class=\"line\">    if value == nil &#123;</div><div class=\"line\">        log.Warnf(&quot;Empty value&quot;)</div><div class=\"line\">        return complexToken&#123;token, nil&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var v []map[string]string</div><div class=\"line\">    currentMap := make(map[string]string)</div><div class=\"line\"></div><div class=\"line\">    matches := regexpSubfield.FindAll(value, -1)</div><div class=\"line\"></div><div class=\"line\">    for _, sub := range matches &#123;</div><div class=\"line\">        h, l := parseLine(sub)</div><div class=\"line\"></div><div class=\"line\">        if _, contains := currentMap[string(h)]; contains &#123;</div><div class=\"line\">            v = append(v, currentMap)</div><div class=\"line\">            currentMap = make(map[string]string)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        currentMap[string(h)] = string(bytes.Trim(l, stringEmpty))</div><div class=\"line\">    &#125;</div><div class=\"line\">    v = append(v, currentMap)</div><div class=\"line\"></div><div class=\"line\">    return complexToken&#123;token, v&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The second code will be then more performant than the first one.</p>\n<h1 id=\"Constants-management\"><a href=\"#Constants-management\" class=\"headerlink\" title=\"Constants management\"></a>Constants management</h1><p>We must manage a constant value to dissociate ADEXP and ICAO messages. The bad code is doing it this way:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">const (</div><div class=\"line\">    AdexpType = 0 // TODO constant</div><div class=\"line\">    IcaoType  = 1</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>Whereas the good code is a more elegant solution based on Go (elegant) iota:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">const (</div><div class=\"line\">    AdexpType = iota</div><div class=\"line\">    IcaoType </div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>It produces exactly the same result but it reduces potential developer mistakes.</p>\n<h1 id=\"Receiver-functions\"><a href=\"#Receiver-functions\" class=\"headerlink\" title=\"Receiver functions\"></a>Receiver functions</h1><p>Each parser provides a function to determine whether a message concerns the upper level (at least one route point above the level 350).<br>The bad code implements it this way:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func IsUpperLevel(m Message) bool &#123;</div><div class=\"line\">    for _, r := range m.RoutePoints &#123;</div><div class=\"line\">        if r.FlightLevel &gt; upperLevel &#123;</div><div class=\"line\">            return true</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Meaning we have to pass a Message as an input of the function.<br>Whereas the good code is simply a function with a Message receiver:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (m *Message) IsUpperLevel() bool &#123;</div><div class=\"line\">    for _, r := range m.RoutePoints &#123;</div><div class=\"line\">        if r.FlightLevel &gt; upperLevel &#123;</div><div class=\"line\">            return true</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The second approach is preferable. We simply indicate the Message struct implements a specific behavior.<br>It might also be a first step to using Go interfaces. For example, if someday we need to create another structure with the same behavior (IsUpperLevel()), the initial code does not even need to be refactored (as Message already implements this behavior).</p>\n<h1 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h1><p>This one is pretty obvious but the bad comment is poorly commented.<br>On the other side, I tried to comment the good code as I would do in a real project. Even though I’m not the kind of developer who likes to comment every single line, I still believe it is important to comment at least each function and the main steps in a complex function.<br>As an example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Split each line in a goroutine</div><div class=\"line\">for _, line := range in &#123;</div><div class=\"line\">    go mapLine(line, ch)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">msg := Message&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">// Gather the goroutine results</div><div class=\"line\">for range in &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>One concrete example in addition of a function comment might also be very useful:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Parse a line by returning the header (token name) and the value. </div><div class=\"line\">// Example: -COMMENT TEST must returns COMMENT and TEST (in byte slices)</div><div class=\"line\">func parseLine(in []byte) ([]byte, []byte) &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Such concrete examples can really help another developer in better understanding an existing project.<br>Last but not least, according to Go best practices the package itself is also commented.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">Package good is a library for parsing the ADEXP messages.</div><div class=\"line\">An intermediate format Message is built by the parser.</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">package good</div></pre></td></tr></table></figure></p>\n<h1 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h1><p>Another obvious example is the lack of logs produced in the bad code. As I’m not a fan of the standard log package, I used an external library called logrus in this project.</p>\n<h1 id=\"go-fmt\"><a href=\"#go-fmt\" class=\"headerlink\" title=\"go fmt\"></a>go fmt</h1><p>Go provides a set of powerful tools like go fmt. Unfortunately, we forgot to apply it to the bad code whereas it was done on the good code.</p>\n<h1 id=\"DDD\"><a href=\"#DDD\" class=\"headerlink\" title=\"DDD\"></a>DDD</h1><p>DDD brings the concept of ubiquitous language to emphasize the importance of a shared language between all the project stakeholders (business experts, dev, testers etc.).<br> This cannot be really measured here in this example, but keeping a simple structure like Message compliant with the language spoken inside of a bounded context is also a good point for the overall project maintainability.</p>\n<h1 id=\"Performance-results\"><a href=\"#Performance-results\" class=\"headerlink\" title=\"Performance results\"></a>Performance results</h1><p>On an i7–7700 4x 3.60Ghz, I ran a benchmark test to compare both parsers:</p>\n<ul>\n<li>Bad implementation: 60430 ns/op</li>\n<li>Good implementation: 45996 ns/op<br>The bad code is more than 30% slower than the good one.</li>\n</ul>\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>It is pretty difficult in my opinion to give a general definition of what is a bad and a good code. A code in one context might be considered as good whereas in another context it might be considered as bad.<br>The first obvious characteristic of a good code is to provide a correct solution according to given functional requirements. A code can be performant if it does not fit the requirements, it is pretty useless.<br>Meanwhile, it is important for a developer to care about simple, maintainable and performant code.<br>The performance improvement does not materialize from the air, it comes with code complexity increase.<br>A good developer is someone able to find the right balance between these characteristics according to a given context.<br>Just like in DDD, context is key :)</p>\n<h1 id=\"Further-reading\"><a href=\"#Further-reading\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h1><p><a href=\"https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7\" target=\"_blank\" rel=\"external\">Go code refactoring: the 23x performance hunt</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>This article was transferred from @teivah</code> <a href=\"https://medium.com/@teivah/good-code-vs-bad-code-in-golang-84cb3c5da49d\" target=\"_blank\" rel=\"external\">Original</a><br><img src=\"./1-yh90bW8jL4f8pOTZTvbzqw.png\" alt=\"\"></p>\n<p>Recently, I was asked to detail what makes a good code or a bad code in Golang. I found this exercice very interesting. Actually, interesting enough to write a post about that. To illustrate my answer, I have taken a concrete use cases I faced in the Air Traffic Management (ATM) domain. The project is available in <a href=\"https://github.com/teivah/golang-good-code-bad-code\" target=\"_blank\" rel=\"external\">Github</a>.</p>\n<h1 id=\"Context\"><a href=\"#Context\" class=\"headerlink\" title=\"Context\"></a>Context</h1><p>First, few words to explain the context of the implementation.<br>Eurocontrol is the organization managing the air traffic across Europe countries. The common network for exchanging data between Eurocontrol and an Air Navigation Service Provider (ANSP) is called AFTN. This network is mainly used to exchange two different message types: ADEXP and ICAO messages. Each message type has its own syntax but in terms of semantic, both types are equivalent (more or less). Given the context, performance must be a key element for the implementation.<br>This project has to provide two implementations for parsing ADEXP messages (ICAO is not managed in the frame of this exercise) based on Go:</p>\n<ul>\n<li>A bad implementation (package name: <a href=\"https://github.com/teivah/golang-good-code-bad-code/tree/master/bad\" target=\"_blank\" rel=\"external\">bad</a>)</li>\n<li>A refactored implementation (package name: <a href=\"https://github.com/teivah/golang-good-code-bad-code/tree/master/good\" target=\"_blank\" rel=\"external\">good</a>).<br>An example of an ADEXP message can be found <a href=\"https://raw.githubusercontent.com/teivah/golang-good-code-bad-code/master/resources/tests/adexp.txt\" target=\"_blank\" rel=\"external\">here</a>.<br>In the frame of this exercise, the parsers handle only a subset of the fields we can find in an ADEXP message. Yet, It is still relevant to illustrate common Go mistakes.</li>\n</ul>\n<h1 id=\"Parsing\"><a href=\"#Parsing\" class=\"headerlink\" title=\"Parsing\"></a>Parsing</h1><p>In a nutshell, an ADEXP message is a set of tokens. A token type can be either:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">-ARCID ACA878</div></pre></td></tr></table></figure></p>\n<p>Meaning the ARCID (aircraft identifier) is ACA878.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-EETFIR EHAA 0853</div><div class=\"line\">-EETFIR EBBU 0908</div></pre></td></tr></table></figure></p>\n<p>This example is a list of FIR (Flight Information Region). The first FIR is EHAA 0853 whereas the second one is EBBU 0908.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-GEO -GEOID GEO01 -LATTD 490000N -LONGTD 0500000W</div><div class=\"line\">-GEO -GEOID GEO02 -LATTD 500000N -LONGTD 0400000W</div></pre></td></tr></table></figure></p>\n<p>A repeating list of tokens. Each line contains a sublist of tokens (in this example GEOID, LATTD, LONGTD).<br>Given the context, it is important to implement a version leveraging parallelization. So the algorithm is the following one:</p>\n<ul>\n<li>A preprocessing step to clean and rearrange the input message (we have to clean the potential white spaces, rearrange the tokens which are multi-lined like COMMENT etc.)</li>\n<li>Then splitting each line in a given goroutine. Each goroutine will be in charge to process one line and to return the result.</li>\n<li>Last but not least, gathering the results and returning a Message structure. This structure is a common one regardless of the message type (ADEXP or ICAO).<br>Each package contains an adexp.go file exposing the main function ParseAdexpMessage().</li>\n</ul>\n<h1 id=\"Step-by-step-comparison\"><a href=\"#Step-by-step-comparison\" class=\"headerlink\" title=\"Step-by-step comparison\"></a>Step-by-step comparison</h1><p>Let’s now see step by step what I consider as a bad code and how I refactored it.</p>\n<h1 id=\"String-vs-byte\"><a href=\"#String-vs-byte\" class=\"headerlink\" title=\"String vs []byte\"></a>String vs []byte</h1><p>The bad implementation handles only string inputs. As Go offers a strong support for bytes operations (basic operation like trim, regexp etc.) and that the input will most likely by a []byte (considering AFTN messages are received through TCP), there’s actually no good reason to force a string input.</p>\n<h1 id=\"Error-management\"><a href=\"#Error-management\" class=\"headerlink\" title=\"Error management\"></a>Error management</h1><p>The error management is kind of terrible the bad implementation.We can find some cases where potential errors returned in the second argument are not even managed:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">preprocessed, _ := preprocess(string)</div></pre></td></tr></table></figure></p>\n<p>The good implementation deals with each potential error:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">preprocessed, err := preprocess(bytes)</div><div class=\"line\">if err != nil &#123;</div><div class=\"line\">  return Message&#123;&#125;, err</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>We can also find some mistakes in the bad implementation like in the following code:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if len(in) == 0 &#123;</div><div class=\"line\">  return &quot;&quot;, fmt.Errorf(&quot;Input is empty&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The first mistake is a syntax one. An error string shall neither be capitalized nor end with a punctuation according to Go standards. The second mistake is due to the fact that if an error string is a simple constant (no formatting is required), a call to errors.New() is slightly more performant.<br>The good implementation looks like:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if len(in) == 0 &#123;</div><div class=\"line\">\treturn nil, errors.New(&quot;input is empty&quot;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"Avoid-nesting\"><a href=\"#Avoid-nesting\" class=\"headerlink\" title=\"Avoid nesting\"></a>Avoid nesting</h1><p>The mapLine() function is a good example of avoidable nesting calls. The bad implementation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">func mapLine(msg *Message, in string, ch chan string) &#123;</div><div class=\"line\">    if !startWith(in, stringComment) &#123;</div><div class=\"line\">        token, value := parseLine(in)</div><div class=\"line\">        if token != &quot;&quot; &#123;</div><div class=\"line\">            f, contains := factory[string(token)]</div><div class=\"line\">            if !contains &#123;</div><div class=\"line\">                ch &lt;- &quot;ok&quot;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                data := f(token, value)</div><div class=\"line\">                enrichMessage(msg, data)</div><div class=\"line\">                ch &lt;- &quot;ok&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ch &lt;- &quot;ok&quot;</div><div class=\"line\">            return</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        ch &lt;- &quot;ok&quot;</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>On the opposite, the good implementation is a flat representation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">func mapLine(in []byte, ch chan interface&#123;&#125;) &#123;</div><div class=\"line\">    // Filter empty lines and comment lines</div><div class=\"line\">    if len(in) == 0 || startWith(in, bytesComment) &#123;</div><div class=\"line\">        ch &lt;- nil</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    token, value := parseLine(in)</div><div class=\"line\">    if token == nil &#123;</div><div class=\"line\">        ch &lt;- nil</div><div class=\"line\">        log.Warnf(&quot;Token name is empty on line %v&quot;, string(in))</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sToken := string(token)</div><div class=\"line\">    if f, contains := factory[sToken]; contains &#123;</div><div class=\"line\">        ch &lt;- f(sToken, value)</div><div class=\"line\">        return</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    log.Warnf(&quot;Token %v is not managed by the parser&quot;, string(in))</div><div class=\"line\">    ch &lt;- nil</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>This makes the code easier to read in my opinion. Furthermore, this flat representation must also be applied to errors management. As an example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">a, err := f1()</div><div class=\"line\">if err == nil &#123;</div><div class=\"line\">    b, err := f2()</div><div class=\"line\">    if err == nil &#123;</div><div class=\"line\">        return b, nil</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        return nil, err</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">    return nil, err</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Should be replaced by:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">a, err := f1()</div><div class=\"line\">if err != nil &#123;</div><div class=\"line\">    return nil, err</div><div class=\"line\">&#125;</div><div class=\"line\">b, err := f2()</div><div class=\"line\">if err != nil &#123;</div><div class=\"line\">    return nil, err</div><div class=\"line\">&#125;</div><div class=\"line\">return b, nil</div></pre></td></tr></table></figure></p>\n<p>Once again, the second code version is easier to read.</p>\n<h1 id=\"Passing-data-by-reference-or-by-value\"><a href=\"#Passing-data-by-reference-or-by-value\" class=\"headerlink\" title=\"Passing data by reference or by value\"></a>Passing data by reference or by value</h1><p>The signature of the preprocessing function in the bad implementation is:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">func preprocess(in container) (container, error) &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Given the context of this project (performance does matter) and considering a message can potentially be quite heavy, a better option was to pass a pointer to the container structure instead. Otherwise, in the previous example the container value will be copied during each call.The good implementation does not face this problem as it deals with slices (a simple 24-byte structure regardless of the underlying data):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">func preprocess(in []byte) ([][]byte, error) &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>More generally speaking, passing data either by reference or by value must not be an idiomatic choice.<br>Passing data by value could also help to make sure a function will not cause any side effect (like mutating the data passed in the function input). This has several benefits like unit testing or refactoring a code for parallelization for example (otherwise we need to check each subfunction to see if a mutation is made).<br>I do believe such choice must really be done carefully depending on the project context.</p>\n<h1 id=\"Parallelization\"><a href=\"#Parallelization\" class=\"headerlink\" title=\"Parallelization\"></a>Parallelization</h1><p>The bad implementation is based on a good initial idea: leveraging goroutines to parallelize the data processing (one goroutine per line).<br>This is achieved in the bad implementation by iterating over the number of lines and spawning a mapLine() call in a goroutine.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i := 0; i &lt; len(lines); i++ &#123;</div><div class=\"line\">    go mapLine(&amp;msg, lines[i], ch)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The mapLine() function takes in arguments three parameters:</p>\n<ul>\n<li>A pointer to the final Message structure to be returned. It means each mapLine() will enrich the same variable.</li>\n<li>The current line</li>\n<li>A channel used for sending a notification once the processing of the line is done</li>\n</ul>\n<p>Sending a pointer to a shared Message variable breaks one of the main Go principles:<br>Don’t communicate by sharing memory, share memory by communicating.<br>There are two main drawbacks to passing this shared variable:</p>\n<ul>\n<li>Drawback #1: Slices concurrent modifications</li>\n</ul>\n<p>Because the structure contains some slices which can be modified concurrently (by two or more goroutine at the same time), in the bad implementation we had to deal with mutexes.<br>For example, the Message structure contains a Estdata []estdata.<br>Modifying the slice by appending another estdata must be done this way:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">mutexEstdata.Lock()</div><div class=\"line\">for _, v := range value &#123;</div><div class=\"line\">    fl := extractFlightLevel(v[subtokenFl])</div><div class=\"line\">    msg.Estdata = append(msg.Estdata, estdata&#123;v[subtokenPtid], v[subtokenEto], fl&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">mutexEstdata.Unlock()</div></pre></td></tr></table></figure></p>\n<p>Actually, except very specific use cases, having to use a mutex in a goroutine might be a code smell.</p>\n<ul>\n<li>Drawback #2: False sharing</li>\n</ul>\n<p>Sharing memory across threads/goroutines is not a good idea due to potential false sharing (a cache line in a given CPU core cache can be invalidated by another CPU core cache). This means we should avoid as much as possible sharing the same variable across threads/goroutines if they intend to mutate it.<br>In this very example, though, I don’t think false sharing has a huge impact as the input file is quite light (running a performance test with padding fields in the Message structure gives more or less the same result). Yet, that’s always something important to bear in mind in my opinion.<br>Let’s see now how is the good implementation dealing with the parallelization:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for _, line := range in &#123;</div><div class=\"line\">    go mapLine(line, ch)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Now, the mapLine() takes only two inputs:</p>\n<ul>\n<li>The current line</li>\n<li>A channel. This time this channel is not used to simply send a notification once a line processing is done but also to send the actual result. It means it is not up to the goroutines to modify the final Message structure.</li>\n</ul>\n<p>Gathering the results is done this way by the parent goroutine (the one spawning the mapLine() calls in separate goroutines):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">msg := Message&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">for range in &#123;</div><div class=\"line\">    data := &lt;-ch</div><div class=\"line\"></div><div class=\"line\">    switch data.(type) &#123;</div><div class=\"line\">        // Modify msg variable</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>This implementation is more aligned, in my opinion, with Go principles to share memory only by communicating. The Message variable is modified by a single goroutine to prevent potential concurrent slices modifications and false sharing.<br>One potential criticism even with the good code is to spawn a goroutine for each line. Such implementation will work because an ADEXP message will not contain thousands of lines. Yet, the simple implementation one request triggering one goroutine does not scale very much under very high throughput. A better option would have been to create a pool of reusable goroutines for example.<br><code>Edit</code>: This assumption (one line = one goroutine) was definitely not a good idea as it leads to way too much context switches. For additional information, please take a look at the link in the further reading chapter (at the end of the post).<br>Line processing notification<br>In the bad implementation, as described above, once a line processing is achieved by a mapLine() we should indicate it to the parent goroutine. This is done using a chan string channel and a call using:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch &lt;- &quot;ok&quot;</div></pre></td></tr></table></figure></p>\n<p>As the parent does not actually check the value sent by the channel, a better option would have been to use chan struct{} with a ch &lt;- struct{}{} or even better (GC wise) to use a chan interface{} with a ch &lt;- nil.<br>Another approach (even cleaner in my opinion) would have been to use a sync.WaitGroup as the parent goroutine just need to continue its execution once every mapLine() is done.</p>\n<h1 id=\"If\"><a href=\"#If\" class=\"headerlink\" title=\"If\"></a>If</h1><p>The Go if statement allows passing a statement before the condition.<br>An improved version of:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">f, contains := factory[string(token)]</div><div class=\"line\">if contains &#123;</div><div class=\"line\">    // Do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Can be the following implementation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if f, contains := factory[sToken]; contains &#123;</div><div class=\"line\">    // Do something</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>It slightly improves the code readability.</p>\n<h1 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h1><p>Another mistake with the bad implementation is to forget the default case in the following switch:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">switch simpleToken.token &#123;</div><div class=\"line\">case tokenTitle:</div><div class=\"line\">    msg.Title = value</div><div class=\"line\">case tokenAdep:</div><div class=\"line\">    msg.Adep = value</div><div class=\"line\">case tokenAltnz:</div><div class=\"line\">    msg.Alternate = value </div><div class=\"line\">// Other cases</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The default can be optional if the developer thought about all the different cases. Yet, it is definitely better to catch this specific case like in the following example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">switch simpleToken.token &#123;</div><div class=\"line\">case tokenTitle:</div><div class=\"line\">    msg.Title = value</div><div class=\"line\">case tokenAdep:</div><div class=\"line\">    msg.Adep = value</div><div class=\"line\">case tokenAltnz:</div><div class=\"line\">    msg.Alternate = value</div><div class=\"line\">// Other cases    </div><div class=\"line\">default:</div><div class=\"line\">    log.Errorf(&quot;unexpected token type %v&quot;, simpleToken.token)</div><div class=\"line\">    return Message&#123;&#125;, fmt.Errorf(&quot;unexpected token type %v&quot;, simpleToken.token)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Handling the default case would help in catching potential bugs made by developers as soon as possible in the development process.</p>\n<h1 id=\"Recursion\"><a href=\"#Recursion\" class=\"headerlink\" title=\"Recursion\"></a>Recursion</h1><p>The parseComplexLines() is a function to parse a complex token. The algorithm in the bad code is done using recursion:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func parseComplexLines(in string, currentMap map[string]string, </div><div class=\"line\">\tout []map[string]string) []map[string]string &#123;</div><div class=\"line\"></div><div class=\"line\">    match := regexpSubfield.Find([]byte(in))</div><div class=\"line\"></div><div class=\"line\">    if match == nil &#123;</div><div class=\"line\">        out = append(out, currentMap)</div><div class=\"line\">        return out</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    sub := string(match)</div><div class=\"line\"></div><div class=\"line\">    h, l := parseLine(sub)</div><div class=\"line\"></div><div class=\"line\">    _, contains := currentMap[string(h)]</div><div class=\"line\"></div><div class=\"line\">    if contains &#123;</div><div class=\"line\">        out = append(out, currentMap)</div><div class=\"line\">        currentMap = make(map[string]string)</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    currentMap[string(h)] = string(strings.Trim(l, stringEmpty))</div><div class=\"line\"></div><div class=\"line\">    return parseComplexLines(in[len(sub):], currentMap, out)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Yet, Go does not support tail-call elimination to optimize sub-function calls. The good code produces the exact same result but using an iterative algorithm:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">func parseComplexToken(token string, value []byte) interface&#123;&#125; &#123;</div><div class=\"line\">    if value == nil &#123;</div><div class=\"line\">        log.Warnf(&quot;Empty value&quot;)</div><div class=\"line\">        return complexToken&#123;token, nil&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    var v []map[string]string</div><div class=\"line\">    currentMap := make(map[string]string)</div><div class=\"line\"></div><div class=\"line\">    matches := regexpSubfield.FindAll(value, -1)</div><div class=\"line\"></div><div class=\"line\">    for _, sub := range matches &#123;</div><div class=\"line\">        h, l := parseLine(sub)</div><div class=\"line\"></div><div class=\"line\">        if _, contains := currentMap[string(h)]; contains &#123;</div><div class=\"line\">            v = append(v, currentMap)</div><div class=\"line\">            currentMap = make(map[string]string)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        currentMap[string(h)] = string(bytes.Trim(l, stringEmpty))</div><div class=\"line\">    &#125;</div><div class=\"line\">    v = append(v, currentMap)</div><div class=\"line\"></div><div class=\"line\">    return complexToken&#123;token, v&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The second code will be then more performant than the first one.</p>\n<h1 id=\"Constants-management\"><a href=\"#Constants-management\" class=\"headerlink\" title=\"Constants management\"></a>Constants management</h1><p>We must manage a constant value to dissociate ADEXP and ICAO messages. The bad code is doing it this way:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">const (</div><div class=\"line\">    AdexpType = 0 // TODO constant</div><div class=\"line\">    IcaoType  = 1</div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>Whereas the good code is a more elegant solution based on Go (elegant) iota:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">const (</div><div class=\"line\">    AdexpType = iota</div><div class=\"line\">    IcaoType </div><div class=\"line\">)</div></pre></td></tr></table></figure></p>\n<p>It produces exactly the same result but it reduces potential developer mistakes.</p>\n<h1 id=\"Receiver-functions\"><a href=\"#Receiver-functions\" class=\"headerlink\" title=\"Receiver functions\"></a>Receiver functions</h1><p>Each parser provides a function to determine whether a message concerns the upper level (at least one route point above the level 350).<br>The bad code implements it this way:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func IsUpperLevel(m Message) bool &#123;</div><div class=\"line\">    for _, r := range m.RoutePoints &#123;</div><div class=\"line\">        if r.FlightLevel &gt; upperLevel &#123;</div><div class=\"line\">            return true</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Meaning we have to pass a Message as an input of the function.<br>Whereas the good code is simply a function with a Message receiver:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">func (m *Message) IsUpperLevel() bool &#123;</div><div class=\"line\">    for _, r := range m.RoutePoints &#123;</div><div class=\"line\">        if r.FlightLevel &gt; upperLevel &#123;</div><div class=\"line\">            return true</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return false</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>The second approach is preferable. We simply indicate the Message struct implements a specific behavior.<br>It might also be a first step to using Go interfaces. For example, if someday we need to create another structure with the same behavior (IsUpperLevel()), the initial code does not even need to be refactored (as Message already implements this behavior).</p>\n<h1 id=\"Comments\"><a href=\"#Comments\" class=\"headerlink\" title=\"Comments\"></a>Comments</h1><p>This one is pretty obvious but the bad comment is poorly commented.<br>On the other side, I tried to comment the good code as I would do in a real project. Even though I’m not the kind of developer who likes to comment every single line, I still believe it is important to comment at least each function and the main steps in a complex function.<br>As an example:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Split each line in a goroutine</div><div class=\"line\">for _, line := range in &#123;</div><div class=\"line\">    go mapLine(line, ch)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">msg := Message&#123;&#125;</div><div class=\"line\"></div><div class=\"line\">// Gather the goroutine results</div><div class=\"line\">for range in &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>One concrete example in addition of a function comment might also be very useful:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Parse a line by returning the header (token name) and the value. </div><div class=\"line\">// Example: -COMMENT TEST must returns COMMENT and TEST (in byte slices)</div><div class=\"line\">func parseLine(in []byte) ([]byte, []byte) &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Such concrete examples can really help another developer in better understanding an existing project.<br>Last but not least, according to Go best practices the package itself is also commented.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">Package good is a library for parsing the ADEXP messages.</div><div class=\"line\">An intermediate format Message is built by the parser.</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\">package good</div></pre></td></tr></table></figure></p>\n<h1 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h1><p>Another obvious example is the lack of logs produced in the bad code. As I’m not a fan of the standard log package, I used an external library called logrus in this project.</p>\n<h1 id=\"go-fmt\"><a href=\"#go-fmt\" class=\"headerlink\" title=\"go fmt\"></a>go fmt</h1><p>Go provides a set of powerful tools like go fmt. Unfortunately, we forgot to apply it to the bad code whereas it was done on the good code.</p>\n<h1 id=\"DDD\"><a href=\"#DDD\" class=\"headerlink\" title=\"DDD\"></a>DDD</h1><p>DDD brings the concept of ubiquitous language to emphasize the importance of a shared language between all the project stakeholders (business experts, dev, testers etc.).<br> This cannot be really measured here in this example, but keeping a simple structure like Message compliant with the language spoken inside of a bounded context is also a good point for the overall project maintainability.</p>\n<h1 id=\"Performance-results\"><a href=\"#Performance-results\" class=\"headerlink\" title=\"Performance results\"></a>Performance results</h1><p>On an i7–7700 4x 3.60Ghz, I ran a benchmark test to compare both parsers:</p>\n<ul>\n<li>Bad implementation: 60430 ns/op</li>\n<li>Good implementation: 45996 ns/op<br>The bad code is more than 30% slower than the good one.</li>\n</ul>\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>It is pretty difficult in my opinion to give a general definition of what is a bad and a good code. A code in one context might be considered as good whereas in another context it might be considered as bad.<br>The first obvious characteristic of a good code is to provide a correct solution according to given functional requirements. A code can be performant if it does not fit the requirements, it is pretty useless.<br>Meanwhile, it is important for a developer to care about simple, maintainable and performant code.<br>The performance improvement does not materialize from the air, it comes with code complexity increase.<br>A good developer is someone able to find the right balance between these characteristics according to a given context.<br>Just like in DDD, context is key :)</p>\n<h1 id=\"Further-reading\"><a href=\"#Further-reading\" class=\"headerlink\" title=\"Further reading\"></a>Further reading</h1><p><a href=\"https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7\" target=\"_blank\" rel=\"external\">Go code refactoring: the 23x performance hunt</a></p>\n"},{"title":"Hadoop基础知识整理","date":"2017-08-11T09:28:43.000Z","_content":"\n# Hadoop是什么\nHadoop是根据Google发表的两篇论文（论述Google文件系统（GFS）和MapReduce框架）开发出的开源框架。\nHadoop是一种开源的适合大数据的分布式存储和处理的平台。作为一种大规模分布式数据处理平台。\n\n# Hadoop能做什么\n1. 搜索引擎：这也正是Doug Cutting设计Hadoop的初衷，为了针对大规模的网页快速建立索引；\n2. 大数据存储：利用Hadoop的分布式存储能力，例如数据备份、数据仓库等；\n3. 大数据处理：利用Hadoop的分布式处理能力，例如数据挖掘、数据分析等；\n4. 科学研究：Hadoop是一种分布式的开源框架，对于分布式系统有很大程度地参考价值。\n\n# Hadoop三种模式\nHadoop有三种不同的模式操作，分别为单机模式、伪分布模式和全分布模式。Hadoop官网都详细介绍了三种模式的配置方式。\n\n# Hadoop分布式文件系统HDFS\nHadoop分布式文件系统（Hadoop Distributed File System，简称HDFS）是Hadoop的核心模块之一，它主要解决Hadoop的大数据存储问题，其思想来源与Google的文件系统GFS。HDFS的主要特点：\n1. 保存多个副本，且提供容错机制，副本丢失或宕机自动恢复。默认存3份。\n2. 运行在廉价的机器上,可以用大规模的PC机搭建出高可用、高性能的服务集群\n3. 适合大数据的处理。HDFS默认会将文件分割成block，128M为1个block。然后将block按键值对存储在HDFS上，并将键值对的映射存到内存中。Hadoop更适合处理大文件，如果小文件太多，那内存的负担会很重。\n\n## HDFS中的四个重要对象：\n\n### [Namenode]\n1. 管理文件系统的命名空间。\n2. 记录每个文件数据块在各个Datanode上的位置和副本信息。\n3. 协调客户端对文件的访问。\n4. 记录命名空间内的改动或者空间本省属性的改动。\n5. 校验块的完整性，副本数量\n6. Namenode 使用事务日志记录HDFS元数据的变化。使用映像文件存储文件系统的命名空间，包括文件映射，文件属性等。\nNamenode是HDFS里面的管理者，发挥者管理、协调、操控的作用。\n\n### [Datanode]\n1. Datnode会发送心跳和块报告给namenode，如果namenode长时间没收到心跳，会判断此节点丢失，并不会再给这个分配任务\n2. 负责所在物理节点的存储管理。\n3. 一次写入，多次读取（不能修改）。\n4. 文件由数据库组成，一般情况下，数据块的大小为128MB。\n5. 数据尽量散步到各个节点\nDatanode是HDFS的工作者，发挥按着Namenode的命令干活，并且把干活的进展和问题反馈到Namenode的作用。\n\n#### 客户端如何访问HDFS中一个文件呢\n1. 首先从Namenode获得组成这个文件的数据块位置列表。\n2. 接下来根据位置列表知道存储数据块的Datanode。\n3. 最后访问Datanode获取数据。\nNamenode并不参与数据实际传输。\n\n### [SecondaryNameNode]\n1. 定期合并namenode的编辑日志到fsimage\n2. 一旦它有了新的fsimage文件，它将其拷贝回NameNode中。\n3. NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间\nSecondaryNameNode辅助NameNode工作，好比是namenode的秘书，不参与实际的管理工作\n\n#### HDFS是如何保证其可靠性呢 \n数据存储系统，数据存储的可靠性至关重要。\n1. 冗余副本策略，即所有数据都有副本，副本的数目可以在hdfs-site.xml中设置相应的复制因子。\n2. 机架策略，即HDFS的“机架感知”，一般在本机架存放一个副本，在其它机架再存放别的副本，这样可以防止机架失效时丢失数据，也可以提供带宽利用率。\n3. 心跳机制，即Namenode周期性从Datanode接受心跳信号和快报告，没有按时发送心跳的Datanode会被标记为宕机，不会再给任何I/O请求，若是Datanode失效造成副本数量下降，并且低于预先设置的阈值，Namenode会检测出这些数据块，并在合适的时机进行重新复制。\n4. 安全模式，Namenode启动时会先经过一个“安全模式”阶段。\n5. 校验和，客户端获取数据通过检查校验和，发现数据块是否损坏，从而确定是否要读取副本。\n6. 回收站，删除文件，会先到回收站/trash，其里面文件可以快速回复。\n7. 元数据保护，映像文件和事务日志是Namenode的核心数据，可以配置为拥有多个副本。\n8. 快照，支持存储某个时间点的映像，需要时可以使数据重返这个时间点的状态。\n\nHDFS也是按照Master和Slave的结构。分NameNode、SecondaryNameNode、DataNode这几个角色。\nNameNode：是Master节点，是大领导。管理数据块映射；处理客户端的读写请求；配置副本策略；管理HDFS的名称空间；\nSecondaryNameNode：是一个小弟，分担大哥namenode的工作量；是NameNode的冷备份；合并fsimage和fsedits然后再发给namenode。\nDataNode：Slave节点，负责存储client发来的数据块block；执行数据块的读写操作。\nfsimage:元数据镜像文件（文件系统的目录树。）\nedits：元数据的操作日志（针对文件系统做的修改操作记录）\nnamenode内存中存储的是=fsimage+edits。\nSecondaryNameNode负责定时默认1小时，从namenode上，获取fsimage和edits来进行合并，然后再发送给namenode。减少namenode的工作量。\n\n# HDFS文件系统的优点\n1. 处理超大文件，超大文件通常是指百MB、设置数百TB大小的文件。目前在实际应用中，HDFS已经能用来存储管理PB级的数据了。\n2. 流式的访问数据，HDFS的设计建立在更多地响应\"一次写入、多次读写\"任务的基础上。这意味着一个数据集一旦由数据源生成，就会被复制分发到不同的存储节点中，然后响应各种各样的数据分析任务请求。在多数情况下，分析任务都会涉及数据集中的大部分数据，也就是说，对HDFS来说，请求读取整个数据集要比读取一条记录更加高效。\n3. 运行于廉价的商用机器集群上，Hadoop设计对硬件需求比较低，只须运行在低廉的商用硬件集群上，而无需昂贵的高可用性机器上。廉价的商用机也就意味着大型集群中出现节点故障情况的概率非常高。这就要求设计HDFS时要充分考虑数据的可靠性，安全性及高可用性。\n\n# HDFS的缺点\n1. 不适合低延迟数据访问，如果要处理一些用户要求时间比较短的低延迟应用请求，则HDFS不适合。HDFS是为了处理大型数据集分析任务的，主要是为达到高的数据吞吐量而设计的，这就可能要求以高延迟作为代价。\n　　对于那些有低延时要求的应用程序，HBase是一个更好的选择。通过上层数据管理项目来尽可能地弥补这个不足。在性能上有了很大的提升，它的口号就是goes real time。使用缓存或多master设计可以降低client的数据请求压力，以减少延时。还有就是对HDFS系统内部的修改，这就得权衡大吞吐量与低延时了，HDFS不是万能的银弹。\n2. 无法高效存储大量小文件，因为Namenode把文件系统的元数据放置在内存中，所以文件系统所能容纳的文件数目是由Namenode的内存大小来决定。一般来说，每一个文件、文件夹和Block需要占据150字节左右的空间，所以，如果你有100万个文件，每一个占据一个Block，你就至少需要300MB内存。当前来说，数百万的文件还是可行的，当扩展到数十亿时，对于当前的硬件水平来说就没法实现了。还有一个问题就是，因为Map task的数量是由splits来决定的，所以用MR处理大量的小文件时，就会产生过多的Maptask，线程管理开销将会增加作业时间。举个例子，处理10000M的文件，若每个split为1M，那就会有10000个Maptasks，会有很大的线程开销；若每个split为100M，则只有100个Maptasks，每个Maptask将会有更多的事情做，而线程的管理开销也将减小很多。\n3. 不支持多用户写入及任意修改文件，在HDFS的一个文件中只有一个写入者，而且写操作只能在文件末尾完成，即只能执行追加操作。目前HDFS还不支持多个用户对同一文件的写操作，以及在文件任意位置进行修改。\n> 改进策略：要想让HDFS能处理好小文件：\n> 1. 利用SequenceFile、MapFile、Har等方式归档小文件，这个方法的原理就是把小文件归档起来管理，HBase就是基于此的。对于这种方法，如果想找回原来的小文件内容，那就必须得知道与归档文件的映射关系。\n> 2. 横向扩展，一个Hadoop集群能管理的小文件有限，那就把几个Hadoop集群拖在一个虚拟服务器后面，形成一个大的Hadoop集群。google也是这么干过的。\n> 3. 多Master设计，这个作用显而易见了。正在研发中的GFS II也要改为分布式多Master设计，还支持Master的Failover，而且Block大小改为1M，有意要调优处理小文件啊。\nAlibaba DFS的设计，也是多Master设计，它把Metadata的映射存储和管理分开了，由多个Metadata存储节点和一个查询Master节点组成。\n\n\n# Hadoop是资源管理系统YARN\n## ResourceManager\n整个集群只有一个，负责集群资源的统一管理和调度\n1. 处理客户端请求\n2. 启动/监控ApplicationMaster\n3. 监控NodeManager\n4. 资源分配与调度\n\n## NodeManager\n整个集群有多个，负责单节点资源管理和使用\n1. 单个节点上的资源管理和任务管理\n2. 处理来自ResourceManager的命令\n3. 处理来自ApplicationMaster的命令\n\n## ApplicationMaster\n每个应用有一个，负责应用程序的管理\n1. 数据切分\n2. 为应用程序申请资源，并进一步分配给内部任务\n3. 任务监控与容错\n\n## Container\n对任务运行环境的抽象，描述一系列信息\n1. 任务运行资源（节点、内存、CPU）\n2. 任务启动命令\n3. 任务运行环境\n\n# Hadoop数据分析框架\nMapReduce是Hadoop的大数据分布式处理系统，Hadoop核心之MapReduce是一个软件框架，基于该框架能够容易地编写应用程序，这些应用程序能够运行在由上千个商用机器组成的大集群上，并以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集。\nMapReduce主要是用于解决Hadoop大数据处理的。所谓大数据处理，即以对大数据加工、挖掘和优化等各种处理。\nMapReduce擅长处理大数据，其主要思想是“分而治之”。Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：一是数据或计算的规模相对原任务要大大缩小；二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算；三是这些小任务可以并行计算，彼此间几乎没有依赖关系。Reducer负责对map阶段的结果进行汇总。可以设置多个Reducer（通过在mapred-site.xml配置文件里设置参数mapred.reduce.tasks的值，缺省值为1）。\nMapReduce的工作机制如图所示：\n\nMapReduce的整个工作过程如上图所示，它包含如下4个独立的实体：\n　　1. 客户端，用来提交MapReduce作业。\n　　2. jobtracker，用来协调作业的运行。\n　　3. tasktracker，用来处理作业划分后的任务。\n　　4. HDFS，用来在其它实体间共享作业文件。\nMapReduce整个工作过程有序地包含如下工作环节：\n　　1. 作业的提交\n　　2. 作业的初始化\n　　3. 任务的分配\n　　4. 任务的执行\n　　5. 进程和状态的更新\n　　6. 作业的完成 \n","source":"_posts/Hadoop基础知识整理.md","raw":"---\ntitle: Hadoop基础知识整理\ndate: 2017-08-11 17:28:43\ncategories:\n  BigData\ntags: \n  - Hadoop\n  - Server\n  - Technology\n---\n\n# Hadoop是什么\nHadoop是根据Google发表的两篇论文（论述Google文件系统（GFS）和MapReduce框架）开发出的开源框架。\nHadoop是一种开源的适合大数据的分布式存储和处理的平台。作为一种大规模分布式数据处理平台。\n\n# Hadoop能做什么\n1. 搜索引擎：这也正是Doug Cutting设计Hadoop的初衷，为了针对大规模的网页快速建立索引；\n2. 大数据存储：利用Hadoop的分布式存储能力，例如数据备份、数据仓库等；\n3. 大数据处理：利用Hadoop的分布式处理能力，例如数据挖掘、数据分析等；\n4. 科学研究：Hadoop是一种分布式的开源框架，对于分布式系统有很大程度地参考价值。\n\n# Hadoop三种模式\nHadoop有三种不同的模式操作，分别为单机模式、伪分布模式和全分布模式。Hadoop官网都详细介绍了三种模式的配置方式。\n\n# Hadoop分布式文件系统HDFS\nHadoop分布式文件系统（Hadoop Distributed File System，简称HDFS）是Hadoop的核心模块之一，它主要解决Hadoop的大数据存储问题，其思想来源与Google的文件系统GFS。HDFS的主要特点：\n1. 保存多个副本，且提供容错机制，副本丢失或宕机自动恢复。默认存3份。\n2. 运行在廉价的机器上,可以用大规模的PC机搭建出高可用、高性能的服务集群\n3. 适合大数据的处理。HDFS默认会将文件分割成block，128M为1个block。然后将block按键值对存储在HDFS上，并将键值对的映射存到内存中。Hadoop更适合处理大文件，如果小文件太多，那内存的负担会很重。\n\n## HDFS中的四个重要对象：\n\n### [Namenode]\n1. 管理文件系统的命名空间。\n2. 记录每个文件数据块在各个Datanode上的位置和副本信息。\n3. 协调客户端对文件的访问。\n4. 记录命名空间内的改动或者空间本省属性的改动。\n5. 校验块的完整性，副本数量\n6. Namenode 使用事务日志记录HDFS元数据的变化。使用映像文件存储文件系统的命名空间，包括文件映射，文件属性等。\nNamenode是HDFS里面的管理者，发挥者管理、协调、操控的作用。\n\n### [Datanode]\n1. Datnode会发送心跳和块报告给namenode，如果namenode长时间没收到心跳，会判断此节点丢失，并不会再给这个分配任务\n2. 负责所在物理节点的存储管理。\n3. 一次写入，多次读取（不能修改）。\n4. 文件由数据库组成，一般情况下，数据块的大小为128MB。\n5. 数据尽量散步到各个节点\nDatanode是HDFS的工作者，发挥按着Namenode的命令干活，并且把干活的进展和问题反馈到Namenode的作用。\n\n#### 客户端如何访问HDFS中一个文件呢\n1. 首先从Namenode获得组成这个文件的数据块位置列表。\n2. 接下来根据位置列表知道存储数据块的Datanode。\n3. 最后访问Datanode获取数据。\nNamenode并不参与数据实际传输。\n\n### [SecondaryNameNode]\n1. 定期合并namenode的编辑日志到fsimage\n2. 一旦它有了新的fsimage文件，它将其拷贝回NameNode中。\n3. NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间\nSecondaryNameNode辅助NameNode工作，好比是namenode的秘书，不参与实际的管理工作\n\n#### HDFS是如何保证其可靠性呢 \n数据存储系统，数据存储的可靠性至关重要。\n1. 冗余副本策略，即所有数据都有副本，副本的数目可以在hdfs-site.xml中设置相应的复制因子。\n2. 机架策略，即HDFS的“机架感知”，一般在本机架存放一个副本，在其它机架再存放别的副本，这样可以防止机架失效时丢失数据，也可以提供带宽利用率。\n3. 心跳机制，即Namenode周期性从Datanode接受心跳信号和快报告，没有按时发送心跳的Datanode会被标记为宕机，不会再给任何I/O请求，若是Datanode失效造成副本数量下降，并且低于预先设置的阈值，Namenode会检测出这些数据块，并在合适的时机进行重新复制。\n4. 安全模式，Namenode启动时会先经过一个“安全模式”阶段。\n5. 校验和，客户端获取数据通过检查校验和，发现数据块是否损坏，从而确定是否要读取副本。\n6. 回收站，删除文件，会先到回收站/trash，其里面文件可以快速回复。\n7. 元数据保护，映像文件和事务日志是Namenode的核心数据，可以配置为拥有多个副本。\n8. 快照，支持存储某个时间点的映像，需要时可以使数据重返这个时间点的状态。\n\nHDFS也是按照Master和Slave的结构。分NameNode、SecondaryNameNode、DataNode这几个角色。\nNameNode：是Master节点，是大领导。管理数据块映射；处理客户端的读写请求；配置副本策略；管理HDFS的名称空间；\nSecondaryNameNode：是一个小弟，分担大哥namenode的工作量；是NameNode的冷备份；合并fsimage和fsedits然后再发给namenode。\nDataNode：Slave节点，负责存储client发来的数据块block；执行数据块的读写操作。\nfsimage:元数据镜像文件（文件系统的目录树。）\nedits：元数据的操作日志（针对文件系统做的修改操作记录）\nnamenode内存中存储的是=fsimage+edits。\nSecondaryNameNode负责定时默认1小时，从namenode上，获取fsimage和edits来进行合并，然后再发送给namenode。减少namenode的工作量。\n\n# HDFS文件系统的优点\n1. 处理超大文件，超大文件通常是指百MB、设置数百TB大小的文件。目前在实际应用中，HDFS已经能用来存储管理PB级的数据了。\n2. 流式的访问数据，HDFS的设计建立在更多地响应\"一次写入、多次读写\"任务的基础上。这意味着一个数据集一旦由数据源生成，就会被复制分发到不同的存储节点中，然后响应各种各样的数据分析任务请求。在多数情况下，分析任务都会涉及数据集中的大部分数据，也就是说，对HDFS来说，请求读取整个数据集要比读取一条记录更加高效。\n3. 运行于廉价的商用机器集群上，Hadoop设计对硬件需求比较低，只须运行在低廉的商用硬件集群上，而无需昂贵的高可用性机器上。廉价的商用机也就意味着大型集群中出现节点故障情况的概率非常高。这就要求设计HDFS时要充分考虑数据的可靠性，安全性及高可用性。\n\n# HDFS的缺点\n1. 不适合低延迟数据访问，如果要处理一些用户要求时间比较短的低延迟应用请求，则HDFS不适合。HDFS是为了处理大型数据集分析任务的，主要是为达到高的数据吞吐量而设计的，这就可能要求以高延迟作为代价。\n　　对于那些有低延时要求的应用程序，HBase是一个更好的选择。通过上层数据管理项目来尽可能地弥补这个不足。在性能上有了很大的提升，它的口号就是goes real time。使用缓存或多master设计可以降低client的数据请求压力，以减少延时。还有就是对HDFS系统内部的修改，这就得权衡大吞吐量与低延时了，HDFS不是万能的银弹。\n2. 无法高效存储大量小文件，因为Namenode把文件系统的元数据放置在内存中，所以文件系统所能容纳的文件数目是由Namenode的内存大小来决定。一般来说，每一个文件、文件夹和Block需要占据150字节左右的空间，所以，如果你有100万个文件，每一个占据一个Block，你就至少需要300MB内存。当前来说，数百万的文件还是可行的，当扩展到数十亿时，对于当前的硬件水平来说就没法实现了。还有一个问题就是，因为Map task的数量是由splits来决定的，所以用MR处理大量的小文件时，就会产生过多的Maptask，线程管理开销将会增加作业时间。举个例子，处理10000M的文件，若每个split为1M，那就会有10000个Maptasks，会有很大的线程开销；若每个split为100M，则只有100个Maptasks，每个Maptask将会有更多的事情做，而线程的管理开销也将减小很多。\n3. 不支持多用户写入及任意修改文件，在HDFS的一个文件中只有一个写入者，而且写操作只能在文件末尾完成，即只能执行追加操作。目前HDFS还不支持多个用户对同一文件的写操作，以及在文件任意位置进行修改。\n> 改进策略：要想让HDFS能处理好小文件：\n> 1. 利用SequenceFile、MapFile、Har等方式归档小文件，这个方法的原理就是把小文件归档起来管理，HBase就是基于此的。对于这种方法，如果想找回原来的小文件内容，那就必须得知道与归档文件的映射关系。\n> 2. 横向扩展，一个Hadoop集群能管理的小文件有限，那就把几个Hadoop集群拖在一个虚拟服务器后面，形成一个大的Hadoop集群。google也是这么干过的。\n> 3. 多Master设计，这个作用显而易见了。正在研发中的GFS II也要改为分布式多Master设计，还支持Master的Failover，而且Block大小改为1M，有意要调优处理小文件啊。\nAlibaba DFS的设计，也是多Master设计，它把Metadata的映射存储和管理分开了，由多个Metadata存储节点和一个查询Master节点组成。\n\n\n# Hadoop是资源管理系统YARN\n## ResourceManager\n整个集群只有一个，负责集群资源的统一管理和调度\n1. 处理客户端请求\n2. 启动/监控ApplicationMaster\n3. 监控NodeManager\n4. 资源分配与调度\n\n## NodeManager\n整个集群有多个，负责单节点资源管理和使用\n1. 单个节点上的资源管理和任务管理\n2. 处理来自ResourceManager的命令\n3. 处理来自ApplicationMaster的命令\n\n## ApplicationMaster\n每个应用有一个，负责应用程序的管理\n1. 数据切分\n2. 为应用程序申请资源，并进一步分配给内部任务\n3. 任务监控与容错\n\n## Container\n对任务运行环境的抽象，描述一系列信息\n1. 任务运行资源（节点、内存、CPU）\n2. 任务启动命令\n3. 任务运行环境\n\n# Hadoop数据分析框架\nMapReduce是Hadoop的大数据分布式处理系统，Hadoop核心之MapReduce是一个软件框架，基于该框架能够容易地编写应用程序，这些应用程序能够运行在由上千个商用机器组成的大集群上，并以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集。\nMapReduce主要是用于解决Hadoop大数据处理的。所谓大数据处理，即以对大数据加工、挖掘和优化等各种处理。\nMapReduce擅长处理大数据，其主要思想是“分而治之”。Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：一是数据或计算的规模相对原任务要大大缩小；二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算；三是这些小任务可以并行计算，彼此间几乎没有依赖关系。Reducer负责对map阶段的结果进行汇总。可以设置多个Reducer（通过在mapred-site.xml配置文件里设置参数mapred.reduce.tasks的值，缺省值为1）。\nMapReduce的工作机制如图所示：\n\nMapReduce的整个工作过程如上图所示，它包含如下4个独立的实体：\n　　1. 客户端，用来提交MapReduce作业。\n　　2. jobtracker，用来协调作业的运行。\n　　3. tasktracker，用来处理作业划分后的任务。\n　　4. HDFS，用来在其它实体间共享作业文件。\nMapReduce整个工作过程有序地包含如下工作环节：\n　　1. 作业的提交\n　　2. 作业的初始化\n　　3. 任务的分配\n　　4. 任务的执行\n　　5. 进程和状态的更新\n　　6. 作业的完成 \n","slug":"Hadoop基础知识整理","published":1,"updated":"2017-09-08T10:16:30.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja38s000844ein0s4vhz0","content":"<h1 id=\"Hadoop是什么\"><a href=\"#Hadoop是什么\" class=\"headerlink\" title=\"Hadoop是什么\"></a>Hadoop是什么</h1><p>Hadoop是根据Google发表的两篇论文（论述Google文件系统（GFS）和MapReduce框架）开发出的开源框架。<br>Hadoop是一种开源的适合大数据的分布式存储和处理的平台。作为一种大规模分布式数据处理平台。</p>\n<h1 id=\"Hadoop能做什么\"><a href=\"#Hadoop能做什么\" class=\"headerlink\" title=\"Hadoop能做什么\"></a>Hadoop能做什么</h1><ol>\n<li>搜索引擎：这也正是Doug Cutting设计Hadoop的初衷，为了针对大规模的网页快速建立索引；</li>\n<li>大数据存储：利用Hadoop的分布式存储能力，例如数据备份、数据仓库等；</li>\n<li>大数据处理：利用Hadoop的分布式处理能力，例如数据挖掘、数据分析等；</li>\n<li>科学研究：Hadoop是一种分布式的开源框架，对于分布式系统有很大程度地参考价值。</li>\n</ol>\n<h1 id=\"Hadoop三种模式\"><a href=\"#Hadoop三种模式\" class=\"headerlink\" title=\"Hadoop三种模式\"></a>Hadoop三种模式</h1><p>Hadoop有三种不同的模式操作，分别为单机模式、伪分布模式和全分布模式。Hadoop官网都详细介绍了三种模式的配置方式。</p>\n<h1 id=\"Hadoop分布式文件系统HDFS\"><a href=\"#Hadoop分布式文件系统HDFS\" class=\"headerlink\" title=\"Hadoop分布式文件系统HDFS\"></a>Hadoop分布式文件系统HDFS</h1><p>Hadoop分布式文件系统（Hadoop Distributed File System，简称HDFS）是Hadoop的核心模块之一，它主要解决Hadoop的大数据存储问题，其思想来源与Google的文件系统GFS。HDFS的主要特点：</p>\n<ol>\n<li>保存多个副本，且提供容错机制，副本丢失或宕机自动恢复。默认存3份。</li>\n<li>运行在廉价的机器上,可以用大规模的PC机搭建出高可用、高性能的服务集群</li>\n<li>适合大数据的处理。HDFS默认会将文件分割成block，128M为1个block。然后将block按键值对存储在HDFS上，并将键值对的映射存到内存中。Hadoop更适合处理大文件，如果小文件太多，那内存的负担会很重。</li>\n</ol>\n<h2 id=\"HDFS中的四个重要对象：\"><a href=\"#HDFS中的四个重要对象：\" class=\"headerlink\" title=\"HDFS中的四个重要对象：\"></a>HDFS中的四个重要对象：</h2><h3 id=\"Namenode\"><a href=\"#Namenode\" class=\"headerlink\" title=\"[Namenode]\"></a>[Namenode]</h3><ol>\n<li>管理文件系统的命名空间。</li>\n<li>记录每个文件数据块在各个Datanode上的位置和副本信息。</li>\n<li>协调客户端对文件的访问。</li>\n<li>记录命名空间内的改动或者空间本省属性的改动。</li>\n<li>校验块的完整性，副本数量</li>\n<li>Namenode 使用事务日志记录HDFS元数据的变化。使用映像文件存储文件系统的命名空间，包括文件映射，文件属性等。<br>Namenode是HDFS里面的管理者，发挥者管理、协调、操控的作用。</li>\n</ol>\n<h3 id=\"Datanode\"><a href=\"#Datanode\" class=\"headerlink\" title=\"[Datanode]\"></a>[Datanode]</h3><ol>\n<li>Datnode会发送心跳和块报告给namenode，如果namenode长时间没收到心跳，会判断此节点丢失，并不会再给这个分配任务</li>\n<li>负责所在物理节点的存储管理。</li>\n<li>一次写入，多次读取（不能修改）。</li>\n<li>文件由数据库组成，一般情况下，数据块的大小为128MB。</li>\n<li>数据尽量散步到各个节点<br>Datanode是HDFS的工作者，发挥按着Namenode的命令干活，并且把干活的进展和问题反馈到Namenode的作用。</li>\n</ol>\n<h4 id=\"客户端如何访问HDFS中一个文件呢\"><a href=\"#客户端如何访问HDFS中一个文件呢\" class=\"headerlink\" title=\"客户端如何访问HDFS中一个文件呢\"></a>客户端如何访问HDFS中一个文件呢</h4><ol>\n<li>首先从Namenode获得组成这个文件的数据块位置列表。</li>\n<li>接下来根据位置列表知道存储数据块的Datanode。</li>\n<li>最后访问Datanode获取数据。<br>Namenode并不参与数据实际传输。</li>\n</ol>\n<h3 id=\"SecondaryNameNode\"><a href=\"#SecondaryNameNode\" class=\"headerlink\" title=\"[SecondaryNameNode]\"></a>[SecondaryNameNode]</h3><ol>\n<li>定期合并namenode的编辑日志到fsimage</li>\n<li>一旦它有了新的fsimage文件，它将其拷贝回NameNode中。</li>\n<li>NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间<br>SecondaryNameNode辅助NameNode工作，好比是namenode的秘书，不参与实际的管理工作</li>\n</ol>\n<h4 id=\"HDFS是如何保证其可靠性呢\"><a href=\"#HDFS是如何保证其可靠性呢\" class=\"headerlink\" title=\"HDFS是如何保证其可靠性呢\"></a>HDFS是如何保证其可靠性呢</h4><p>数据存储系统，数据存储的可靠性至关重要。</p>\n<ol>\n<li>冗余副本策略，即所有数据都有副本，副本的数目可以在hdfs-site.xml中设置相应的复制因子。</li>\n<li>机架策略，即HDFS的“机架感知”，一般在本机架存放一个副本，在其它机架再存放别的副本，这样可以防止机架失效时丢失数据，也可以提供带宽利用率。</li>\n<li>心跳机制，即Namenode周期性从Datanode接受心跳信号和快报告，没有按时发送心跳的Datanode会被标记为宕机，不会再给任何I/O请求，若是Datanode失效造成副本数量下降，并且低于预先设置的阈值，Namenode会检测出这些数据块，并在合适的时机进行重新复制。</li>\n<li>安全模式，Namenode启动时会先经过一个“安全模式”阶段。</li>\n<li>校验和，客户端获取数据通过检查校验和，发现数据块是否损坏，从而确定是否要读取副本。</li>\n<li>回收站，删除文件，会先到回收站/trash，其里面文件可以快速回复。</li>\n<li>元数据保护，映像文件和事务日志是Namenode的核心数据，可以配置为拥有多个副本。</li>\n<li>快照，支持存储某个时间点的映像，需要时可以使数据重返这个时间点的状态。</li>\n</ol>\n<p>HDFS也是按照Master和Slave的结构。分NameNode、SecondaryNameNode、DataNode这几个角色。<br>NameNode：是Master节点，是大领导。管理数据块映射；处理客户端的读写请求；配置副本策略；管理HDFS的名称空间；<br>SecondaryNameNode：是一个小弟，分担大哥namenode的工作量；是NameNode的冷备份；合并fsimage和fsedits然后再发给namenode。<br>DataNode：Slave节点，负责存储client发来的数据块block；执行数据块的读写操作。<br>fsimage:元数据镜像文件（文件系统的目录树。）<br>edits：元数据的操作日志（针对文件系统做的修改操作记录）<br>namenode内存中存储的是=fsimage+edits。<br>SecondaryNameNode负责定时默认1小时，从namenode上，获取fsimage和edits来进行合并，然后再发送给namenode。减少namenode的工作量。</p>\n<h1 id=\"HDFS文件系统的优点\"><a href=\"#HDFS文件系统的优点\" class=\"headerlink\" title=\"HDFS文件系统的优点\"></a>HDFS文件系统的优点</h1><ol>\n<li>处理超大文件，超大文件通常是指百MB、设置数百TB大小的文件。目前在实际应用中，HDFS已经能用来存储管理PB级的数据了。</li>\n<li>流式的访问数据，HDFS的设计建立在更多地响应”一次写入、多次读写”任务的基础上。这意味着一个数据集一旦由数据源生成，就会被复制分发到不同的存储节点中，然后响应各种各样的数据分析任务请求。在多数情况下，分析任务都会涉及数据集中的大部分数据，也就是说，对HDFS来说，请求读取整个数据集要比读取一条记录更加高效。</li>\n<li>运行于廉价的商用机器集群上，Hadoop设计对硬件需求比较低，只须运行在低廉的商用硬件集群上，而无需昂贵的高可用性机器上。廉价的商用机也就意味着大型集群中出现节点故障情况的概率非常高。这就要求设计HDFS时要充分考虑数据的可靠性，安全性及高可用性。</li>\n</ol>\n<h1 id=\"HDFS的缺点\"><a href=\"#HDFS的缺点\" class=\"headerlink\" title=\"HDFS的缺点\"></a>HDFS的缺点</h1><ol>\n<li>不适合低延迟数据访问，如果要处理一些用户要求时间比较短的低延迟应用请求，则HDFS不适合。HDFS是为了处理大型数据集分析任务的，主要是为达到高的数据吞吐量而设计的，这就可能要求以高延迟作为代价。<br>　　对于那些有低延时要求的应用程序，HBase是一个更好的选择。通过上层数据管理项目来尽可能地弥补这个不足。在性能上有了很大的提升，它的口号就是goes real time。使用缓存或多master设计可以降低client的数据请求压力，以减少延时。还有就是对HDFS系统内部的修改，这就得权衡大吞吐量与低延时了，HDFS不是万能的银弹。</li>\n<li>无法高效存储大量小文件，因为Namenode把文件系统的元数据放置在内存中，所以文件系统所能容纳的文件数目是由Namenode的内存大小来决定。一般来说，每一个文件、文件夹和Block需要占据150字节左右的空间，所以，如果你有100万个文件，每一个占据一个Block，你就至少需要300MB内存。当前来说，数百万的文件还是可行的，当扩展到数十亿时，对于当前的硬件水平来说就没法实现了。还有一个问题就是，因为Map task的数量是由splits来决定的，所以用MR处理大量的小文件时，就会产生过多的Maptask，线程管理开销将会增加作业时间。举个例子，处理10000M的文件，若每个split为1M，那就会有10000个Maptasks，会有很大的线程开销；若每个split为100M，则只有100个Maptasks，每个Maptask将会有更多的事情做，而线程的管理开销也将减小很多。</li>\n<li>不支持多用户写入及任意修改文件，在HDFS的一个文件中只有一个写入者，而且写操作只能在文件末尾完成，即只能执行追加操作。目前HDFS还不支持多个用户对同一文件的写操作，以及在文件任意位置进行修改。<blockquote>\n<p>改进策略：要想让HDFS能处理好小文件：</p>\n<ol>\n<li>利用SequenceFile、MapFile、Har等方式归档小文件，这个方法的原理就是把小文件归档起来管理，HBase就是基于此的。对于这种方法，如果想找回原来的小文件内容，那就必须得知道与归档文件的映射关系。</li>\n<li>横向扩展，一个Hadoop集群能管理的小文件有限，那就把几个Hadoop集群拖在一个虚拟服务器后面，形成一个大的Hadoop集群。google也是这么干过的。</li>\n<li>多Master设计，这个作用显而易见了。正在研发中的GFS II也要改为分布式多Master设计，还支持Master的Failover，而且Block大小改为1M，有意要调优处理小文件啊。<br>Alibaba DFS的设计，也是多Master设计，它把Metadata的映射存储和管理分开了，由多个Metadata存储节点和一个查询Master节点组成。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"Hadoop是资源管理系统YARN\"><a href=\"#Hadoop是资源管理系统YARN\" class=\"headerlink\" title=\"Hadoop是资源管理系统YARN\"></a>Hadoop是资源管理系统YARN</h1><h2 id=\"ResourceManager\"><a href=\"#ResourceManager\" class=\"headerlink\" title=\"ResourceManager\"></a>ResourceManager</h2><p>整个集群只有一个，负责集群资源的统一管理和调度</p>\n<ol>\n<li>处理客户端请求</li>\n<li>启动/监控ApplicationMaster</li>\n<li>监控NodeManager</li>\n<li>资源分配与调度</li>\n</ol>\n<h2 id=\"NodeManager\"><a href=\"#NodeManager\" class=\"headerlink\" title=\"NodeManager\"></a>NodeManager</h2><p>整个集群有多个，负责单节点资源管理和使用</p>\n<ol>\n<li>单个节点上的资源管理和任务管理</li>\n<li>处理来自ResourceManager的命令</li>\n<li>处理来自ApplicationMaster的命令</li>\n</ol>\n<h2 id=\"ApplicationMaster\"><a href=\"#ApplicationMaster\" class=\"headerlink\" title=\"ApplicationMaster\"></a>ApplicationMaster</h2><p>每个应用有一个，负责应用程序的管理</p>\n<ol>\n<li>数据切分</li>\n<li>为应用程序申请资源，并进一步分配给内部任务</li>\n<li>任务监控与容错</li>\n</ol>\n<h2 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h2><p>对任务运行环境的抽象，描述一系列信息</p>\n<ol>\n<li>任务运行资源（节点、内存、CPU）</li>\n<li>任务启动命令</li>\n<li>任务运行环境</li>\n</ol>\n<h1 id=\"Hadoop数据分析框架\"><a href=\"#Hadoop数据分析框架\" class=\"headerlink\" title=\"Hadoop数据分析框架\"></a>Hadoop数据分析框架</h1><p>MapReduce是Hadoop的大数据分布式处理系统，Hadoop核心之MapReduce是一个软件框架，基于该框架能够容易地编写应用程序，这些应用程序能够运行在由上千个商用机器组成的大集群上，并以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集。<br>MapReduce主要是用于解决Hadoop大数据处理的。所谓大数据处理，即以对大数据加工、挖掘和优化等各种处理。<br>MapReduce擅长处理大数据，其主要思想是“分而治之”。Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：一是数据或计算的规模相对原任务要大大缩小；二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算；三是这些小任务可以并行计算，彼此间几乎没有依赖关系。Reducer负责对map阶段的结果进行汇总。可以设置多个Reducer（通过在mapred-site.xml配置文件里设置参数mapred.reduce.tasks的值，缺省值为1）。<br>MapReduce的工作机制如图所示：</p>\n<p>MapReduce的整个工作过程如上图所示，它包含如下4个独立的实体：<br>　　1. 客户端，用来提交MapReduce作业。<br>　　2. jobtracker，用来协调作业的运行。<br>　　3. tasktracker，用来处理作业划分后的任务。<br>　　4. HDFS，用来在其它实体间共享作业文件。<br>MapReduce整个工作过程有序地包含如下工作环节：<br>　　1. 作业的提交<br>　　2. 作业的初始化<br>　　3. 任务的分配<br>　　4. 任务的执行<br>　　5. 进程和状态的更新<br>　　6. 作业的完成 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hadoop是什么\"><a href=\"#Hadoop是什么\" class=\"headerlink\" title=\"Hadoop是什么\"></a>Hadoop是什么</h1><p>Hadoop是根据Google发表的两篇论文（论述Google文件系统（GFS）和MapReduce框架）开发出的开源框架。<br>Hadoop是一种开源的适合大数据的分布式存储和处理的平台。作为一种大规模分布式数据处理平台。</p>\n<h1 id=\"Hadoop能做什么\"><a href=\"#Hadoop能做什么\" class=\"headerlink\" title=\"Hadoop能做什么\"></a>Hadoop能做什么</h1><ol>\n<li>搜索引擎：这也正是Doug Cutting设计Hadoop的初衷，为了针对大规模的网页快速建立索引；</li>\n<li>大数据存储：利用Hadoop的分布式存储能力，例如数据备份、数据仓库等；</li>\n<li>大数据处理：利用Hadoop的分布式处理能力，例如数据挖掘、数据分析等；</li>\n<li>科学研究：Hadoop是一种分布式的开源框架，对于分布式系统有很大程度地参考价值。</li>\n</ol>\n<h1 id=\"Hadoop三种模式\"><a href=\"#Hadoop三种模式\" class=\"headerlink\" title=\"Hadoop三种模式\"></a>Hadoop三种模式</h1><p>Hadoop有三种不同的模式操作，分别为单机模式、伪分布模式和全分布模式。Hadoop官网都详细介绍了三种模式的配置方式。</p>\n<h1 id=\"Hadoop分布式文件系统HDFS\"><a href=\"#Hadoop分布式文件系统HDFS\" class=\"headerlink\" title=\"Hadoop分布式文件系统HDFS\"></a>Hadoop分布式文件系统HDFS</h1><p>Hadoop分布式文件系统（Hadoop Distributed File System，简称HDFS）是Hadoop的核心模块之一，它主要解决Hadoop的大数据存储问题，其思想来源与Google的文件系统GFS。HDFS的主要特点：</p>\n<ol>\n<li>保存多个副本，且提供容错机制，副本丢失或宕机自动恢复。默认存3份。</li>\n<li>运行在廉价的机器上,可以用大规模的PC机搭建出高可用、高性能的服务集群</li>\n<li>适合大数据的处理。HDFS默认会将文件分割成block，128M为1个block。然后将block按键值对存储在HDFS上，并将键值对的映射存到内存中。Hadoop更适合处理大文件，如果小文件太多，那内存的负担会很重。</li>\n</ol>\n<h2 id=\"HDFS中的四个重要对象：\"><a href=\"#HDFS中的四个重要对象：\" class=\"headerlink\" title=\"HDFS中的四个重要对象：\"></a>HDFS中的四个重要对象：</h2><h3 id=\"Namenode\"><a href=\"#Namenode\" class=\"headerlink\" title=\"[Namenode]\"></a>[Namenode]</h3><ol>\n<li>管理文件系统的命名空间。</li>\n<li>记录每个文件数据块在各个Datanode上的位置和副本信息。</li>\n<li>协调客户端对文件的访问。</li>\n<li>记录命名空间内的改动或者空间本省属性的改动。</li>\n<li>校验块的完整性，副本数量</li>\n<li>Namenode 使用事务日志记录HDFS元数据的变化。使用映像文件存储文件系统的命名空间，包括文件映射，文件属性等。<br>Namenode是HDFS里面的管理者，发挥者管理、协调、操控的作用。</li>\n</ol>\n<h3 id=\"Datanode\"><a href=\"#Datanode\" class=\"headerlink\" title=\"[Datanode]\"></a>[Datanode]</h3><ol>\n<li>Datnode会发送心跳和块报告给namenode，如果namenode长时间没收到心跳，会判断此节点丢失，并不会再给这个分配任务</li>\n<li>负责所在物理节点的存储管理。</li>\n<li>一次写入，多次读取（不能修改）。</li>\n<li>文件由数据库组成，一般情况下，数据块的大小为128MB。</li>\n<li>数据尽量散步到各个节点<br>Datanode是HDFS的工作者，发挥按着Namenode的命令干活，并且把干活的进展和问题反馈到Namenode的作用。</li>\n</ol>\n<h4 id=\"客户端如何访问HDFS中一个文件呢\"><a href=\"#客户端如何访问HDFS中一个文件呢\" class=\"headerlink\" title=\"客户端如何访问HDFS中一个文件呢\"></a>客户端如何访问HDFS中一个文件呢</h4><ol>\n<li>首先从Namenode获得组成这个文件的数据块位置列表。</li>\n<li>接下来根据位置列表知道存储数据块的Datanode。</li>\n<li>最后访问Datanode获取数据。<br>Namenode并不参与数据实际传输。</li>\n</ol>\n<h3 id=\"SecondaryNameNode\"><a href=\"#SecondaryNameNode\" class=\"headerlink\" title=\"[SecondaryNameNode]\"></a>[SecondaryNameNode]</h3><ol>\n<li>定期合并namenode的编辑日志到fsimage</li>\n<li>一旦它有了新的fsimage文件，它将其拷贝回NameNode中。</li>\n<li>NameNode在下次重启时会使用这个新的fsimage文件，从而减少重启的时间<br>SecondaryNameNode辅助NameNode工作，好比是namenode的秘书，不参与实际的管理工作</li>\n</ol>\n<h4 id=\"HDFS是如何保证其可靠性呢\"><a href=\"#HDFS是如何保证其可靠性呢\" class=\"headerlink\" title=\"HDFS是如何保证其可靠性呢\"></a>HDFS是如何保证其可靠性呢</h4><p>数据存储系统，数据存储的可靠性至关重要。</p>\n<ol>\n<li>冗余副本策略，即所有数据都有副本，副本的数目可以在hdfs-site.xml中设置相应的复制因子。</li>\n<li>机架策略，即HDFS的“机架感知”，一般在本机架存放一个副本，在其它机架再存放别的副本，这样可以防止机架失效时丢失数据，也可以提供带宽利用率。</li>\n<li>心跳机制，即Namenode周期性从Datanode接受心跳信号和快报告，没有按时发送心跳的Datanode会被标记为宕机，不会再给任何I/O请求，若是Datanode失效造成副本数量下降，并且低于预先设置的阈值，Namenode会检测出这些数据块，并在合适的时机进行重新复制。</li>\n<li>安全模式，Namenode启动时会先经过一个“安全模式”阶段。</li>\n<li>校验和，客户端获取数据通过检查校验和，发现数据块是否损坏，从而确定是否要读取副本。</li>\n<li>回收站，删除文件，会先到回收站/trash，其里面文件可以快速回复。</li>\n<li>元数据保护，映像文件和事务日志是Namenode的核心数据，可以配置为拥有多个副本。</li>\n<li>快照，支持存储某个时间点的映像，需要时可以使数据重返这个时间点的状态。</li>\n</ol>\n<p>HDFS也是按照Master和Slave的结构。分NameNode、SecondaryNameNode、DataNode这几个角色。<br>NameNode：是Master节点，是大领导。管理数据块映射；处理客户端的读写请求；配置副本策略；管理HDFS的名称空间；<br>SecondaryNameNode：是一个小弟，分担大哥namenode的工作量；是NameNode的冷备份；合并fsimage和fsedits然后再发给namenode。<br>DataNode：Slave节点，负责存储client发来的数据块block；执行数据块的读写操作。<br>fsimage:元数据镜像文件（文件系统的目录树。）<br>edits：元数据的操作日志（针对文件系统做的修改操作记录）<br>namenode内存中存储的是=fsimage+edits。<br>SecondaryNameNode负责定时默认1小时，从namenode上，获取fsimage和edits来进行合并，然后再发送给namenode。减少namenode的工作量。</p>\n<h1 id=\"HDFS文件系统的优点\"><a href=\"#HDFS文件系统的优点\" class=\"headerlink\" title=\"HDFS文件系统的优点\"></a>HDFS文件系统的优点</h1><ol>\n<li>处理超大文件，超大文件通常是指百MB、设置数百TB大小的文件。目前在实际应用中，HDFS已经能用来存储管理PB级的数据了。</li>\n<li>流式的访问数据，HDFS的设计建立在更多地响应”一次写入、多次读写”任务的基础上。这意味着一个数据集一旦由数据源生成，就会被复制分发到不同的存储节点中，然后响应各种各样的数据分析任务请求。在多数情况下，分析任务都会涉及数据集中的大部分数据，也就是说，对HDFS来说，请求读取整个数据集要比读取一条记录更加高效。</li>\n<li>运行于廉价的商用机器集群上，Hadoop设计对硬件需求比较低，只须运行在低廉的商用硬件集群上，而无需昂贵的高可用性机器上。廉价的商用机也就意味着大型集群中出现节点故障情况的概率非常高。这就要求设计HDFS时要充分考虑数据的可靠性，安全性及高可用性。</li>\n</ol>\n<h1 id=\"HDFS的缺点\"><a href=\"#HDFS的缺点\" class=\"headerlink\" title=\"HDFS的缺点\"></a>HDFS的缺点</h1><ol>\n<li>不适合低延迟数据访问，如果要处理一些用户要求时间比较短的低延迟应用请求，则HDFS不适合。HDFS是为了处理大型数据集分析任务的，主要是为达到高的数据吞吐量而设计的，这就可能要求以高延迟作为代价。<br>　　对于那些有低延时要求的应用程序，HBase是一个更好的选择。通过上层数据管理项目来尽可能地弥补这个不足。在性能上有了很大的提升，它的口号就是goes real time。使用缓存或多master设计可以降低client的数据请求压力，以减少延时。还有就是对HDFS系统内部的修改，这就得权衡大吞吐量与低延时了，HDFS不是万能的银弹。</li>\n<li>无法高效存储大量小文件，因为Namenode把文件系统的元数据放置在内存中，所以文件系统所能容纳的文件数目是由Namenode的内存大小来决定。一般来说，每一个文件、文件夹和Block需要占据150字节左右的空间，所以，如果你有100万个文件，每一个占据一个Block，你就至少需要300MB内存。当前来说，数百万的文件还是可行的，当扩展到数十亿时，对于当前的硬件水平来说就没法实现了。还有一个问题就是，因为Map task的数量是由splits来决定的，所以用MR处理大量的小文件时，就会产生过多的Maptask，线程管理开销将会增加作业时间。举个例子，处理10000M的文件，若每个split为1M，那就会有10000个Maptasks，会有很大的线程开销；若每个split为100M，则只有100个Maptasks，每个Maptask将会有更多的事情做，而线程的管理开销也将减小很多。</li>\n<li>不支持多用户写入及任意修改文件，在HDFS的一个文件中只有一个写入者，而且写操作只能在文件末尾完成，即只能执行追加操作。目前HDFS还不支持多个用户对同一文件的写操作，以及在文件任意位置进行修改。<blockquote>\n<p>改进策略：要想让HDFS能处理好小文件：</p>\n<ol>\n<li>利用SequenceFile、MapFile、Har等方式归档小文件，这个方法的原理就是把小文件归档起来管理，HBase就是基于此的。对于这种方法，如果想找回原来的小文件内容，那就必须得知道与归档文件的映射关系。</li>\n<li>横向扩展，一个Hadoop集群能管理的小文件有限，那就把几个Hadoop集群拖在一个虚拟服务器后面，形成一个大的Hadoop集群。google也是这么干过的。</li>\n<li>多Master设计，这个作用显而易见了。正在研发中的GFS II也要改为分布式多Master设计，还支持Master的Failover，而且Block大小改为1M，有意要调优处理小文件啊。<br>Alibaba DFS的设计，也是多Master设计，它把Metadata的映射存储和管理分开了，由多个Metadata存储节点和一个查询Master节点组成。</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<h1 id=\"Hadoop是资源管理系统YARN\"><a href=\"#Hadoop是资源管理系统YARN\" class=\"headerlink\" title=\"Hadoop是资源管理系统YARN\"></a>Hadoop是资源管理系统YARN</h1><h2 id=\"ResourceManager\"><a href=\"#ResourceManager\" class=\"headerlink\" title=\"ResourceManager\"></a>ResourceManager</h2><p>整个集群只有一个，负责集群资源的统一管理和调度</p>\n<ol>\n<li>处理客户端请求</li>\n<li>启动/监控ApplicationMaster</li>\n<li>监控NodeManager</li>\n<li>资源分配与调度</li>\n</ol>\n<h2 id=\"NodeManager\"><a href=\"#NodeManager\" class=\"headerlink\" title=\"NodeManager\"></a>NodeManager</h2><p>整个集群有多个，负责单节点资源管理和使用</p>\n<ol>\n<li>单个节点上的资源管理和任务管理</li>\n<li>处理来自ResourceManager的命令</li>\n<li>处理来自ApplicationMaster的命令</li>\n</ol>\n<h2 id=\"ApplicationMaster\"><a href=\"#ApplicationMaster\" class=\"headerlink\" title=\"ApplicationMaster\"></a>ApplicationMaster</h2><p>每个应用有一个，负责应用程序的管理</p>\n<ol>\n<li>数据切分</li>\n<li>为应用程序申请资源，并进一步分配给内部任务</li>\n<li>任务监控与容错</li>\n</ol>\n<h2 id=\"Container\"><a href=\"#Container\" class=\"headerlink\" title=\"Container\"></a>Container</h2><p>对任务运行环境的抽象，描述一系列信息</p>\n<ol>\n<li>任务运行资源（节点、内存、CPU）</li>\n<li>任务启动命令</li>\n<li>任务运行环境</li>\n</ol>\n<h1 id=\"Hadoop数据分析框架\"><a href=\"#Hadoop数据分析框架\" class=\"headerlink\" title=\"Hadoop数据分析框架\"></a>Hadoop数据分析框架</h1><p>MapReduce是Hadoop的大数据分布式处理系统，Hadoop核心之MapReduce是一个软件框架，基于该框架能够容易地编写应用程序，这些应用程序能够运行在由上千个商用机器组成的大集群上，并以一种可靠的，具有容错能力的方式并行地处理上TB级别的海量数据集。<br>MapReduce主要是用于解决Hadoop大数据处理的。所谓大数据处理，即以对大数据加工、挖掘和优化等各种处理。<br>MapReduce擅长处理大数据，其主要思想是“分而治之”。Mapper负责“分”，即把复杂的任务分解为若干个“简单的任务”来处理。“简单的任务”包含三层含义：一是数据或计算的规模相对原任务要大大缩小；二是就近计算原则，即任务会分配到存放着所需数据的节点上进行计算；三是这些小任务可以并行计算，彼此间几乎没有依赖关系。Reducer负责对map阶段的结果进行汇总。可以设置多个Reducer（通过在mapred-site.xml配置文件里设置参数mapred.reduce.tasks的值，缺省值为1）。<br>MapReduce的工作机制如图所示：</p>\n<p>MapReduce的整个工作过程如上图所示，它包含如下4个独立的实体：<br>　　1. 客户端，用来提交MapReduce作业。<br>　　2. jobtracker，用来协调作业的运行。<br>　　3. tasktracker，用来处理作业划分后的任务。<br>　　4. HDFS，用来在其它实体间共享作业文件。<br>MapReduce整个工作过程有序地包含如下工作环节：<br>　　1. 作业的提交<br>　　2. 作业的初始化<br>　　3. 任务的分配<br>　　4. 任务的执行<br>　　5. 进程和状态的更新<br>　　6. 作业的完成 </p>\n"},{"title":"Hive学习笔记","date":"2017-08-12T09:28:43.000Z","_content":"\n# Hive简单介绍\n　　Hive是一种以SQL风格进行任何大小数据分析的工具，其特点是通过 SQL处理Hadoop的大数据，数据规模可以伸缩扩展到100PB+，数据形式可以是结构或非结构数据。\n\n# Hive与传统关系数据库比较\n* 侧重于分析，而非实时在线交易\n* 无事务机制\n* 不像关系数据库那样可以随机进行 insert或update.\n* 通过Hadoop的map/reduce进行分布式处理，传统数据库则没有\n* 传统关系数据库只能拓展最多20个服务器，而Hive可以拓展到上百个服务器。\n\n# 安装Hive\n1. 首先我们需要安装Java环境和Hadoop环境\n2. 从这里http://mirrors.shuosc.org/apache/hive/获取Hive安装包\n3. 解压安装包到安装目录下\n```\n$ tar -xzvf apache-hive-2.2.0-bin.tar.gz\n```\n4. 添加环境变量\n```\nexport HIVE_HOME={{/user/local/hive-2.2.0}}\nexport PATH=$HIVE_HOME/bin:$PATH\n```\n5. 配置hive-env.sh文件\n```\nHADOOP_HOME=/user/local/hadoop-2.8.1\nexport HIVE_CONF_DIR=/user/local/hive-2.2.0/conf\n```\n6. 在HDFS文件系统上创建数据仓库目录并赋予权限\n```\n  $ hdfs dfs -mkdir       /tmp\n  $ hdfs dfs -mkdir       /user/hive/warehouse\n  $ hdfs dfs -chmod g+w   /tmp\n  $ hdfs dfs -chmod g+w   /user/hive/warehouse\n```\n7. 使用配置启动Hive，需要初始化Hive的metastore数据库\n```\n$ bin/schematool -initSchema -dbType derby #我在这里折腾了很久....\n```\n8. 如果报这个错误的话（message:Version information not found in metastore. ），需要修改下面这个配置项\n```\n<property>\n    <name>hive.metastore.schema.verification</name>\n    <value>true</value>  #这里把true修改成false\n</property>\n```\n9. 到这一步就可以使用命令启动Hive了\n```\n$ bin/hive\n```\n# Hive数据类型\n\n|数据类型|所占字节|开始支持版本|\n|TINYINT|1byte，-128 ~ 127||\t \n|SMALLINT|2byte，-32,768 ~ 32,767||\t \n|INT|4byte,-2,147,483,648 ~ 2,147,483,647||\t \n|BIGINT|8byte,-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807||\n|BOOLEAN||| \t \n|FLOAT|4byte单精度|| \n|DOUBLE|8byte双精度||\n|STRING||| \n|BINARY||从Hive0.8.0开始支持|\n|TIMESTAMP||从Hive0.8.0开始支持|\n|DECIMAL||从Hive0.11.0开始支持|\n|CHAR||从Hive0.13.0开始支持|\n|VARCHAR||从Hive0.12.0开始支持|\n|DATE||从Hive0.12.0开始支持|\n\n# 数据库操作\n## 创建数据库\n```\nCREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name\n  [COMMENT database_comment]\n  [LOCATION hdfs_path]\n  [WITH DBPROPERTIES (property_name=property_value, ...)];\n```\n## 删除数据库\n```\nDROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE];\n```\n## 修改数据库\n```\nALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...);   -- (Note: SCHEMA added in Hive 0.14.0)\n \nALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role;   -- (Note: Hive 0.13.0 and later; SCHEMA added in Hive 0.14.0)\n \nALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path; -- (Note: Hive 2.2.1, 2.4.0 and later)\n```\n# 数据库表操作\n## 创建表\n```\nCREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive 0.14.0 and later)\n  [(col_name data_type [COMMENT col_comment], ... [constraint_specification])]\n  [COMMENT table_comment]\n  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]\n  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]\n  [SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive 0.10.0 and later)]\n     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)\n     [STORED AS DIRECTORIES]\n  [\n   [ROW FORMAT row_format] #指定行分隔符\n***[FIELDS TERMINATED BY ] #指定字段间的分隔符\n   [STORED AS file_format]   \n     | STORED BY 'storage.handler.class.name' [WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive 0.6.0 and later)\n  ]\n  [LOCATION hdfs_path]\n  [TBLPROPERTIES (property_name=property_value, ...)]   -- (Note: Available in Hive 0.6.0 and later)\n  [AS select_statement];   -- (Note: Available in Hive 0.5.0 and later; not supported for external tables)\n\nCREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name\n  LIKE existing_table_or_view_name\n  [LOCATION hdfs_path];\n```\n# 添加分区表\n```\nALTER TABLE table_name ADD [IF NOT EXISTS] PARTITION partition_spec\n[LOCATION 'location1'] partition_spec [LOCATION 'location2'] ...;\n\npartition_spec:\n: (p_column = p_col_value, p_column = p_col_value, ...)\n```\n把数据一定规则划分（例如：把收集的日志按天存放），把数据按天存储在一个单独的文件，可以减少了查询处理时间。\n\n## 加载数据到表中\n```\nLOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename \n[PARTITION (partcol1=val1, partcol2=val2 ...)]\n```\n\n# SQL语句\n## 基本查询语句\n```\nSELECT [ALL | DISTINCT] select_expr, select_expr, ... \nFROM table_reference \n[WHERE where_condition] \n[GROUP BY col_list] \n[HAVING having_condition] \n[CLUSTER BY col_list |                   #col_list相同时，CLUSTER BY相当于是DISTRIBUTE BY和SORT BY的组合\n [DISTRIBUTE BY col_list]                #控制map的输出在reducer是如何划分的（默认是通过hash的方式划分）\n [SORT BY col_list]]                     #每个reducer端都会做排序\n[LIMIT number];\n```\n\n## JOIN查询\n```\njoin_table:\n\n   table_reference JOIN table_factor [join_condition]\n   | table_reference {LEFT|RIGHT|FULL} [OUTER] JOIN table_reference\n   join_condition\n   | table_reference LEFT SEMI JOIN table_reference join_condition\n   | table_reference CROSS JOIN table_reference [join_condition]\n```\n","source":"_posts/Hive学习笔记.md","raw":"---\ntitle: Hive学习笔记\ndate: 2017-08-12 17:28:43\ncategories:\n  BigData\ntags: \n  - Hadoop\n  - Hive\n  - Server\n  - Technology\n---\n\n# Hive简单介绍\n　　Hive是一种以SQL风格进行任何大小数据分析的工具，其特点是通过 SQL处理Hadoop的大数据，数据规模可以伸缩扩展到100PB+，数据形式可以是结构或非结构数据。\n\n# Hive与传统关系数据库比较\n* 侧重于分析，而非实时在线交易\n* 无事务机制\n* 不像关系数据库那样可以随机进行 insert或update.\n* 通过Hadoop的map/reduce进行分布式处理，传统数据库则没有\n* 传统关系数据库只能拓展最多20个服务器，而Hive可以拓展到上百个服务器。\n\n# 安装Hive\n1. 首先我们需要安装Java环境和Hadoop环境\n2. 从这里http://mirrors.shuosc.org/apache/hive/获取Hive安装包\n3. 解压安装包到安装目录下\n```\n$ tar -xzvf apache-hive-2.2.0-bin.tar.gz\n```\n4. 添加环境变量\n```\nexport HIVE_HOME={{/user/local/hive-2.2.0}}\nexport PATH=$HIVE_HOME/bin:$PATH\n```\n5. 配置hive-env.sh文件\n```\nHADOOP_HOME=/user/local/hadoop-2.8.1\nexport HIVE_CONF_DIR=/user/local/hive-2.2.0/conf\n```\n6. 在HDFS文件系统上创建数据仓库目录并赋予权限\n```\n  $ hdfs dfs -mkdir       /tmp\n  $ hdfs dfs -mkdir       /user/hive/warehouse\n  $ hdfs dfs -chmod g+w   /tmp\n  $ hdfs dfs -chmod g+w   /user/hive/warehouse\n```\n7. 使用配置启动Hive，需要初始化Hive的metastore数据库\n```\n$ bin/schematool -initSchema -dbType derby #我在这里折腾了很久....\n```\n8. 如果报这个错误的话（message:Version information not found in metastore. ），需要修改下面这个配置项\n```\n<property>\n    <name>hive.metastore.schema.verification</name>\n    <value>true</value>  #这里把true修改成false\n</property>\n```\n9. 到这一步就可以使用命令启动Hive了\n```\n$ bin/hive\n```\n# Hive数据类型\n\n|数据类型|所占字节|开始支持版本|\n|TINYINT|1byte，-128 ~ 127||\t \n|SMALLINT|2byte，-32,768 ~ 32,767||\t \n|INT|4byte,-2,147,483,648 ~ 2,147,483,647||\t \n|BIGINT|8byte,-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807||\n|BOOLEAN||| \t \n|FLOAT|4byte单精度|| \n|DOUBLE|8byte双精度||\n|STRING||| \n|BINARY||从Hive0.8.0开始支持|\n|TIMESTAMP||从Hive0.8.0开始支持|\n|DECIMAL||从Hive0.11.0开始支持|\n|CHAR||从Hive0.13.0开始支持|\n|VARCHAR||从Hive0.12.0开始支持|\n|DATE||从Hive0.12.0开始支持|\n\n# 数据库操作\n## 创建数据库\n```\nCREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name\n  [COMMENT database_comment]\n  [LOCATION hdfs_path]\n  [WITH DBPROPERTIES (property_name=property_value, ...)];\n```\n## 删除数据库\n```\nDROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE];\n```\n## 修改数据库\n```\nALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...);   -- (Note: SCHEMA added in Hive 0.14.0)\n \nALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role;   -- (Note: Hive 0.13.0 and later; SCHEMA added in Hive 0.14.0)\n \nALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path; -- (Note: Hive 2.2.1, 2.4.0 and later)\n```\n# 数据库表操作\n## 创建表\n```\nCREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive 0.14.0 and later)\n  [(col_name data_type [COMMENT col_comment], ... [constraint_specification])]\n  [COMMENT table_comment]\n  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]\n  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]\n  [SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive 0.10.0 and later)]\n     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)\n     [STORED AS DIRECTORIES]\n  [\n   [ROW FORMAT row_format] #指定行分隔符\n***[FIELDS TERMINATED BY ] #指定字段间的分隔符\n   [STORED AS file_format]   \n     | STORED BY 'storage.handler.class.name' [WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive 0.6.0 and later)\n  ]\n  [LOCATION hdfs_path]\n  [TBLPROPERTIES (property_name=property_value, ...)]   -- (Note: Available in Hive 0.6.0 and later)\n  [AS select_statement];   -- (Note: Available in Hive 0.5.0 and later; not supported for external tables)\n\nCREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name\n  LIKE existing_table_or_view_name\n  [LOCATION hdfs_path];\n```\n# 添加分区表\n```\nALTER TABLE table_name ADD [IF NOT EXISTS] PARTITION partition_spec\n[LOCATION 'location1'] partition_spec [LOCATION 'location2'] ...;\n\npartition_spec:\n: (p_column = p_col_value, p_column = p_col_value, ...)\n```\n把数据一定规则划分（例如：把收集的日志按天存放），把数据按天存储在一个单独的文件，可以减少了查询处理时间。\n\n## 加载数据到表中\n```\nLOAD DATA [LOCAL] INPATH 'filepath' [OVERWRITE] INTO TABLE tablename \n[PARTITION (partcol1=val1, partcol2=val2 ...)]\n```\n\n# SQL语句\n## 基本查询语句\n```\nSELECT [ALL | DISTINCT] select_expr, select_expr, ... \nFROM table_reference \n[WHERE where_condition] \n[GROUP BY col_list] \n[HAVING having_condition] \n[CLUSTER BY col_list |                   #col_list相同时，CLUSTER BY相当于是DISTRIBUTE BY和SORT BY的组合\n [DISTRIBUTE BY col_list]                #控制map的输出在reducer是如何划分的（默认是通过hash的方式划分）\n [SORT BY col_list]]                     #每个reducer端都会做排序\n[LIMIT number];\n```\n\n## JOIN查询\n```\njoin_table:\n\n   table_reference JOIN table_factor [join_condition]\n   | table_reference {LEFT|RIGHT|FULL} [OUTER] JOIN table_reference\n   join_condition\n   | table_reference LEFT SEMI JOIN table_reference join_condition\n   | table_reference CROSS JOIN table_reference [join_condition]\n```\n","slug":"Hive学习笔记","published":1,"updated":"2017-09-21T10:31:43.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja38v000b44ei9grhlcqi","content":"<h1 id=\"Hive简单介绍\"><a href=\"#Hive简单介绍\" class=\"headerlink\" title=\"Hive简单介绍\"></a>Hive简单介绍</h1><p>　　Hive是一种以SQL风格进行任何大小数据分析的工具，其特点是通过 SQL处理Hadoop的大数据，数据规模可以伸缩扩展到100PB+，数据形式可以是结构或非结构数据。</p>\n<h1 id=\"Hive与传统关系数据库比较\"><a href=\"#Hive与传统关系数据库比较\" class=\"headerlink\" title=\"Hive与传统关系数据库比较\"></a>Hive与传统关系数据库比较</h1><ul>\n<li>侧重于分析，而非实时在线交易</li>\n<li>无事务机制</li>\n<li>不像关系数据库那样可以随机进行 insert或update.</li>\n<li>通过Hadoop的map/reduce进行分布式处理，传统数据库则没有</li>\n<li>传统关系数据库只能拓展最多20个服务器，而Hive可以拓展到上百个服务器。</li>\n</ul>\n<h1 id=\"安装Hive\"><a href=\"#安装Hive\" class=\"headerlink\" title=\"安装Hive\"></a>安装Hive</h1><ol>\n<li>首先我们需要安装Java环境和Hadoop环境</li>\n<li>从这里<a href=\"http://mirrors.shuosc.org/apache/hive/获取Hive安装包\" target=\"_blank\" rel=\"external\">http://mirrors.shuosc.org/apache/hive/获取Hive安装包</a></li>\n<li><p>解压安装包到安装目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tar -xzvf apache-hive-2.2.0-bin.tar.gz</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export HIVE_HOME=&#123;&#123;/user/local/hive-2.2.0&#125;&#125;</div><div class=\"line\">export PATH=$HIVE_HOME/bin:$PATH</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置hive-env.sh文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">HADOOP_HOME=/user/local/hadoop-2.8.1</div><div class=\"line\">export HIVE_CONF_DIR=/user/local/hive-2.2.0/conf</div></pre></td></tr></table></figure>\n</li>\n<li><p>在HDFS文件系统上创建数据仓库目录并赋予权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hdfs dfs -mkdir       /tmp</div><div class=\"line\">$ hdfs dfs -mkdir       /user/hive/warehouse</div><div class=\"line\">$ hdfs dfs -chmod g+w   /tmp</div><div class=\"line\">$ hdfs dfs -chmod g+w   /user/hive/warehouse</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用配置启动Hive，需要初始化Hive的metastore数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bin/schematool -initSchema -dbType derby #我在这里折腾了很久....</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果报这个错误的话（message:Version information not found in metastore. ），需要修改下面这个配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;  #这里把true修改成false</div><div class=\"line\">&lt;/property&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>到这一步就可以使用命令启动Hive了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bin/hive</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Hive数据类型\"><a href=\"#Hive数据类型\" class=\"headerlink\" title=\"Hive数据类型\"></a>Hive数据类型</h1><p>|数据类型|所占字节|开始支持版本|<br>|TINYINT|1byte，-128 ~ 127||<br>|SMALLINT|2byte，-32,768 ~ 32,767||<br>|INT|4byte,-2,147,483,648 ~ 2,147,483,647||<br>|BIGINT|8byte,-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807||<br>|BOOLEAN|||<br>|FLOAT|4byte单精度||<br>|DOUBLE|8byte双精度||<br>|STRING|||<br>|BINARY||从Hive0.8.0开始支持|<br>|TIMESTAMP||从Hive0.8.0开始支持|<br>|DECIMAL||从Hive0.11.0开始支持|<br>|CHAR||从Hive0.13.0开始支持|<br>|VARCHAR||从Hive0.12.0开始支持|<br>|DATE||从Hive0.12.0开始支持|</p>\n<h1 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h1><h2 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name</div><div class=\"line\">  [COMMENT database_comment]</div><div class=\"line\">  [LOCATION hdfs_path]</div><div class=\"line\">  [WITH DBPROPERTIES (property_name=property_value, ...)];</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE];</div></pre></td></tr></table></figure>\n<h2 id=\"修改数据库\"><a href=\"#修改数据库\" class=\"headerlink\" title=\"修改数据库\"></a>修改数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...);   -- (Note: SCHEMA added in Hive 0.14.0)</div><div class=\"line\"> </div><div class=\"line\">ALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role;   -- (Note: Hive 0.13.0 and later; SCHEMA added in Hive 0.14.0)</div><div class=\"line\"> </div><div class=\"line\">ALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path; -- (Note: Hive 2.2.1, 2.4.0 and later)</div></pre></td></tr></table></figure>\n<h1 id=\"数据库表操作\"><a href=\"#数据库表操作\" class=\"headerlink\" title=\"数据库表操作\"></a>数据库表操作</h1><h2 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive 0.14.0 and later)</div><div class=\"line\">  [(col_name data_type [COMMENT col_comment], ... [constraint_specification])]</div><div class=\"line\">  [COMMENT table_comment]</div><div class=\"line\">  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]</div><div class=\"line\">  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</div><div class=\"line\">  [SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive 0.10.0 and later)]</div><div class=\"line\">     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)</div><div class=\"line\">     [STORED AS DIRECTORIES]</div><div class=\"line\">  [</div><div class=\"line\">   [ROW FORMAT row_format] #指定行分隔符</div><div class=\"line\">***[FIELDS TERMINATED BY ] #指定字段间的分隔符</div><div class=\"line\">   [STORED AS file_format]   </div><div class=\"line\">     | STORED BY &apos;storage.handler.class.name&apos; [WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive 0.6.0 and later)</div><div class=\"line\">  ]</div><div class=\"line\">  [LOCATION hdfs_path]</div><div class=\"line\">  [TBLPROPERTIES (property_name=property_value, ...)]   -- (Note: Available in Hive 0.6.0 and later)</div><div class=\"line\">  [AS select_statement];   -- (Note: Available in Hive 0.5.0 and later; not supported for external tables)</div><div class=\"line\"></div><div class=\"line\">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name</div><div class=\"line\">  LIKE existing_table_or_view_name</div><div class=\"line\">  [LOCATION hdfs_path];</div></pre></td></tr></table></figure>\n<h1 id=\"添加分区表\"><a href=\"#添加分区表\" class=\"headerlink\" title=\"添加分区表\"></a>添加分区表</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALTER TABLE table_name ADD [IF NOT EXISTS] PARTITION partition_spec</div><div class=\"line\">[LOCATION &apos;location1&apos;] partition_spec [LOCATION &apos;location2&apos;] ...;</div><div class=\"line\"></div><div class=\"line\">partition_spec:</div><div class=\"line\">: (p_column = p_col_value, p_column = p_col_value, ...)</div></pre></td></tr></table></figure>\n<p>把数据一定规则划分（例如：把收集的日志按天存放），把数据按天存储在一个单独的文件，可以减少了查询处理时间。</p>\n<h2 id=\"加载数据到表中\"><a href=\"#加载数据到表中\" class=\"headerlink\" title=\"加载数据到表中\"></a>加载数据到表中</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOAD DATA [LOCAL] INPATH &apos;filepath&apos; [OVERWRITE] INTO TABLE tablename </div><div class=\"line\">[PARTITION (partcol1=val1, partcol2=val2 ...)]</div></pre></td></tr></table></figure>\n<h1 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h1><h2 id=\"基本查询语句\"><a href=\"#基本查询语句\" class=\"headerlink\" title=\"基本查询语句\"></a>基本查询语句</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT [ALL | DISTINCT] select_expr, select_expr, ... </div><div class=\"line\">FROM table_reference </div><div class=\"line\">[WHERE where_condition] </div><div class=\"line\">[GROUP BY col_list] </div><div class=\"line\">[HAVING having_condition] </div><div class=\"line\">[CLUSTER BY col_list |                   #col_list相同时，CLUSTER BY相当于是DISTRIBUTE BY和SORT BY的组合</div><div class=\"line\"> [DISTRIBUTE BY col_list]                #控制map的输出在reducer是如何划分的（默认是通过hash的方式划分）</div><div class=\"line\"> [SORT BY col_list]]                     #每个reducer端都会做排序</div><div class=\"line\">[LIMIT number];</div></pre></td></tr></table></figure>\n<h2 id=\"JOIN查询\"><a href=\"#JOIN查询\" class=\"headerlink\" title=\"JOIN查询\"></a>JOIN查询</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">join_table:</div><div class=\"line\"></div><div class=\"line\">   table_reference JOIN table_factor [join_condition]</div><div class=\"line\">   | table_reference &#123;LEFT|RIGHT|FULL&#125; [OUTER] JOIN table_reference</div><div class=\"line\">   join_condition</div><div class=\"line\">   | table_reference LEFT SEMI JOIN table_reference join_condition</div><div class=\"line\">   | table_reference CROSS JOIN table_reference [join_condition]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hive简单介绍\"><a href=\"#Hive简单介绍\" class=\"headerlink\" title=\"Hive简单介绍\"></a>Hive简单介绍</h1><p>　　Hive是一种以SQL风格进行任何大小数据分析的工具，其特点是通过 SQL处理Hadoop的大数据，数据规模可以伸缩扩展到100PB+，数据形式可以是结构或非结构数据。</p>\n<h1 id=\"Hive与传统关系数据库比较\"><a href=\"#Hive与传统关系数据库比较\" class=\"headerlink\" title=\"Hive与传统关系数据库比较\"></a>Hive与传统关系数据库比较</h1><ul>\n<li>侧重于分析，而非实时在线交易</li>\n<li>无事务机制</li>\n<li>不像关系数据库那样可以随机进行 insert或update.</li>\n<li>通过Hadoop的map/reduce进行分布式处理，传统数据库则没有</li>\n<li>传统关系数据库只能拓展最多20个服务器，而Hive可以拓展到上百个服务器。</li>\n</ul>\n<h1 id=\"安装Hive\"><a href=\"#安装Hive\" class=\"headerlink\" title=\"安装Hive\"></a>安装Hive</h1><ol>\n<li>首先我们需要安装Java环境和Hadoop环境</li>\n<li>从这里<a href=\"http://mirrors.shuosc.org/apache/hive/获取Hive安装包\" target=\"_blank\" rel=\"external\">http://mirrors.shuosc.org/apache/hive/获取Hive安装包</a></li>\n<li><p>解压安装包到安装目录下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tar -xzvf apache-hive-2.2.0-bin.tar.gz</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">export HIVE_HOME=&#123;&#123;/user/local/hive-2.2.0&#125;&#125;</div><div class=\"line\">export PATH=$HIVE_HOME/bin:$PATH</div></pre></td></tr></table></figure>\n</li>\n<li><p>配置hive-env.sh文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">HADOOP_HOME=/user/local/hadoop-2.8.1</div><div class=\"line\">export HIVE_CONF_DIR=/user/local/hive-2.2.0/conf</div></pre></td></tr></table></figure>\n</li>\n<li><p>在HDFS文件系统上创建数据仓库目录并赋予权限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hdfs dfs -mkdir       /tmp</div><div class=\"line\">$ hdfs dfs -mkdir       /user/hive/warehouse</div><div class=\"line\">$ hdfs dfs -chmod g+w   /tmp</div><div class=\"line\">$ hdfs dfs -chmod g+w   /user/hive/warehouse</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用配置启动Hive，需要初始化Hive的metastore数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bin/schematool -initSchema -dbType derby #我在这里折腾了很久....</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果报这个错误的话（message:Version information not found in metastore. ），需要修改下面这个配置项</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;property&gt;</div><div class=\"line\">    &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</div><div class=\"line\">    &lt;value&gt;true&lt;/value&gt;  #这里把true修改成false</div><div class=\"line\">&lt;/property&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>到这一步就可以使用命令启动Hive了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bin/hive</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"Hive数据类型\"><a href=\"#Hive数据类型\" class=\"headerlink\" title=\"Hive数据类型\"></a>Hive数据类型</h1><p>|数据类型|所占字节|开始支持版本|<br>|TINYINT|1byte，-128 ~ 127||<br>|SMALLINT|2byte，-32,768 ~ 32,767||<br>|INT|4byte,-2,147,483,648 ~ 2,147,483,647||<br>|BIGINT|8byte,-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807||<br>|BOOLEAN|||<br>|FLOAT|4byte单精度||<br>|DOUBLE|8byte双精度||<br>|STRING|||<br>|BINARY||从Hive0.8.0开始支持|<br>|TIMESTAMP||从Hive0.8.0开始支持|<br>|DECIMAL||从Hive0.11.0开始支持|<br>|CHAR||从Hive0.13.0开始支持|<br>|VARCHAR||从Hive0.12.0开始支持|<br>|DATE||从Hive0.12.0开始支持|</p>\n<h1 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h1><h2 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE (DATABASE|SCHEMA) [IF NOT EXISTS] database_name</div><div class=\"line\">  [COMMENT database_comment]</div><div class=\"line\">  [LOCATION hdfs_path]</div><div class=\"line\">  [WITH DBPROPERTIES (property_name=property_value, ...)];</div></pre></td></tr></table></figure>\n<h2 id=\"删除数据库\"><a href=\"#删除数据库\" class=\"headerlink\" title=\"删除数据库\"></a>删除数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">DROP (DATABASE|SCHEMA) [IF EXISTS] database_name [RESTRICT|CASCADE];</div></pre></td></tr></table></figure>\n<h2 id=\"修改数据库\"><a href=\"#修改数据库\" class=\"headerlink\" title=\"修改数据库\"></a>修改数据库</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALTER (DATABASE|SCHEMA) database_name SET DBPROPERTIES (property_name=property_value, ...);   -- (Note: SCHEMA added in Hive 0.14.0)</div><div class=\"line\"> </div><div class=\"line\">ALTER (DATABASE|SCHEMA) database_name SET OWNER [USER|ROLE] user_or_role;   -- (Note: Hive 0.13.0 and later; SCHEMA added in Hive 0.14.0)</div><div class=\"line\"> </div><div class=\"line\">ALTER (DATABASE|SCHEMA) database_name SET LOCATION hdfs_path; -- (Note: Hive 2.2.1, 2.4.0 and later)</div></pre></td></tr></table></figure>\n<h1 id=\"数据库表操作\"><a href=\"#数据库表操作\" class=\"headerlink\" title=\"数据库表操作\"></a>数据库表操作</h1><h2 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive 0.14.0 and later)</div><div class=\"line\">  [(col_name data_type [COMMENT col_comment], ... [constraint_specification])]</div><div class=\"line\">  [COMMENT table_comment]</div><div class=\"line\">  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]</div><div class=\"line\">  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</div><div class=\"line\">  [SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive 0.10.0 and later)]</div><div class=\"line\">     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)</div><div class=\"line\">     [STORED AS DIRECTORIES]</div><div class=\"line\">  [</div><div class=\"line\">   [ROW FORMAT row_format] #指定行分隔符</div><div class=\"line\">***[FIELDS TERMINATED BY ] #指定字段间的分隔符</div><div class=\"line\">   [STORED AS file_format]   </div><div class=\"line\">     | STORED BY &apos;storage.handler.class.name&apos; [WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive 0.6.0 and later)</div><div class=\"line\">  ]</div><div class=\"line\">  [LOCATION hdfs_path]</div><div class=\"line\">  [TBLPROPERTIES (property_name=property_value, ...)]   -- (Note: Available in Hive 0.6.0 and later)</div><div class=\"line\">  [AS select_statement];   -- (Note: Available in Hive 0.5.0 and later; not supported for external tables)</div><div class=\"line\"></div><div class=\"line\">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name</div><div class=\"line\">  LIKE existing_table_or_view_name</div><div class=\"line\">  [LOCATION hdfs_path];</div></pre></td></tr></table></figure>\n<h1 id=\"添加分区表\"><a href=\"#添加分区表\" class=\"headerlink\" title=\"添加分区表\"></a>添加分区表</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALTER TABLE table_name ADD [IF NOT EXISTS] PARTITION partition_spec</div><div class=\"line\">[LOCATION &apos;location1&apos;] partition_spec [LOCATION &apos;location2&apos;] ...;</div><div class=\"line\"></div><div class=\"line\">partition_spec:</div><div class=\"line\">: (p_column = p_col_value, p_column = p_col_value, ...)</div></pre></td></tr></table></figure>\n<p>把数据一定规则划分（例如：把收集的日志按天存放），把数据按天存储在一个单独的文件，可以减少了查询处理时间。</p>\n<h2 id=\"加载数据到表中\"><a href=\"#加载数据到表中\" class=\"headerlink\" title=\"加载数据到表中\"></a>加载数据到表中</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">LOAD DATA [LOCAL] INPATH &apos;filepath&apos; [OVERWRITE] INTO TABLE tablename </div><div class=\"line\">[PARTITION (partcol1=val1, partcol2=val2 ...)]</div></pre></td></tr></table></figure>\n<h1 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h1><h2 id=\"基本查询语句\"><a href=\"#基本查询语句\" class=\"headerlink\" title=\"基本查询语句\"></a>基本查询语句</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT [ALL | DISTINCT] select_expr, select_expr, ... </div><div class=\"line\">FROM table_reference </div><div class=\"line\">[WHERE where_condition] </div><div class=\"line\">[GROUP BY col_list] </div><div class=\"line\">[HAVING having_condition] </div><div class=\"line\">[CLUSTER BY col_list |                   #col_list相同时，CLUSTER BY相当于是DISTRIBUTE BY和SORT BY的组合</div><div class=\"line\"> [DISTRIBUTE BY col_list]                #控制map的输出在reducer是如何划分的（默认是通过hash的方式划分）</div><div class=\"line\"> [SORT BY col_list]]                     #每个reducer端都会做排序</div><div class=\"line\">[LIMIT number];</div></pre></td></tr></table></figure>\n<h2 id=\"JOIN查询\"><a href=\"#JOIN查询\" class=\"headerlink\" title=\"JOIN查询\"></a>JOIN查询</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">join_table:</div><div class=\"line\"></div><div class=\"line\">   table_reference JOIN table_factor [join_condition]</div><div class=\"line\">   | table_reference &#123;LEFT|RIGHT|FULL&#125; [OUTER] JOIN table_reference</div><div class=\"line\">   join_condition</div><div class=\"line\">   | table_reference LEFT SEMI JOIN table_reference join_condition</div><div class=\"line\">   | table_reference CROSS JOIN table_reference [join_condition]</div></pre></td></tr></table></figure>\n"},{"title":"JavaScript继承方式","date":"2013-06-20T03:43:05.000Z","_content":"# JavaScript对象概念\nJavaScript的所有数据都可以看作对象，在ECMAScript中，对象是一个无序属性集，这里的“属性”可以是基本值、对象或者函数。JavaScript的面相对象编程和Java、c#的面向对象编程不太一样。在java、c#中面向对象的概念是：\n1.类：类是同一类实物的抽象，例如定义一个Person代表人类，类是一种类型，它不代表某个具体的人。\n2.实例：实例是根据类创建的对象，例如，根据Person类可以创建出xiaoming、xiaojun等多个实例，每个实例表示一个具体的人，他们全都属于Person类型。\n不过，在JavaScript中是不区分类和实例的概念，而是通过原形（prototype）来实现面向对象。原型是指创建的具体的人，而并没有Person类型可用。\n```js\nvar Person = {\n    name: 'xiao',\n    height: 1.7,\n    run: function () {\n        console.log(this.name + ' is running');\n    }\n};\n```\n上面的Person对象有名字、身高，人也有这两个属性，于是我们就用它来创建一个具体的人小李：\n```js\nvar xiaoli = {\n    name: XiaoLi'\n};\nxiaoli.__proto__ = Person;\n```\n把person这个对象赋值给__proto__属性，这样xiaoli就继承了run这个方法了。但是，在实际编写JavaScript代码时是不可以直接给__proto__属性赋值的，需要其他方式实现继承。\n\n# 原型链继承\n这是实现继承最简单的方式了\n\n## 实现方式：\n```js\nfunction Animal(name){\n\t//属性\n\tthis.name = name || \"animal\";\n\tthis.features = [];\n\t//实例方法\n\tthis.sleep = function(){\n\t\tconsole.log(this.name + 'is sleeping!');\n\t}\n}\nAnimal.prototype.eat = function(){\n\tconsole.log(this.name + \"is eating milk!\");\n}\n\nfunction Cat(){\n}\nCat.prototype = New Animal();\n\nvar blackCat = new Cat();\nvar whiteCat = new Cat();\n\nblackCat.name = 'Black Cat';\nblackCat.features.push('eat');\n\n//针对父类实例值类型成员的更改，不影响\nconsole.log(blackCat.name); // \"Black Cat\"\nconsole.log(whiteCat.name); // \"animal\"\n//针对父类实例引用类型成员的更改，会通过影响其他子类实例\nconsole.log(blackCat.features); // ['eat']\nconsole.log(whiteCat.features); // ['eat']\n```\n\n## 特点\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例\n2. 父类新增原型方法/原型属性，子类都能访问到\n3. 简单，易于实现\n\n## 缺点\n1. 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中\n2. 无法实现多继承\n3. 来自原型对象的引用属性是所有实例共享的\n> blackCat.features.push，首先找tom对象的实例属性（找不到），\n> 那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的\n> features属性中插入值。\n> 在console.log(whiteCat.features); 的时候。whiteCat实例上也没有，那么去原型上找。\n> 原型上有就直接返回，但是这个原型对象中features属性值已经变化了。\n4. 创建子类实例时，无法向父类构造函数传参\n\n# 借用构造函数\n原型链的范式确实简单，可是存在2个致命缺点，所以就出现了借用构造函数方式\n\n## 实现方式：\n```js\nfunction Cat(name){\n\tAnimal.call(this,name);\n}\n\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n## 特点\n1. 解决了子类实例共享父类引用属性的问题\n2. 创建子类实例时，可以向父类传递参数\n3. 可以实现多继承（call多个父类对象）\n\n## 确定\n1. 实例并不是父类的实例，只是子类的实例\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n# 组合继承\n通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n## 实现方式：\n```js\nfunction Cat(name){\n  Animal.call(this,name);\n}\nCat.prototype = new Animal();\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n## 特点\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n2. 既是子类的实例，也是父类的实例\n3. 不存在引用属性共享问题\n4. 可传参\n5. 函数可复用\n\n## 缺点\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了），浪费了点内存\n\n# 寄生组合继承\n通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n## 实现方式：\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\n```\n\n## 特点\n1. 前面的缺点都没了\n\n## 缺点\n1. 实现较为复杂","source":"_posts/JavaScript继承方式.md","raw":"---\ntitle: JavaScript继承方式\ndate: 2013-06-20 11:43:05\ncategories:\n   前端\ntags: \n  - JavaScript\n---\n# JavaScript对象概念\nJavaScript的所有数据都可以看作对象，在ECMAScript中，对象是一个无序属性集，这里的“属性”可以是基本值、对象或者函数。JavaScript的面相对象编程和Java、c#的面向对象编程不太一样。在java、c#中面向对象的概念是：\n1.类：类是同一类实物的抽象，例如定义一个Person代表人类，类是一种类型，它不代表某个具体的人。\n2.实例：实例是根据类创建的对象，例如，根据Person类可以创建出xiaoming、xiaojun等多个实例，每个实例表示一个具体的人，他们全都属于Person类型。\n不过，在JavaScript中是不区分类和实例的概念，而是通过原形（prototype）来实现面向对象。原型是指创建的具体的人，而并没有Person类型可用。\n```js\nvar Person = {\n    name: 'xiao',\n    height: 1.7,\n    run: function () {\n        console.log(this.name + ' is running');\n    }\n};\n```\n上面的Person对象有名字、身高，人也有这两个属性，于是我们就用它来创建一个具体的人小李：\n```js\nvar xiaoli = {\n    name: XiaoLi'\n};\nxiaoli.__proto__ = Person;\n```\n把person这个对象赋值给__proto__属性，这样xiaoli就继承了run这个方法了。但是，在实际编写JavaScript代码时是不可以直接给__proto__属性赋值的，需要其他方式实现继承。\n\n# 原型链继承\n这是实现继承最简单的方式了\n\n## 实现方式：\n```js\nfunction Animal(name){\n\t//属性\n\tthis.name = name || \"animal\";\n\tthis.features = [];\n\t//实例方法\n\tthis.sleep = function(){\n\t\tconsole.log(this.name + 'is sleeping!');\n\t}\n}\nAnimal.prototype.eat = function(){\n\tconsole.log(this.name + \"is eating milk!\");\n}\n\nfunction Cat(){\n}\nCat.prototype = New Animal();\n\nvar blackCat = new Cat();\nvar whiteCat = new Cat();\n\nblackCat.name = 'Black Cat';\nblackCat.features.push('eat');\n\n//针对父类实例值类型成员的更改，不影响\nconsole.log(blackCat.name); // \"Black Cat\"\nconsole.log(whiteCat.name); // \"animal\"\n//针对父类实例引用类型成员的更改，会通过影响其他子类实例\nconsole.log(blackCat.features); // ['eat']\nconsole.log(whiteCat.features); // ['eat']\n```\n\n## 特点\n1. 非常纯粹的继承关系，实例是子类的实例，也是父类的实例\n2. 父类新增原型方法/原型属性，子类都能访问到\n3. 简单，易于实现\n\n## 缺点\n1. 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中\n2. 无法实现多继承\n3. 来自原型对象的引用属性是所有实例共享的\n> blackCat.features.push，首先找tom对象的实例属性（找不到），\n> 那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的\n> features属性中插入值。\n> 在console.log(whiteCat.features); 的时候。whiteCat实例上也没有，那么去原型上找。\n> 原型上有就直接返回，但是这个原型对象中features属性值已经变化了。\n4. 创建子类实例时，无法向父类构造函数传参\n\n# 借用构造函数\n原型链的范式确实简单，可是存在2个致命缺点，所以就出现了借用构造函数方式\n\n## 实现方式：\n```js\nfunction Cat(name){\n\tAnimal.call(this,name);\n}\n\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // false\nconsole.log(cat instanceof Cat); // true\n```\n\n## 特点\n1. 解决了子类实例共享父类引用属性的问题\n2. 创建子类实例时，可以向父类传递参数\n3. 可以实现多继承（call多个父类对象）\n\n## 确定\n1. 实例并不是父类的实例，只是子类的实例\n2. 只能继承父类的实例属性和方法，不能继承原型属性/方法\n3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能\n\n# 组合继承\n通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用\n\n## 实现方式：\n```js\nfunction Cat(name){\n  Animal.call(this,name);\n}\nCat.prototype = new Animal();\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); // true\n```\n\n## 特点\n1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法\n2. 既是子类的实例，也是父类的实例\n3. 不存在引用属性共享问题\n4. 可传参\n5. 函数可复用\n\n## 缺点\n1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了），浪费了点内存\n\n# 寄生组合继承\n通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点\n\n## 实现方式：\n```js\nfunction Cat(name){\n  Animal.call(this);\n  this.name = name || 'Tom';\n}\n(function(){\n  // 创建一个没有实例方法的类\n  var Super = function(){};\n  Super.prototype = Animal.prototype;\n  //将实例作为子类的原型\n  Cat.prototype = new Super();\n})();\n\n// Test Code\nvar cat = new Cat();\nconsole.log(cat.name);\nconsole.log(cat.sleep());\nconsole.log(cat instanceof Animal); // true\nconsole.log(cat instanceof Cat); //true\n```\n\n## 特点\n1. 前面的缺点都没了\n\n## 缺点\n1. 实现较为复杂","slug":"JavaScript继承方式","published":1,"updated":"2017-09-08T10:19:12.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja38x000d44eikzziqfln","content":"<h1 id=\"JavaScript对象概念\"><a href=\"#JavaScript对象概念\" class=\"headerlink\" title=\"JavaScript对象概念\"></a>JavaScript对象概念</h1><p>JavaScript的所有数据都可以看作对象，在ECMAScript中，对象是一个无序属性集，这里的“属性”可以是基本值、对象或者函数。JavaScript的面相对象编程和Java、c#的面向对象编程不太一样。在java、c#中面向对象的概念是：<br>1.类：类是同一类实物的抽象，例如定义一个Person代表人类，类是一种类型，它不代表某个具体的人。<br>2.实例：实例是根据类创建的对象，例如，根据Person类可以创建出xiaoming、xiaojun等多个实例，每个实例表示一个具体的人，他们全都属于Person类型。<br>不过，在JavaScript中是不区分类和实例的概念，而是通过原形（prototype）来实现面向对象。原型是指创建的具体的人，而并没有Person类型可用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Person = &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">'xiao'</span>,</div><div class=\"line\">    <span class=\"attr\">height</span>: <span class=\"number\">1.7</span>,</div><div class=\"line\">    <span class=\"attr\">run</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is running'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>上面的Person对象有名字、身高，人也有这两个属性，于是我们就用它来创建一个具体的人小李：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var xiaoli = &#123;</div><div class=\"line\">    name: XiaoLi'</div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoli.__proto__ = Person;</div></pre></td></tr></table></figure></p>\n<p>把person这个对象赋值给<strong>proto</strong>属性，这样xiaoli就继承了run这个方法了。但是，在实际编写JavaScript代码时是不可以直接给<strong>proto</strong>属性赋值的，需要其他方式实现继承。</p>\n<h1 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h1><p>这是实现继承最简单的方式了</p>\n<h2 id=\"实现方式：\"><a href=\"#实现方式：\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//属性</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"animal\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.features = [];</div><div class=\"line\">\t<span class=\"comment\">//实例方法</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'is sleeping!'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"is eating milk!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Cat.prototype = New Animal();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> blackCat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"keyword\">var</span> whiteCat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"></div><div class=\"line\">blackCat.name = <span class=\"string\">'Black Cat'</span>;</div><div class=\"line\">blackCat.features.push(<span class=\"string\">'eat'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//针对父类实例值类型成员的更改，不影响</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(blackCat.name); <span class=\"comment\">// \"Black Cat\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(whiteCat.name); <span class=\"comment\">// \"animal\"</span></div><div class=\"line\"><span class=\"comment\">//针对父类实例引用类型成员的更改，会通过影响其他子类实例</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(blackCat.features); <span class=\"comment\">// ['eat']</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(whiteCat.features); <span class=\"comment\">// ['eat']</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>\n<li>父类新增原型方法/原型属性，子类都能访问到</li>\n<li>简单，易于实现</li>\n</ol>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中</li>\n<li>无法实现多继承</li>\n<li>来自原型对象的引用属性是所有实例共享的<blockquote>\n<p>blackCat.features.push，首先找tom对象的实例属性（找不到），<br>那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的<br>features属性中插入值。<br>在console.log(whiteCat.features); 的时候。whiteCat实例上也没有，那么去原型上找。<br>原型上有就直接返回，但是这个原型对象中features属性值已经变化了。</p>\n</blockquote>\n</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n</ol>\n<h1 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h1><p>原型链的范式确实简单，可是存在2个致命缺点，所以就出现了借用构造函数方式</p>\n<h2 id=\"实现方式：-1\"><a href=\"#实现方式：-1\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>,name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>解决了子类实例共享父类引用属性的问题</li>\n<li>创建子类实例时，可以向父类传递参数</li>\n<li>可以实现多继承（call多个父类对象）</li>\n</ol>\n<h2 id=\"确定\"><a href=\"#确定\" class=\"headerlink\" title=\"确定\"></a>确定</h2><ol>\n<li>实例并不是父类的实例，只是子类的实例</li>\n<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>\n<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ol>\n<h1 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h1><p>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<h2 id=\"实现方式：-2\"><a href=\"#实现方式：-2\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Animal.call(<span class=\"keyword\">this</span>,name);</div><div class=\"line\">&#125;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Test Code</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>\n<li>既是子类的实例，也是父类的实例</li>\n<li>不存在引用属性共享问题</li>\n<li>可传参</li>\n<li>函数可复用</li>\n</ol>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了），浪费了点内存</li>\n</ol>\n<h1 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h1><p>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<h2 id=\"实现方式：-3\"><a href=\"#实现方式：-3\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></div><div class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">  Super.prototype = Animal.prototype;</div><div class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></div><div class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Test Code</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>前面的缺点都没了</li>\n</ol>\n<h2 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>实现较为复杂</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript对象概念\"><a href=\"#JavaScript对象概念\" class=\"headerlink\" title=\"JavaScript对象概念\"></a>JavaScript对象概念</h1><p>JavaScript的所有数据都可以看作对象，在ECMAScript中，对象是一个无序属性集，这里的“属性”可以是基本值、对象或者函数。JavaScript的面相对象编程和Java、c#的面向对象编程不太一样。在java、c#中面向对象的概念是：<br>1.类：类是同一类实物的抽象，例如定义一个Person代表人类，类是一种类型，它不代表某个具体的人。<br>2.实例：实例是根据类创建的对象，例如，根据Person类可以创建出xiaoming、xiaojun等多个实例，每个实例表示一个具体的人，他们全都属于Person类型。<br>不过，在JavaScript中是不区分类和实例的概念，而是通过原形（prototype）来实现面向对象。原型是指创建的具体的人，而并没有Person类型可用。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Person = &#123;</div><div class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">'xiao'</span>,</div><div class=\"line\">    <span class=\"attr\">height</span>: <span class=\"number\">1.7</span>,</div><div class=\"line\">    <span class=\"attr\">run</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' is running'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>上面的Person对象有名字、身高，人也有这两个属性，于是我们就用它来创建一个具体的人小李：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var xiaoli = &#123;</div><div class=\"line\">    name: XiaoLi'</div><div class=\"line\">&#125;;</div><div class=\"line\">xiaoli.__proto__ = Person;</div></pre></td></tr></table></figure></p>\n<p>把person这个对象赋值给<strong>proto</strong>属性，这样xiaoli就继承了run这个方法了。但是，在实际编写JavaScript代码时是不可以直接给<strong>proto</strong>属性赋值的，需要其他方式实现继承。</p>\n<h1 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h1><p>这是实现继承最简单的方式了</p>\n<h2 id=\"实现方式：\"><a href=\"#实现方式：\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\t<span class=\"comment\">//属性</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.name = name || <span class=\"string\">\"animal\"</span>;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.features = [];</div><div class=\"line\">\t<span class=\"comment\">//实例方法</span></div><div class=\"line\">\t<span class=\"keyword\">this</span>.sleep = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">'is sleeping!'</span>);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Animal.prototype.eat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">\"is eating milk!\"</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">&#125;</div><div class=\"line\">Cat.prototype = New Animal();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> blackCat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"keyword\">var</span> whiteCat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"></div><div class=\"line\">blackCat.name = <span class=\"string\">'Black Cat'</span>;</div><div class=\"line\">blackCat.features.push(<span class=\"string\">'eat'</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//针对父类实例值类型成员的更改，不影响</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(blackCat.name); <span class=\"comment\">// \"Black Cat\"</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(whiteCat.name); <span class=\"comment\">// \"animal\"</span></div><div class=\"line\"><span class=\"comment\">//针对父类实例引用类型成员的更改，会通过影响其他子类实例</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(blackCat.features); <span class=\"comment\">// ['eat']</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(whiteCat.features); <span class=\"comment\">// ['eat']</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li>\n<li>父类新增原型方法/原型属性，子类都能访问到</li>\n<li>简单，易于实现</li>\n</ol>\n<h2 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中</li>\n<li>无法实现多继承</li>\n<li>来自原型对象的引用属性是所有实例共享的<blockquote>\n<p>blackCat.features.push，首先找tom对象的实例属性（找不到），<br>那么去原型对象中找，也就是Animal的实例。发现有，那么就直接在这个对象的<br>features属性中插入值。<br>在console.log(whiteCat.features); 的时候。whiteCat实例上也没有，那么去原型上找。<br>原型上有就直接返回，但是这个原型对象中features属性值已经变化了。</p>\n</blockquote>\n</li>\n<li>创建子类实例时，无法向父类构造函数传参</li>\n</ol>\n<h1 id=\"借用构造函数\"><a href=\"#借用构造函数\" class=\"headerlink\" title=\"借用构造函数\"></a>借用构造函数</h1><p>原型链的范式确实简单，可是存在2个致命缺点，所以就出现了借用构造函数方式</p>\n<h2 id=\"实现方式：-1\"><a href=\"#实现方式：-1\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">\tAnimal.call(<span class=\"keyword\">this</span>,name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// false</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点-1\"><a href=\"#特点-1\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>解决了子类实例共享父类引用属性的问题</li>\n<li>创建子类实例时，可以向父类传递参数</li>\n<li>可以实现多继承（call多个父类对象）</li>\n</ol>\n<h2 id=\"确定\"><a href=\"#确定\" class=\"headerlink\" title=\"确定\"></a>确定</h2><ol>\n<li>实例并不是父类的实例，只是子类的实例</li>\n<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>\n<li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li>\n</ol>\n<h1 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h1><p>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>\n<h2 id=\"实现方式：-2\"><a href=\"#实现方式：-2\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Animal.call(<span class=\"keyword\">this</span>,name);</div><div class=\"line\">&#125;</div><div class=\"line\">Cat.prototype = <span class=\"keyword\">new</span> Animal();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Test Code</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点-2\"><a href=\"#特点-2\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li>\n<li>既是子类的实例，也是父类的实例</li>\n<li>不存在引用属性共享问题</li>\n<li>可传参</li>\n<li>函数可复用</li>\n</ol>\n<h2 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了），浪费了点内存</li>\n</ol>\n<h1 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h1><p>通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p>\n<h2 id=\"实现方式：-3\"><a href=\"#实现方式：-3\" class=\"headerlink\" title=\"实现方式：\"></a>实现方式：</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Cat</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">  Animal.call(<span class=\"keyword\">this</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.name = name || <span class=\"string\">'Tom'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 创建一个没有实例方法的类</span></div><div class=\"line\">  <span class=\"keyword\">var</span> Super = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">  Super.prototype = Animal.prototype;</div><div class=\"line\">  <span class=\"comment\">//将实例作为子类的原型</span></div><div class=\"line\">  Cat.prototype = <span class=\"keyword\">new</span> Super();</div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Test Code</span></div><div class=\"line\"><span class=\"keyword\">var</span> cat = <span class=\"keyword\">new</span> Cat();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.name);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat.sleep());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Animal); <span class=\"comment\">// true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(cat <span class=\"keyword\">instanceof</span> Cat); <span class=\"comment\">//true</span></div></pre></td></tr></table></figure>\n<h2 id=\"特点-3\"><a href=\"#特点-3\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>前面的缺点都没了</li>\n</ol>\n<h2 id=\"缺点-2\"><a href=\"#缺点-2\" class=\"headerlink\" title=\"缺点\"></a>缺点</h2><ol>\n<li>实现较为复杂</li>\n</ol>\n"},{"title":"KMP算法","date":"2017-01-12T07:25:37.000Z","_content":"# 什么是KMP算法\n  KMP算法是其实就是一种字符串匹配算法（字符串中宣召匹配的子串），由D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。\n\n# KMP算法的思想\n  假设现在有字符串A.那么我们需要在A中找到是否包含字符串B，如果存在就返回起始位置。  \n  A:ABCDABCABCDEABCEABDE \n  B:ABCDE\nA串中出现了两次B串：  \nABCDABC<font color=#ff0000>ABCDE</font>ABCEABDE  \n传统方法是，从左到右一个字符一个字符的比较，当遇到不匹配的字符就回到上次开始匹配的下一位继续匹配。  \n下面给出一段暴力搜索的代码：\n```java\npublic class General{\n\n    public static void main(String[] args){\n        String txt = \"ABCDABCABCDEABCEABDE\";\n        String pat = \"ABCDE\";\n        int a = search(pat, txt);\n        if (a == txt.length()){\n            System.out.println(\"Not Found!\");\n        }else{\n            System.out.println(\"Found: \" + a);\n        }\n    }\n\n    private static int search(String pat, String txt){\n        int M = pat.length();\n        int N = txt.length();\n\n        for (int i = 0; i <= N - M; i++){\n            int j;\n            for (j = 0; j < M; j++){\n                if (txt.charAt(i+j) != pat.charAt(j)){\n                    break;\n                }\n            }\n            if (j == M) return i;//Found\n        }\n        return N;//Not Found\n    }\n}\n```\n    ","source":"_posts/KMP算法.md","raw":"---\ntitle: KMP算法\ndate: 2017-01-12 15:25:37\ncategories:\n  算法 \ntags:\n  - 算法\n---\n# 什么是KMP算法\n  KMP算法是其实就是一种字符串匹配算法（字符串中宣召匹配的子串），由D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。\n\n# KMP算法的思想\n  假设现在有字符串A.那么我们需要在A中找到是否包含字符串B，如果存在就返回起始位置。  \n  A:ABCDABCABCDEABCEABDE \n  B:ABCDE\nA串中出现了两次B串：  \nABCDABC<font color=#ff0000>ABCDE</font>ABCEABDE  \n传统方法是，从左到右一个字符一个字符的比较，当遇到不匹配的字符就回到上次开始匹配的下一位继续匹配。  \n下面给出一段暴力搜索的代码：\n```java\npublic class General{\n\n    public static void main(String[] args){\n        String txt = \"ABCDABCABCDEABCEABDE\";\n        String pat = \"ABCDE\";\n        int a = search(pat, txt);\n        if (a == txt.length()){\n            System.out.println(\"Not Found!\");\n        }else{\n            System.out.println(\"Found: \" + a);\n        }\n    }\n\n    private static int search(String pat, String txt){\n        int M = pat.length();\n        int N = txt.length();\n\n        for (int i = 0; i <= N - M; i++){\n            int j;\n            for (j = 0; j < M; j++){\n                if (txt.charAt(i+j) != pat.charAt(j)){\n                    break;\n                }\n            }\n            if (j == M) return i;//Found\n        }\n        return N;//Not Found\n    }\n}\n```\n    ","slug":"KMP算法","published":1,"updated":"2018-06-08T08:16:56.650Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja390000g44eilw1b506a","content":"<h1 id=\"什么是KMP算法\"><a href=\"#什么是KMP算法\" class=\"headerlink\" title=\"什么是KMP算法\"></a>什么是KMP算法</h1><p>  KMP算法是其实就是一种字符串匹配算法（字符串中宣召匹配的子串），由D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。</p>\n<h1 id=\"KMP算法的思想\"><a href=\"#KMP算法的思想\" class=\"headerlink\" title=\"KMP算法的思想\"></a>KMP算法的思想</h1><p>  假设现在有字符串A.那么我们需要在A中找到是否包含字符串B，如果存在就返回起始位置。<br>  A:ABCDABCABCDEABCEABDE<br>  B:ABCDE<br>A串中出现了两次B串：<br>ABCDABC<font color=\"#ff0000\">ABCDE</font>ABCEABDE<br>传统方法是，从左到右一个字符一个字符的比较，当遇到不匹配的字符就回到上次开始匹配的下一位继续匹配。<br>下面给出一段暴力搜索的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">General</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">        String txt = <span class=\"string\">\"ABCDABCABCDEABCEABDE\"</span>;</div><div class=\"line\">        String pat = <span class=\"string\">\"ABCDE\"</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> a = search(pat, txt);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == txt.length())&#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"Not Found!\"</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"Found: \"</span> + a);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(String pat, String txt)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> M = pat.length();</div><div class=\"line\">        <span class=\"keyword\">int</span> N = txt.length();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N - M; i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> j;</div><div class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; M; j++)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (txt.charAt(i+j) != pat.charAt(j))&#123;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (j == M) <span class=\"keyword\">return</span> i;<span class=\"comment\">//Found</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> N;<span class=\"comment\">//Not Found</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是KMP算法\"><a href=\"#什么是KMP算法\" class=\"headerlink\" title=\"什么是KMP算法\"></a>什么是KMP算法</h1><p>  KMP算法是其实就是一种字符串匹配算法（字符串中宣召匹配的子串），由D.E.Knuth、J.H.Morris和V.R.Pratt同时发现的。</p>\n<h1 id=\"KMP算法的思想\"><a href=\"#KMP算法的思想\" class=\"headerlink\" title=\"KMP算法的思想\"></a>KMP算法的思想</h1><p>  假设现在有字符串A.那么我们需要在A中找到是否包含字符串B，如果存在就返回起始位置。<br>  A:ABCDABCABCDEABCEABDE<br>  B:ABCDE<br>A串中出现了两次B串：<br>ABCDABC<font color=\"#ff0000\">ABCDE</font>ABCEABDE<br>传统方法是，从左到右一个字符一个字符的比较，当遇到不匹配的字符就回到上次开始匹配的下一位继续匹配。<br>下面给出一段暴力搜索的代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">General</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</div><div class=\"line\">        String txt = <span class=\"string\">\"ABCDABCABCDEABCEABDE\"</span>;</div><div class=\"line\">        String pat = <span class=\"string\">\"ABCDE\"</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> a = search(pat, txt);</div><div class=\"line\">        <span class=\"keyword\">if</span> (a == txt.length())&#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"Not Found!\"</span>);</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            System.out.println(<span class=\"string\">\"Found: \"</span> + a);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(String pat, String txt)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> M = pat.length();</div><div class=\"line\">        <span class=\"keyword\">int</span> N = txt.length();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= N - M; i++)&#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> j;</div><div class=\"line\">            <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; M; j++)&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (txt.charAt(i+j) != pat.charAt(j))&#123;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span> (j == M) <span class=\"keyword\">return</span> i;<span class=\"comment\">//Found</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> N;<span class=\"comment\">//Not Found</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"Rides介绍和安装","date":"2013-05-12T09:32:40.000Z","_content":"\n## Redis介绍\nRedis是一个开源，先进的key-value存储，并用于构建高性能，可扩展的Web应用程序的完美解决方案。\n\nRedis从它的许多竞争继承来的三个主要特点：\n\n* Redis数据库完全在内存中，使用磁盘仅用于持久性。\n\n* 相比许多键值数据存储，Redis拥有一套较为丰富的数据类型。\n\n* Redis可以将数据复制到任意数量的从服务器。\n\n## Redis 优势\n  * 异常快速：Redis的速度非常快，每秒能执行约11万集合，每秒约81000+条记录。\n\n  * 支持丰富的数据类型：Redis支持最大多数开发人员已经知道像列表，集合，有序集合，散列数据类型。这使得它非常容易解决各种各样的问题，因为我们知道哪些问题是可以处理通过它的数据类型更好。\n\n  * 操作都是原子性：所有Redis操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值。\n\n  * 多功能实用工具：Redis是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis原生支持发布/订阅)，任何短暂的数据，应用程序，如Web应用程序会话，网页命中计数等。\n\n## Redis安装\n\n### 1.安装必要包\n```sh\nyum install gcc\n```\n\n### 2.下载\n```sh\nwget http://download.redis.io/releases/redis-3.0.0.tar.gz  \ntar zxvf redis-3.0.0.tar.gz  \ncd redis-3.0.0  \n\\#如果不加参数,linux下会报错  \nmake MALLOC=libc\n```\n\n### 3.启动\n```sh\n\\#启动redis  \nsrc/redis-server &  \n\n\\#关闭redis  \nsrc/redis-cli shutdown</span>\n```\n\n### 4.测试  \n```sh\n$ src/redis-cli  \n127.0.0.1:6379> set foo bar  \nOK  \n127.0.0.1:6379> get foo  \n\"bar\"\n```\n  \n### 5.redis中比较重要的工具  \n* redis-server： Redis 服务器程序\n* redis-cli： Redis命令行操作工具，也可以用telnet根据其纯文本协议\n* redis-benchmark：Redis性能测试工具，测试Reids在你的系统及配置下的读写性能","source":"_posts/Redis.md","raw":"---\ntitle: Rides介绍和安装\ndate: 2013-05-12 17:32:40\ncategories:\n  Server \ntags: \n  - Rides\n  - Technology\n  - Server\n---\n\n## Redis介绍\nRedis是一个开源，先进的key-value存储，并用于构建高性能，可扩展的Web应用程序的完美解决方案。\n\nRedis从它的许多竞争继承来的三个主要特点：\n\n* Redis数据库完全在内存中，使用磁盘仅用于持久性。\n\n* 相比许多键值数据存储，Redis拥有一套较为丰富的数据类型。\n\n* Redis可以将数据复制到任意数量的从服务器。\n\n## Redis 优势\n  * 异常快速：Redis的速度非常快，每秒能执行约11万集合，每秒约81000+条记录。\n\n  * 支持丰富的数据类型：Redis支持最大多数开发人员已经知道像列表，集合，有序集合，散列数据类型。这使得它非常容易解决各种各样的问题，因为我们知道哪些问题是可以处理通过它的数据类型更好。\n\n  * 操作都是原子性：所有Redis操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值。\n\n  * 多功能实用工具：Redis是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis原生支持发布/订阅)，任何短暂的数据，应用程序，如Web应用程序会话，网页命中计数等。\n\n## Redis安装\n\n### 1.安装必要包\n```sh\nyum install gcc\n```\n\n### 2.下载\n```sh\nwget http://download.redis.io/releases/redis-3.0.0.tar.gz  \ntar zxvf redis-3.0.0.tar.gz  \ncd redis-3.0.0  \n\\#如果不加参数,linux下会报错  \nmake MALLOC=libc\n```\n\n### 3.启动\n```sh\n\\#启动redis  \nsrc/redis-server &  \n\n\\#关闭redis  \nsrc/redis-cli shutdown</span>\n```\n\n### 4.测试  \n```sh\n$ src/redis-cli  \n127.0.0.1:6379> set foo bar  \nOK  \n127.0.0.1:6379> get foo  \n\"bar\"\n```\n  \n### 5.redis中比较重要的工具  \n* redis-server： Redis 服务器程序\n* redis-cli： Redis命令行操作工具，也可以用telnet根据其纯文本协议\n* redis-benchmark：Redis性能测试工具，测试Reids在你的系统及配置下的读写性能","slug":"Redis","published":1,"updated":"2017-09-08T10:18:51.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja391000j44eiutuyoiqo","content":"<h2 id=\"Redis介绍\"><a href=\"#Redis介绍\" class=\"headerlink\" title=\"Redis介绍\"></a>Redis介绍</h2><p>Redis是一个开源，先进的key-value存储，并用于构建高性能，可扩展的Web应用程序的完美解决方案。</p>\n<p>Redis从它的许多竞争继承来的三个主要特点：</p>\n<ul>\n<li><p>Redis数据库完全在内存中，使用磁盘仅用于持久性。</p>\n</li>\n<li><p>相比许多键值数据存储，Redis拥有一套较为丰富的数据类型。</p>\n</li>\n<li><p>Redis可以将数据复制到任意数量的从服务器。</p>\n</li>\n</ul>\n<h2 id=\"Redis-优势\"><a href=\"#Redis-优势\" class=\"headerlink\" title=\"Redis 优势\"></a>Redis 优势</h2><ul>\n<li><p>异常快速：Redis的速度非常快，每秒能执行约11万集合，每秒约81000+条记录。</p>\n</li>\n<li><p>支持丰富的数据类型：Redis支持最大多数开发人员已经知道像列表，集合，有序集合，散列数据类型。这使得它非常容易解决各种各样的问题，因为我们知道哪些问题是可以处理通过它的数据类型更好。</p>\n</li>\n<li><p>操作都是原子性：所有Redis操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值。</p>\n</li>\n<li><p>多功能实用工具：Redis是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis原生支持发布/订阅)，任何短暂的数据，应用程序，如Web应用程序会话，网页命中计数等。</p>\n</li>\n</ul>\n<h2 id=\"Redis安装\"><a href=\"#Redis安装\" class=\"headerlink\" title=\"Redis安装\"></a>Redis安装</h2><h3 id=\"1-安装必要包\"><a href=\"#1-安装必要包\" class=\"headerlink\" title=\"1.安装必要包\"></a>1.安装必要包</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install gcc</div></pre></td></tr></table></figure>\n<h3 id=\"2-下载\"><a href=\"#2-下载\" class=\"headerlink\" title=\"2.下载\"></a>2.下载</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://download.redis.io/releases/redis-3.0.0.tar.gz  </div><div class=\"line\">tar zxvf redis-3.0.0.tar.gz  </div><div class=\"line\"><span class=\"built_in\">cd</span> redis-3.0.0  </div><div class=\"line\">\\<span class=\"comment\">#如果不加参数,linux下会报错  </span></div><div class=\"line\">make MALLOC=libc</div></pre></td></tr></table></figure>\n<h3 id=\"3-启动\"><a href=\"#3-启动\" class=\"headerlink\" title=\"3.启动\"></a>3.启动</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\<span class=\"comment\">#启动redis  </span></div><div class=\"line\">src/redis-server &amp;  </div><div class=\"line\"></div><div class=\"line\">\\<span class=\"comment\">#关闭redis  </span></div><div class=\"line\">src/redis-cli shutdown&lt;/span&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ src/redis-cli  </div><div class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> foo bar  </div><div class=\"line\">OK  </div><div class=\"line\">127.0.0.1:6379&gt; get foo  </div><div class=\"line\"><span class=\"string\">\"bar\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"5-redis中比较重要的工具\"><a href=\"#5-redis中比较重要的工具\" class=\"headerlink\" title=\"5.redis中比较重要的工具\"></a>5.redis中比较重要的工具</h3><ul>\n<li>redis-server： Redis 服务器程序</li>\n<li>redis-cli： Redis命令行操作工具，也可以用telnet根据其纯文本协议</li>\n<li>redis-benchmark：Redis性能测试工具，测试Reids在你的系统及配置下的读写性能</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Redis介绍\"><a href=\"#Redis介绍\" class=\"headerlink\" title=\"Redis介绍\"></a>Redis介绍</h2><p>Redis是一个开源，先进的key-value存储，并用于构建高性能，可扩展的Web应用程序的完美解决方案。</p>\n<p>Redis从它的许多竞争继承来的三个主要特点：</p>\n<ul>\n<li><p>Redis数据库完全在内存中，使用磁盘仅用于持久性。</p>\n</li>\n<li><p>相比许多键值数据存储，Redis拥有一套较为丰富的数据类型。</p>\n</li>\n<li><p>Redis可以将数据复制到任意数量的从服务器。</p>\n</li>\n</ul>\n<h2 id=\"Redis-优势\"><a href=\"#Redis-优势\" class=\"headerlink\" title=\"Redis 优势\"></a>Redis 优势</h2><ul>\n<li><p>异常快速：Redis的速度非常快，每秒能执行约11万集合，每秒约81000+条记录。</p>\n</li>\n<li><p>支持丰富的数据类型：Redis支持最大多数开发人员已经知道像列表，集合，有序集合，散列数据类型。这使得它非常容易解决各种各样的问题，因为我们知道哪些问题是可以处理通过它的数据类型更好。</p>\n</li>\n<li><p>操作都是原子性：所有Redis操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值。</p>\n</li>\n<li><p>多功能实用工具：Redis是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis原生支持发布/订阅)，任何短暂的数据，应用程序，如Web应用程序会话，网页命中计数等。</p>\n</li>\n</ul>\n<h2 id=\"Redis安装\"><a href=\"#Redis安装\" class=\"headerlink\" title=\"Redis安装\"></a>Redis安装</h2><h3 id=\"1-安装必要包\"><a href=\"#1-安装必要包\" class=\"headerlink\" title=\"1.安装必要包\"></a>1.安装必要包</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install gcc</div></pre></td></tr></table></figure>\n<h3 id=\"2-下载\"><a href=\"#2-下载\" class=\"headerlink\" title=\"2.下载\"></a>2.下载</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://download.redis.io/releases/redis-3.0.0.tar.gz  </div><div class=\"line\">tar zxvf redis-3.0.0.tar.gz  </div><div class=\"line\"><span class=\"built_in\">cd</span> redis-3.0.0  </div><div class=\"line\">\\<span class=\"comment\">#如果不加参数,linux下会报错  </span></div><div class=\"line\">make MALLOC=libc</div></pre></td></tr></table></figure>\n<h3 id=\"3-启动\"><a href=\"#3-启动\" class=\"headerlink\" title=\"3.启动\"></a>3.启动</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\<span class=\"comment\">#启动redis  </span></div><div class=\"line\">src/redis-server &amp;  </div><div class=\"line\"></div><div class=\"line\">\\<span class=\"comment\">#关闭redis  </span></div><div class=\"line\">src/redis-cli shutdown&lt;/span&gt;</div></pre></td></tr></table></figure>\n<h3 id=\"4-测试\"><a href=\"#4-测试\" class=\"headerlink\" title=\"4.测试\"></a>4.测试</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ src/redis-cli  </div><div class=\"line\">127.0.0.1:6379&gt; <span class=\"built_in\">set</span> foo bar  </div><div class=\"line\">OK  </div><div class=\"line\">127.0.0.1:6379&gt; get foo  </div><div class=\"line\"><span class=\"string\">\"bar\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"5-redis中比较重要的工具\"><a href=\"#5-redis中比较重要的工具\" class=\"headerlink\" title=\"5.redis中比较重要的工具\"></a>5.redis中比较重要的工具</h3><ul>\n<li>redis-server： Redis 服务器程序</li>\n<li>redis-cli： Redis命令行操作工具，也可以用telnet根据其纯文本协议</li>\n<li>redis-benchmark：Redis性能测试工具，测试Reids在你的系统及配置下的读写性能</li>\n</ul>\n"},{"title":"Redis的数据结构（一）","date":"2013-05-15T07:04:26.000Z","_content":"\n  Redis是一种面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。它起步较晚，发展迅速，目前已被许多大型机构采用，比如Github、Twitter、Weibo等。Redis并不是简单的key-value存储，实际上他是一个数据结构服务器，支持不同类型的值。也就是说，你不必仅仅把字符串当作键所指向的值。在Redis中一共有5种数据结构，那每种数据结构的使用场景都是什么呢？\n\n- String——字符串\n- Hash——字典\n- List——列表\n- Set——集合\n- Sorted Set——有序集合\n\n# 1. String--字符串\n\nString 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。使用 Strings 类型，可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化（可以选择 RDB 模式或者 AOF 模式），操作日志及 Replication 等功能。\n\n## #SET、GET操作\n```sh\n$ redis-cli set mykey \"my binary safe value\"\nOK\n$ redis-cli get mykey\nmy binary safe value\n```\n> GET和SET用来获取和设置字符串的值，只可以是任何类型的字符串，甚至你都可以在一个键下保存一副jpeg图片。但值的长度不能超过1GB。\n\n## #INCR操作\n```sh\n$ redis-cli set count 100\nOK $ redis-cli incr count\n(integer) 101\n$ redis-cli incr count\n(integer) 102\n$ redis-cli incrby count 10\n(integer) 112\n```\nINCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，类似的命令有INCRBY, DECR and DECRBY。实际上他们在内部就是同一个命令，只是看上去有点儿不同。对字符串，另一个的令人感兴趣的操作是GETSET命令，行如其名：他为key设置新值并且返回原值。这有什么用处呢？例如：你的系统每当有新用户访问时就用INCR命令操作一个Redis key。你希望每小时对这个信息收集一次。你就可以GETSET这个key并给其赋值0并读取原值。除了提供与 Memcached 一样的 get、set、incr、decr 等操作外，Redis 还提供了下面一些操作：\n\n1. LEN niushuai：O(1)获取字符串长度\n2. APPEND niushuai redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）\n3. 设置和获取字符串的某一段内容\n4. 设置及获取字符串的某一位（bit）\n5. 批量设置一系列字符串的内容\n\n# 2. Hash--字典\n\nhash是一个string类型的field和value的映射表.一个key可对应多个field，一个field对应一个value。将一个对象存储为hash类型，较于每个字段都存储成string类型更能节省内存。新建一个hash对象时开始是用zipmap(又称为small hash)来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，Redis会在内部自动将zipmap替换成正常的hash实现.\n\n## #HSET\nHSET key field value\n将哈希表key中的域field的值设为value。如果key不存在，一个新的哈希表被创建并进行hset操作。如果域field已经存在于哈希表中，旧值将被覆盖。\n\n## #HGET\nHGET key field\n返回哈希表key中指定的field的值。\n\n## #HSETNX\nHSETNX key field value\n将哈希表key中的域field的值设置为value，当且仅当域field不存在。若域field已经存在，该操作无效。如果key不存在，一个新哈希表被创建并执行hsetnx命令。\n\n## #HMSET\nHMSET key field value [field value ...]\n同时将多个field - value(域-值)对设置到哈希表key中。此命令会覆盖哈希表中已存在的域。如果key不存在，一个空哈希表被创建并执行hmset操作。\n\n## #HMGET\nHMGET key field [field ...]\n返回哈希表key中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个nil值。因为不存在的key被当作一个空哈希表来处理，所以对一个不存在的key进行hmget操作将返回一个只带有nil值的表。\n\n## #HGETALL\nHGETALL key\n返回哈希表key中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。\n\n## #HDEL\nHDEL key field [field ...]\n删除哈希表key中的一个或多个指定域，不存在的域将被忽略。\n\n## #HLEN\nHLEN key\n返回哈希表key对应的field的数量。\n\n## #HEXISTS\nHEXISTS key field\n查看哈希表key中，给定域field是否存在。\n\n## #HKEYS\nHKEYS key\n获得哈希表中key对应的所有field。\n\n## #HVALS\nHVALS key\n获得哈希表中key对应的所有values。\n\n## #hincrby\n为哈希表key中的域field的值加上增量increment。增量也可以为负数，相当于对给定域进行减法操作。如果key不存在，一个新的哈希表被创建并执行hincrby命令。如果域field不存在，那么在执行命令前，域的值被初始化为0。对一个储存字符串值的域field执行hincrby命令将造成一个错误。本操作的值限制在64位(bit)有符号数字表示之内。\n","source":"_posts/Redis的数据结构.md","raw":"---\ntitle: Redis的数据结构（一）\ndate: 2013-05-15 15:04:26\ncategories:\n  Server \ntags: \n  - Rides\n  - Technology\n  - Server\n---\n\n  Redis是一种面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。它起步较晚，发展迅速，目前已被许多大型机构采用，比如Github、Twitter、Weibo等。Redis并不是简单的key-value存储，实际上他是一个数据结构服务器，支持不同类型的值。也就是说，你不必仅仅把字符串当作键所指向的值。在Redis中一共有5种数据结构，那每种数据结构的使用场景都是什么呢？\n\n- String——字符串\n- Hash——字典\n- List——列表\n- Set——集合\n- Sorted Set——有序集合\n\n# 1. String--字符串\n\nString 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。使用 Strings 类型，可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化（可以选择 RDB 模式或者 AOF 模式），操作日志及 Replication 等功能。\n\n## #SET、GET操作\n```sh\n$ redis-cli set mykey \"my binary safe value\"\nOK\n$ redis-cli get mykey\nmy binary safe value\n```\n> GET和SET用来获取和设置字符串的值，只可以是任何类型的字符串，甚至你都可以在一个键下保存一副jpeg图片。但值的长度不能超过1GB。\n\n## #INCR操作\n```sh\n$ redis-cli set count 100\nOK $ redis-cli incr count\n(integer) 101\n$ redis-cli incr count\n(integer) 102\n$ redis-cli incrby count 10\n(integer) 112\n```\nINCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，类似的命令有INCRBY, DECR and DECRBY。实际上他们在内部就是同一个命令，只是看上去有点儿不同。对字符串，另一个的令人感兴趣的操作是GETSET命令，行如其名：他为key设置新值并且返回原值。这有什么用处呢？例如：你的系统每当有新用户访问时就用INCR命令操作一个Redis key。你希望每小时对这个信息收集一次。你就可以GETSET这个key并给其赋值0并读取原值。除了提供与 Memcached 一样的 get、set、incr、decr 等操作外，Redis 还提供了下面一些操作：\n\n1. LEN niushuai：O(1)获取字符串长度\n2. APPEND niushuai redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）\n3. 设置和获取字符串的某一段内容\n4. 设置及获取字符串的某一位（bit）\n5. 批量设置一系列字符串的内容\n\n# 2. Hash--字典\n\nhash是一个string类型的field和value的映射表.一个key可对应多个field，一个field对应一个value。将一个对象存储为hash类型，较于每个字段都存储成string类型更能节省内存。新建一个hash对象时开始是用zipmap(又称为small hash)来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，Redis会在内部自动将zipmap替换成正常的hash实现.\n\n## #HSET\nHSET key field value\n将哈希表key中的域field的值设为value。如果key不存在，一个新的哈希表被创建并进行hset操作。如果域field已经存在于哈希表中，旧值将被覆盖。\n\n## #HGET\nHGET key field\n返回哈希表key中指定的field的值。\n\n## #HSETNX\nHSETNX key field value\n将哈希表key中的域field的值设置为value，当且仅当域field不存在。若域field已经存在，该操作无效。如果key不存在，一个新哈希表被创建并执行hsetnx命令。\n\n## #HMSET\nHMSET key field value [field value ...]\n同时将多个field - value(域-值)对设置到哈希表key中。此命令会覆盖哈希表中已存在的域。如果key不存在，一个空哈希表被创建并执行hmset操作。\n\n## #HMGET\nHMGET key field [field ...]\n返回哈希表key中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个nil值。因为不存在的key被当作一个空哈希表来处理，所以对一个不存在的key进行hmget操作将返回一个只带有nil值的表。\n\n## #HGETALL\nHGETALL key\n返回哈希表key中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。\n\n## #HDEL\nHDEL key field [field ...]\n删除哈希表key中的一个或多个指定域，不存在的域将被忽略。\n\n## #HLEN\nHLEN key\n返回哈希表key对应的field的数量。\n\n## #HEXISTS\nHEXISTS key field\n查看哈希表key中，给定域field是否存在。\n\n## #HKEYS\nHKEYS key\n获得哈希表中key对应的所有field。\n\n## #HVALS\nHVALS key\n获得哈希表中key对应的所有values。\n\n## #hincrby\n为哈希表key中的域field的值加上增量increment。增量也可以为负数，相当于对给定域进行减法操作。如果key不存在，一个新的哈希表被创建并执行hincrby命令。如果域field不存在，那么在执行命令前，域的值被初始化为0。对一个储存字符串值的域field执行hincrby命令将造成一个错误。本操作的值限制在64位(bit)有符号数字表示之内。\n","slug":"Redis的数据结构","published":1,"updated":"2017-09-08T10:18:36.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja393000n44eisx4nxz9x","content":"<p>  Redis是一种面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。它起步较晚，发展迅速，目前已被许多大型机构采用，比如Github、Twitter、Weibo等。Redis并不是简单的key-value存储，实际上他是一个数据结构服务器，支持不同类型的值。也就是说，你不必仅仅把字符串当作键所指向的值。在Redis中一共有5种数据结构，那每种数据结构的使用场景都是什么呢？</p>\n<ul>\n<li>String——字符串</li>\n<li>Hash——字典</li>\n<li>List——列表</li>\n<li>Set——集合</li>\n<li>Sorted Set——有序集合</li>\n</ul>\n<h1 id=\"1-String–字符串\"><a href=\"#1-String–字符串\" class=\"headerlink\" title=\"1. String–字符串\"></a>1. String–字符串</h1><p>String 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。使用 Strings 类型，可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化（可以选择 RDB 模式或者 AOF 模式），操作日志及 Replication 等功能。</p>\n<h2 id=\"SET、GET操作\"><a href=\"#SET、GET操作\" class=\"headerlink\" title=\"#SET、GET操作\"></a>#SET、GET操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> mykey <span class=\"string\">\"my binary safe value\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli get mykey</div><div class=\"line\">my binary safe value</div></pre></td></tr></table></figure>\n<blockquote>\n<p>GET和SET用来获取和设置字符串的值，只可以是任何类型的字符串，甚至你都可以在一个键下保存一副jpeg图片。但值的长度不能超过1GB。</p>\n</blockquote>\n<h2 id=\"INCR操作\"><a href=\"#INCR操作\" class=\"headerlink\" title=\"#INCR操作\"></a>#INCR操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> count 100</div><div class=\"line\">OK $ redis-cli incr count</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 101</div><div class=\"line\">$ redis-cli incr count</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 102</div><div class=\"line\">$ redis-cli incrby count 10</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 112</div></pre></td></tr></table></figure>\n<p>INCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，类似的命令有INCRBY, DECR and DECRBY。实际上他们在内部就是同一个命令，只是看上去有点儿不同。对字符串，另一个的令人感兴趣的操作是GETSET命令，行如其名：他为key设置新值并且返回原值。这有什么用处呢？例如：你的系统每当有新用户访问时就用INCR命令操作一个Redis key。你希望每小时对这个信息收集一次。你就可以GETSET这个key并给其赋值0并读取原值。除了提供与 Memcached 一样的 get、set、incr、decr 等操作外，Redis 还提供了下面一些操作：</p>\n<ol>\n<li>LEN niushuai：O(1)获取字符串长度</li>\n<li>APPEND niushuai redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）</li>\n<li>设置和获取字符串的某一段内容</li>\n<li>设置及获取字符串的某一位（bit）</li>\n<li>批量设置一系列字符串的内容</li>\n</ol>\n<h1 id=\"2-Hash–字典\"><a href=\"#2-Hash–字典\" class=\"headerlink\" title=\"2. Hash–字典\"></a>2. Hash–字典</h1><p>hash是一个string类型的field和value的映射表.一个key可对应多个field，一个field对应一个value。将一个对象存储为hash类型，较于每个字段都存储成string类型更能节省内存。新建一个hash对象时开始是用zipmap(又称为small hash)来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，Redis会在内部自动将zipmap替换成正常的hash实现.</p>\n<h2 id=\"HSET\"><a href=\"#HSET\" class=\"headerlink\" title=\"#HSET\"></a>#HSET</h2><p>HSET key field value<br>将哈希表key中的域field的值设为value。如果key不存在，一个新的哈希表被创建并进行hset操作。如果域field已经存在于哈希表中，旧值将被覆盖。</p>\n<h2 id=\"HGET\"><a href=\"#HGET\" class=\"headerlink\" title=\"#HGET\"></a>#HGET</h2><p>HGET key field<br>返回哈希表key中指定的field的值。</p>\n<h2 id=\"HSETNX\"><a href=\"#HSETNX\" class=\"headerlink\" title=\"#HSETNX\"></a>#HSETNX</h2><p>HSETNX key field value<br>将哈希表key中的域field的值设置为value，当且仅当域field不存在。若域field已经存在，该操作无效。如果key不存在，一个新哈希表被创建并执行hsetnx命令。</p>\n<h2 id=\"HMSET\"><a href=\"#HMSET\" class=\"headerlink\" title=\"#HMSET\"></a>#HMSET</h2><p>HMSET key field value [field value …]<br>同时将多个field - value(域-值)对设置到哈希表key中。此命令会覆盖哈希表中已存在的域。如果key不存在，一个空哈希表被创建并执行hmset操作。</p>\n<h2 id=\"HMGET\"><a href=\"#HMGET\" class=\"headerlink\" title=\"#HMGET\"></a>#HMGET</h2><p>HMGET key field [field …]<br>返回哈希表key中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个nil值。因为不存在的key被当作一个空哈希表来处理，所以对一个不存在的key进行hmget操作将返回一个只带有nil值的表。</p>\n<h2 id=\"HGETALL\"><a href=\"#HGETALL\" class=\"headerlink\" title=\"#HGETALL\"></a>#HGETALL</h2><p>HGETALL key<br>返回哈希表key中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p>\n<h2 id=\"HDEL\"><a href=\"#HDEL\" class=\"headerlink\" title=\"#HDEL\"></a>#HDEL</h2><p>HDEL key field [field …]<br>删除哈希表key中的一个或多个指定域，不存在的域将被忽略。</p>\n<h2 id=\"HLEN\"><a href=\"#HLEN\" class=\"headerlink\" title=\"#HLEN\"></a>#HLEN</h2><p>HLEN key<br>返回哈希表key对应的field的数量。</p>\n<h2 id=\"HEXISTS\"><a href=\"#HEXISTS\" class=\"headerlink\" title=\"#HEXISTS\"></a>#HEXISTS</h2><p>HEXISTS key field<br>查看哈希表key中，给定域field是否存在。</p>\n<h2 id=\"HKEYS\"><a href=\"#HKEYS\" class=\"headerlink\" title=\"#HKEYS\"></a>#HKEYS</h2><p>HKEYS key<br>获得哈希表中key对应的所有field。</p>\n<h2 id=\"HVALS\"><a href=\"#HVALS\" class=\"headerlink\" title=\"#HVALS\"></a>#HVALS</h2><p>HVALS key<br>获得哈希表中key对应的所有values。</p>\n<h2 id=\"hincrby\"><a href=\"#hincrby\" class=\"headerlink\" title=\"#hincrby\"></a>#hincrby</h2><p>为哈希表key中的域field的值加上增量increment。增量也可以为负数，相当于对给定域进行减法操作。如果key不存在，一个新的哈希表被创建并执行hincrby命令。如果域field不存在，那么在执行命令前，域的值被初始化为0。对一个储存字符串值的域field执行hincrby命令将造成一个错误。本操作的值限制在64位(bit)有符号数字表示之内。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>  Redis是一种面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。它起步较晚，发展迅速，目前已被许多大型机构采用，比如Github、Twitter、Weibo等。Redis并不是简单的key-value存储，实际上他是一个数据结构服务器，支持不同类型的值。也就是说，你不必仅仅把字符串当作键所指向的值。在Redis中一共有5种数据结构，那每种数据结构的使用场景都是什么呢？</p>\n<ul>\n<li>String——字符串</li>\n<li>Hash——字典</li>\n<li>List——列表</li>\n<li>Set——集合</li>\n<li>Sorted Set——有序集合</li>\n</ul>\n<h1 id=\"1-String–字符串\"><a href=\"#1-String–字符串\" class=\"headerlink\" title=\"1. String–字符串\"></a>1. String–字符串</h1><p>String 数据结构是简单的 key-value 类型，value 不仅可以是 String，也可以是数字（当数字类型用 Long 可以表示的时候encoding 就是整型，其他都存储在 sdshdr 当做字符串）。使用 Strings 类型，可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受 Redis 的定时持久化（可以选择 RDB 模式或者 AOF 模式），操作日志及 Replication 等功能。</p>\n<h2 id=\"SET、GET操作\"><a href=\"#SET、GET操作\" class=\"headerlink\" title=\"#SET、GET操作\"></a>#SET、GET操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> mykey <span class=\"string\">\"my binary safe value\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli get mykey</div><div class=\"line\">my binary safe value</div></pre></td></tr></table></figure>\n<blockquote>\n<p>GET和SET用来获取和设置字符串的值，只可以是任何类型的字符串，甚至你都可以在一个键下保存一副jpeg图片。但值的长度不能超过1GB。</p>\n</blockquote>\n<h2 id=\"INCR操作\"><a href=\"#INCR操作\" class=\"headerlink\" title=\"#INCR操作\"></a>#INCR操作</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> count 100</div><div class=\"line\">OK $ redis-cli incr count</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 101</div><div class=\"line\">$ redis-cli incr count</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 102</div><div class=\"line\">$ redis-cli incrby count 10</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 112</div></pre></td></tr></table></figure>\n<p>INCR 命令将字符串值解析成整型，将其加一，最后将结果保存为新的字符串值，类似的命令有INCRBY, DECR and DECRBY。实际上他们在内部就是同一个命令，只是看上去有点儿不同。对字符串，另一个的令人感兴趣的操作是GETSET命令，行如其名：他为key设置新值并且返回原值。这有什么用处呢？例如：你的系统每当有新用户访问时就用INCR命令操作一个Redis key。你希望每小时对这个信息收集一次。你就可以GETSET这个key并给其赋值0并读取原值。除了提供与 Memcached 一样的 get、set、incr、decr 等操作外，Redis 还提供了下面一些操作：</p>\n<ol>\n<li>LEN niushuai：O(1)获取字符串长度</li>\n<li>APPEND niushuai redis：往字符串 append 内容，而且采用智能分配内存（每次2倍）</li>\n<li>设置和获取字符串的某一段内容</li>\n<li>设置及获取字符串的某一位（bit）</li>\n<li>批量设置一系列字符串的内容</li>\n</ol>\n<h1 id=\"2-Hash–字典\"><a href=\"#2-Hash–字典\" class=\"headerlink\" title=\"2. Hash–字典\"></a>2. Hash–字典</h1><p>hash是一个string类型的field和value的映射表.一个key可对应多个field，一个field对应一个value。将一个对象存储为hash类型，较于每个字段都存储成string类型更能节省内存。新建一个hash对象时开始是用zipmap(又称为small hash)来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，Redis会在内部自动将zipmap替换成正常的hash实现.</p>\n<h2 id=\"HSET\"><a href=\"#HSET\" class=\"headerlink\" title=\"#HSET\"></a>#HSET</h2><p>HSET key field value<br>将哈希表key中的域field的值设为value。如果key不存在，一个新的哈希表被创建并进行hset操作。如果域field已经存在于哈希表中，旧值将被覆盖。</p>\n<h2 id=\"HGET\"><a href=\"#HGET\" class=\"headerlink\" title=\"#HGET\"></a>#HGET</h2><p>HGET key field<br>返回哈希表key中指定的field的值。</p>\n<h2 id=\"HSETNX\"><a href=\"#HSETNX\" class=\"headerlink\" title=\"#HSETNX\"></a>#HSETNX</h2><p>HSETNX key field value<br>将哈希表key中的域field的值设置为value，当且仅当域field不存在。若域field已经存在，该操作无效。如果key不存在，一个新哈希表被创建并执行hsetnx命令。</p>\n<h2 id=\"HMSET\"><a href=\"#HMSET\" class=\"headerlink\" title=\"#HMSET\"></a>#HMSET</h2><p>HMSET key field value [field value …]<br>同时将多个field - value(域-值)对设置到哈希表key中。此命令会覆盖哈希表中已存在的域。如果key不存在，一个空哈希表被创建并执行hmset操作。</p>\n<h2 id=\"HMGET\"><a href=\"#HMGET\" class=\"headerlink\" title=\"#HMGET\"></a>#HMGET</h2><p>HMGET key field [field …]<br>返回哈希表key中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个nil值。因为不存在的key被当作一个空哈希表来处理，所以对一个不存在的key进行hmget操作将返回一个只带有nil值的表。</p>\n<h2 id=\"HGETALL\"><a href=\"#HGETALL\" class=\"headerlink\" title=\"#HGETALL\"></a>#HGETALL</h2><p>HGETALL key<br>返回哈希表key中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。</p>\n<h2 id=\"HDEL\"><a href=\"#HDEL\" class=\"headerlink\" title=\"#HDEL\"></a>#HDEL</h2><p>HDEL key field [field …]<br>删除哈希表key中的一个或多个指定域，不存在的域将被忽略。</p>\n<h2 id=\"HLEN\"><a href=\"#HLEN\" class=\"headerlink\" title=\"#HLEN\"></a>#HLEN</h2><p>HLEN key<br>返回哈希表key对应的field的数量。</p>\n<h2 id=\"HEXISTS\"><a href=\"#HEXISTS\" class=\"headerlink\" title=\"#HEXISTS\"></a>#HEXISTS</h2><p>HEXISTS key field<br>查看哈希表key中，给定域field是否存在。</p>\n<h2 id=\"HKEYS\"><a href=\"#HKEYS\" class=\"headerlink\" title=\"#HKEYS\"></a>#HKEYS</h2><p>HKEYS key<br>获得哈希表中key对应的所有field。</p>\n<h2 id=\"HVALS\"><a href=\"#HVALS\" class=\"headerlink\" title=\"#HVALS\"></a>#HVALS</h2><p>HVALS key<br>获得哈希表中key对应的所有values。</p>\n<h2 id=\"hincrby\"><a href=\"#hincrby\" class=\"headerlink\" title=\"#hincrby\"></a>#hincrby</h2><p>为哈希表key中的域field的值加上增量increment。增量也可以为负数，相当于对给定域进行减法操作。如果key不存在，一个新的哈希表被创建并执行hincrby命令。如果域field不存在，那么在执行命令前，域的值被初始化为0。对一个储存字符串值的域field执行hincrby命令将造成一个错误。本操作的值限制在64位(bit)有符号数字表示之内。</p>\n"},{"title":"Redis的数据结构（二）","date":"2013-05-16T01:58:37.000Z","_content":"---\n在上文[Redis的数据结构(一)](http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)中，我们了解了Redis的两种数据类型(String和Hash)，这篇文章我们将继续了解其他几种数据类型。在Redis中总共有5中数据类型：\n- String——字符串\n- Hash——字典\n- List——列表\n- Set——集合\n- Sorted Set——有序集合\n\n# 1. List——列表\n\n一般意义上讲，列表就是有序元素的序列：10,20,1,2,3就是一个列表。但用数组实现的List和用Linked List实现的List，在属性方面大不相同。\nRedis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。\nRedis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。\n\nLPUSH 命令可向list的左边（头部）添加一个新元素，而RPUSH命令可向list的右边（尾部）添加一个新元素。最后LRANGE 命令可从list中取出一定范围的元素\n```sh\n$ redis-cli rpush messages \"Hello\"\nOK\n$ redis-cli rpush messages \"Redis：hello\"\nOK\n$ redis-cli rpush messages \"I'm a NOSQL\"\nOK\n$ redis-cli lrange messages 0 2\n1. Hello\n2. Redis：hello\n3. I'm a NOSQL\n```\n注意LRANGE 带有两个索引，一定范围的第一个和最后一个元素。这两个索引都可以为负来告知Redis从尾部开始计数，因此-1表示最后一个元素，-2表示list中的倒数第二个元素，以此类推。\n正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。\n\n在上面的例子里 ，我们将“对象”（此例中是简单消息）直接压入Redis list，但通常不应这么做，由于对象可能被多次引用：例如在一个list中维护其时间顺序，在一个集合中保存它的类别，只要有必要，它还会出现在其他list中，等等。\n例如我们有一个新闻列表，我们将用户提交的链接（新闻）添加到list中，可以用下面的方法：\n```sh\n$ redis-cli incr next.news.id\n(integer) 1\n$ redis-cli set news:1:title \"Redis的数据结构(一)\"\nOK\n$ redis-cli set news:1:url \"http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\"\nOK\n$ redis-cli lpush submitted.news 1\nOK\n```\n我们自增一个key，很容易得到一个独一无二的自增ID，然后通过此ID创建对象–为对象的每个字段设置一个key。最后将新对象的ID压入submitted.news list。\n在命令参考文档中还可以读到所有和list有关的命令。你可以删除元素，旋转list，根据索引获取和设置元素，当然也可以用LLEN得到list的长度。\n\n# 2. Set--集合\nRedis集合是未排序的集合，其元素是二进制安全的字符串。SADD命令可以向集合添加一个新元素。和sets相关的操作也有许多，比如检测某个元素是否存在，以及实现交集，并集，差集等等。\n```·sh\n$ redis-cli sadd set 1\n(integer) 1\n$ redis-cli sadd set 2\n(integer) 1\n$ redis-cli sadd set 3\n(integer) 1\n$ redis-cli smembers set\n1. 3\n2. 1\n3. 2\n```\n\n# 3. Sorted Set--有序集合\n和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。\n1. 带有权重的元素，比如一个游戏的用户得分排行榜\n2. 比较复杂的数据结构，一般用到的场景不算太多","source":"_posts/Redis的数据结构（二）.md","raw":"---\ntitle: Redis的数据结构（二）\ndate: 2013-05-16 09:58:37\ncategories:\n  Server \ntags: \n  - Rides\n  - Technology\n  - Server\n---\n---\n在上文[Redis的数据结构(一)](http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/)中，我们了解了Redis的两种数据类型(String和Hash)，这篇文章我们将继续了解其他几种数据类型。在Redis中总共有5中数据类型：\n- String——字符串\n- Hash——字典\n- List——列表\n- Set——集合\n- Sorted Set——有序集合\n\n# 1. List——列表\n\n一般意义上讲，列表就是有序元素的序列：10,20,1,2,3就是一个列表。但用数组实现的List和用Linked List实现的List，在属性方面大不相同。\nRedis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。\nRedis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。\n\nLPUSH 命令可向list的左边（头部）添加一个新元素，而RPUSH命令可向list的右边（尾部）添加一个新元素。最后LRANGE 命令可从list中取出一定范围的元素\n```sh\n$ redis-cli rpush messages \"Hello\"\nOK\n$ redis-cli rpush messages \"Redis：hello\"\nOK\n$ redis-cli rpush messages \"I'm a NOSQL\"\nOK\n$ redis-cli lrange messages 0 2\n1. Hello\n2. Redis：hello\n3. I'm a NOSQL\n```\n注意LRANGE 带有两个索引，一定范围的第一个和最后一个元素。这两个索引都可以为负来告知Redis从尾部开始计数，因此-1表示最后一个元素，-2表示list中的倒数第二个元素，以此类推。\n正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。\n\n在上面的例子里 ，我们将“对象”（此例中是简单消息）直接压入Redis list，但通常不应这么做，由于对象可能被多次引用：例如在一个list中维护其时间顺序，在一个集合中保存它的类别，只要有必要，它还会出现在其他list中，等等。\n例如我们有一个新闻列表，我们将用户提交的链接（新闻）添加到list中，可以用下面的方法：\n```sh\n$ redis-cli incr next.news.id\n(integer) 1\n$ redis-cli set news:1:title \"Redis的数据结构(一)\"\nOK\n$ redis-cli set news:1:url \"http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\"\nOK\n$ redis-cli lpush submitted.news 1\nOK\n```\n我们自增一个key，很容易得到一个独一无二的自增ID，然后通过此ID创建对象–为对象的每个字段设置一个key。最后将新对象的ID压入submitted.news list。\n在命令参考文档中还可以读到所有和list有关的命令。你可以删除元素，旋转list，根据索引获取和设置元素，当然也可以用LLEN得到list的长度。\n\n# 2. Set--集合\nRedis集合是未排序的集合，其元素是二进制安全的字符串。SADD命令可以向集合添加一个新元素。和sets相关的操作也有许多，比如检测某个元素是否存在，以及实现交集，并集，差集等等。\n```·sh\n$ redis-cli sadd set 1\n(integer) 1\n$ redis-cli sadd set 2\n(integer) 1\n$ redis-cli sadd set 3\n(integer) 1\n$ redis-cli smembers set\n1. 3\n2. 1\n3. 2\n```\n\n# 3. Sorted Set--有序集合\n和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。\n1. 带有权重的元素，比如一个游戏的用户得分排行榜\n2. 比较复杂的数据结构，一般用到的场景不算太多","slug":"Redis的数据结构（二）","published":1,"updated":"2017-09-08T10:18:46.047Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja396000o44eirrrd5rn0","content":"<hr>\n<p>在上文<a href=\"http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\">Redis的数据结构(一)</a>中，我们了解了Redis的两种数据类型(String和Hash)，这篇文章我们将继续了解其他几种数据类型。在Redis中总共有5中数据类型：</p>\n<ul>\n<li>String——字符串</li>\n<li>Hash——字典</li>\n<li>List——列表</li>\n<li>Set——集合</li>\n<li>Sorted Set——有序集合</li>\n</ul>\n<h1 id=\"1-List——列表\"><a href=\"#1-List——列表\" class=\"headerlink\" title=\"1. List——列表\"></a>1. List——列表</h1><p>一般意义上讲，列表就是有序元素的序列：10,20,1,2,3就是一个列表。但用数组实现的List和用Linked List实现的List，在属性方面大不相同。<br>Redis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。<br>Redis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。</p>\n<p>LPUSH 命令可向list的左边（头部）添加一个新元素，而RPUSH命令可向list的右边（尾部）添加一个新元素。最后LRANGE 命令可从list中取出一定范围的元素<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli rpush messages <span class=\"string\">\"Hello\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli rpush messages <span class=\"string\">\"Redis：hello\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli rpush messages <span class=\"string\">\"I'm a NOSQL\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli lrange messages 0 2</div><div class=\"line\">1. Hello</div><div class=\"line\">2. Redis：hello</div><div class=\"line\">3. I<span class=\"string\">'m a NOSQL</span></div></pre></td></tr></table></figure></p>\n<p>注意LRANGE 带有两个索引，一定范围的第一个和最后一个元素。这两个索引都可以为负来告知Redis从尾部开始计数，因此-1表示最后一个元素，-2表示list中的倒数第二个元素，以此类推。<br>正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。</p>\n<p>在上面的例子里 ，我们将“对象”（此例中是简单消息）直接压入Redis list，但通常不应这么做，由于对象可能被多次引用：例如在一个list中维护其时间顺序，在一个集合中保存它的类别，只要有必要，它还会出现在其他list中，等等。<br>例如我们有一个新闻列表，我们将用户提交的链接（新闻）添加到list中，可以用下面的方法：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli incr next.news.id</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> news:1:title <span class=\"string\">\"Redis的数据结构(一)\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> news:1:url <span class=\"string\">\"http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli lpush submitted.news 1</div><div class=\"line\">OK</div></pre></td></tr></table></figure></p>\n<p>我们自增一个key，很容易得到一个独一无二的自增ID，然后通过此ID创建对象–为对象的每个字段设置一个key。最后将新对象的ID压入submitted.news list。<br>在命令参考文档中还可以读到所有和list有关的命令。你可以删除元素，旋转list，根据索引获取和设置元素，当然也可以用LLEN得到list的长度。</p>\n<h1 id=\"2-Set–集合\"><a href=\"#2-Set–集合\" class=\"headerlink\" title=\"2. Set–集合\"></a>2. Set–集合</h1><p>Redis集合是未排序的集合，其元素是二进制安全的字符串。SADD命令可以向集合添加一个新元素。和sets相关的操作也有许多，比如检测某个元素是否存在，以及实现交集，并集，差集等等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli sadd set 1</div><div class=\"line\">(integer) 1</div><div class=\"line\">$ redis-cli sadd set 2</div><div class=\"line\">(integer) 1</div><div class=\"line\">$ redis-cli sadd set 3</div><div class=\"line\">(integer) 1</div><div class=\"line\">$ redis-cli smembers set</div><div class=\"line\">1. 3</div><div class=\"line\">2. 1</div><div class=\"line\">3. 2</div></pre></td></tr></table></figure></p>\n<h1 id=\"3-Sorted-Set–有序集合\"><a href=\"#3-Sorted-Set–有序集合\" class=\"headerlink\" title=\"3. Sorted Set–有序集合\"></a>3. Sorted Set–有序集合</h1><p>和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</p>\n<ol>\n<li>带有权重的元素，比如一个游戏的用户得分排行榜</li>\n<li>比较复杂的数据结构，一般用到的场景不算太多</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>在上文<a href=\"http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\">Redis的数据结构(一)</a>中，我们了解了Redis的两种数据类型(String和Hash)，这篇文章我们将继续了解其他几种数据类型。在Redis中总共有5中数据类型：</p>\n<ul>\n<li>String——字符串</li>\n<li>Hash——字典</li>\n<li>List——列表</li>\n<li>Set——集合</li>\n<li>Sorted Set——有序集合</li>\n</ul>\n<h1 id=\"1-List——列表\"><a href=\"#1-List——列表\" class=\"headerlink\" title=\"1. List——列表\"></a>1. List——列表</h1><p>一般意义上讲，列表就是有序元素的序列：10,20,1,2,3就是一个列表。但用数组实现的List和用Linked List实现的List，在属性方面大不相同。<br>Redis lists基于Linked Lists实现。这意味着即使在一个list中有数百万个元素，在头部或尾部添加一个元素的操作，其时间复杂度也是常数级别的。用LPUSH命令在十个元素的list头部添加新元素，和在千万元素list头部添加新元素的速度相同。那么，坏消息是什么？在数组实现的list中利用索引访问元素的速度极快，而同样的操作在linked list实现的list上没有那么快。<br>Redis Lists用linked list实现的原因是：对于数据库系统来说，至关重要的特性是：能非常快的在很大的列表上添加元素。另一个重要因素是，正如你将要看到的：Redis lists能在常数时间取得常数长度。</p>\n<p>LPUSH 命令可向list的左边（头部）添加一个新元素，而RPUSH命令可向list的右边（尾部）添加一个新元素。最后LRANGE 命令可从list中取出一定范围的元素<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli rpush messages <span class=\"string\">\"Hello\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli rpush messages <span class=\"string\">\"Redis：hello\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli rpush messages <span class=\"string\">\"I'm a NOSQL\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli lrange messages 0 2</div><div class=\"line\">1. Hello</div><div class=\"line\">2. Redis：hello</div><div class=\"line\">3. I<span class=\"string\">'m a NOSQL</span></div></pre></td></tr></table></figure></p>\n<p>注意LRANGE 带有两个索引，一定范围的第一个和最后一个元素。这两个索引都可以为负来告知Redis从尾部开始计数，因此-1表示最后一个元素，-2表示list中的倒数第二个元素，以此类推。<br>正如你可以从上面的例子中猜到的，list可被用来实现聊天系统。还可以作为不同进程间传递消息的队列。关键是，你可以每次都以原先添加的顺序访问数据。这不需要任何SQL ORDER BY 操作，将会非常快，也会很容易扩展到百万级别元素的规模。</p>\n<p>在上面的例子里 ，我们将“对象”（此例中是简单消息）直接压入Redis list，但通常不应这么做，由于对象可能被多次引用：例如在一个list中维护其时间顺序，在一个集合中保存它的类别，只要有必要，它还会出现在其他list中，等等。<br>例如我们有一个新闻列表，我们将用户提交的链接（新闻）添加到list中，可以用下面的方法：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli incr next.news.id</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> news:1:title <span class=\"string\">\"Redis的数据结构(一)\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli <span class=\"built_in\">set</span> news:1:url <span class=\"string\">\"http://zhkui.com/2017/05/15/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/\"</span></div><div class=\"line\">OK</div><div class=\"line\">$ redis-cli lpush submitted.news 1</div><div class=\"line\">OK</div></pre></td></tr></table></figure></p>\n<p>我们自增一个key，很容易得到一个独一无二的自增ID，然后通过此ID创建对象–为对象的每个字段设置一个key。最后将新对象的ID压入submitted.news list。<br>在命令参考文档中还可以读到所有和list有关的命令。你可以删除元素，旋转list，根据索引获取和设置元素，当然也可以用LLEN得到list的长度。</p>\n<h1 id=\"2-Set–集合\"><a href=\"#2-Set–集合\" class=\"headerlink\" title=\"2. Set–集合\"></a>2. Set–集合</h1><p>Redis集合是未排序的集合，其元素是二进制安全的字符串。SADD命令可以向集合添加一个新元素。和sets相关的操作也有许多，比如检测某个元素是否存在，以及实现交集，并集，差集等等。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ redis-cli sadd set 1</div><div class=\"line\">(integer) 1</div><div class=\"line\">$ redis-cli sadd set 2</div><div class=\"line\">(integer) 1</div><div class=\"line\">$ redis-cli sadd set 3</div><div class=\"line\">(integer) 1</div><div class=\"line\">$ redis-cli smembers set</div><div class=\"line\">1. 3</div><div class=\"line\">2. 1</div><div class=\"line\">3. 2</div></pre></td></tr></table></figure></p>\n<h1 id=\"3-Sorted-Set–有序集合\"><a href=\"#3-Sorted-Set–有序集合\" class=\"headerlink\" title=\"3. Sorted Set–有序集合\"></a>3. Sorted Set–有序集合</h1><p>和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，比如一个存储全班同学成绩的 Sorted Sets，其集合 value 可以是同学的学号，而 score 就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用 Sorted Sets 来做带权重的队列，比如普通消息的 score 为1，重要消息的 score 为2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。</p>\n<ol>\n<li>带有权重的元素，比如一个游戏的用户得分排行榜</li>\n<li>比较复杂的数据结构，一般用到的场景不算太多</li>\n</ol>\n"},{"title":"SpringCloud微服务框架搭建","date":"2016-06-20T07:05:37.000Z","_content":"\n# 一、微服务架构\n## 1.1什么是分布式\n不同模块部署在不同服务器上\n作用：分布式解决网站高并发带来问题\n\n## 1.2什么是集群\n多台服务器部署相同应用构成一个集群\n作用：通过负载均衡设备共同对外提供服务\n\n## 1.3什么是RPC\nRPC 的全称是 Remote Procedure Call 是一种进程间通信方式。\n它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。\n比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决\n\n### 1.3.1restful、soap、rpc\n（1）RESTful是一种架构设计风格，提供了设计原则和约束条件，而不是架构。而满足这些约束条件和原则的应用程序或设计就是 RESTful架构或服务。\n（2）SOAP，简单对象访问协议是一种数据交换协议规范，\n是一种轻量的、简单的、基于XML的协议的规范。SOAP协议和HTTP协议一样，都是底层的通信协议，只是请求包的格式不同而已，SOAP包是XML格式的。\nSOAP的消息是基于xml并封装成了符合http协议，因此，它符合任何路由器、 防火墙或代理服务器的要求。\nsoap可以使用任何语言来完成，只要发送正确的soap请求即可，基于soap的服务可以在任何平台无需修改即可正常使用。\n（3）RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。\nRPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）\nRPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）\nRPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。\n### 1.3.2rpc远程调用框架\n几种比较典型的RPC的实现和调用框架。 \n（1）RMI实现，利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol) \n和java的原生序列化。 \n（2）Hessian，是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。 \n（3）thrift是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。\n（4）SpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。\n\n## 1.4什么是SOA\n业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力\n通过服务的组合和编排来实现上层的业务流程\n作用：简化维护,降低整体风险,伸缩灵活\n\n## 1.5什么是微服务\n架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行\n SOA到微服务架构的演进过程\n 作用：各服务可独立应用，组合服务也可系统应用(巨石应用[monolith]的简化实现策略-平台思想)\n\n## 1.6使用RPC http技术实现会员与订单系统通讯\n\n# 二、SpringCloud\nSpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。\n\n## 2.1、服务提供者与消费关系\n服务提供者:提供服务被人调用\n消费者:调用被人服务\n\n## 2.2、服务的注册与发现(Eureka )\n在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,eureka是一个服务注册和发现模块。\n  1 服务注册\n  2 创建eurekaserver项目\n  3 引入maven依赖\n\n![代码结构](https://upload-images.jianshu.io/upload_images/5548226-692713d14976044d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以上是springcloud项目，eureka是注册中心，zuul是注册网关，ribbon和feign都是cloud的rpc远程调用。\nzuul主要是用来配置网关\n```\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.2.RELEASE</version>\n        <relativePath /> <!-- lookup parent from repository -->\n    </parent>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <!--eureka server -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka-server</artifactId>\n        </dependency>\n        <!-- spring boot test -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Dalston.RC1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n    <repositories>\n        <repository>\n            <id>spring-milestones</id>\n            <name>Spring Milestones</name>\n            <url>https://repo.spring.io/milestone</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n```\n 4 配置application.yml\n```\nserver:\n  port: 8761\neureka:\n  instance:\n    hostname: localhost\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n 5 启动EurekaServer\n```\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n       SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n```\neureka.client.registerWithEureka=true #是否将自身注册\neureka.client.fetchRegistry=false #如果为true，启动时报警.\n\n 6 打开eureka server 界面的\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-8bd98f9a99397bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2.3、服务提供者\n创建一个服务提供者 (eureka client),当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。\n \n 1 创建项目eurekaclient\n 2 引入maven依赖\n```\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.2.RELEASE</version>\n        <relativePath /> <!-- lookup parent from repository -->\n    </parent>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Dalston.RC1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n    <repositories>\n        <repository>\n            <id>spring-milestones</id>\n            <name>Spring Milestones</name>\n            <url>https://repo.spring.io/milestone</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n```\n 3 application.yml配置\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8762\nspring:\n  application:\n    name: service-hi\n```\n 4 发布服务\n通过注解@EnableEurekaClient 表明自己是一个eurekaclient.\n```\n@SpringBootApplication\n@EnableEurekaClient\n@RestController\npublic class ServiceHiApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceHiApplication.class, args);\n    }\n\n    @Value(\"${server.port}\")\n    String port;\n\n    @RequestMapping(\"/hi\")\n    public String home(@RequestParam String name) {\n        return \"hi \" + name + \",i am from port:\" + port;\n    }\n\n}\n```\n 5 演示效果\n需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。 启动工程，打开http://localhost:8761 ，即eureka server 的网址：\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-da12e4ba2018f724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862\n这时打开 http://localhost:8762/hi?name=forezp ，你会在浏览器上看到 :\nhi forezp,i am from port:8762\n \n## 2.4、服务消费者（Feign）\n什么是Feign\nFeign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。\n它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。\nFeign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n简而言之：\nFeign 采用的是基于接口的注解\nFeign 整合了ribbon\n 准备工作\n继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.\n 准备工创建一个feign的服务\n 1 新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖\nspring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web，代码如下：\n```\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.2.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-feign</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Dalston.RC1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n    <repositories>\n        <repository>\n            <id>spring-milestones</id>\n            <name>Spring Milestones</name>\n            <url>https://repo.spring.io/milestone</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n```\n 2 application.yml配置\n在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为http://localhost:8761/eureka/ ，代码如下：\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8765\nspring:\n  application:\n    name: service-feign\n```\n 3 定义一个feign接口\n```\n@FeignClient(value = \"service-hi\")\npublic interface SchedualServiceHi {\n    @RequestMapping(value = \"/hi\", method = RequestMethod.GET)\n    String sayHiFromClientOne(@RequestParam(value = \"name\") String name);\n}\n\n一个”/hi”的API接口\n@RestController\npublic class HiController {\n    @Autowired\n    SchedualServiceHi schedualServiceHi;\n    @RequestMapping(value = \"/hi\",method = RequestMethod.GET)\n    public String sayHi(@RequestParam String name){\n        return schedualServiceHi.sayHiFromClientOne(name);\n    }\n}\n\n启动方式\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class SericeFeign {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SericeFeign.class, args);\n    }\n\n}\n```\n 4 演示效果\n启动程序，多次访问http://localhost:8765/hi?name=forezp(http://localhost:8765/hi?name=forezp),浏览器交替显示：\n\nhi forezp,i am from port:8762\n\nhi forezp,i am from port:8763\n\n\n## 2.5、Hystrix断路器\n在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n### 2.5.1、什么是Hystrix\nNetflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-2fbf1a17cb61fe3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-f2b5c67fcf1be95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。\n准备工作\n这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。\n 1 在ribbon使用断路器\n改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖：\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-hystrix</artifactId>\n</dependency>\n```\n 2 改造service\n改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi,”+name+”,sorry,error!”，代码如下：\n```\n@Service\npublic class HelloService {\n\n    @Autowired\n    RestTemplate restTemplate;\n\n    @HystrixCommand(fallbackMethod = \"hiError\")\n    public String hiService(String name) {\n        return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\" + name, String.class);\n    }\n\n    public String hiError(String name) {\n        return \"hi,\" + name + \",sorry,error!\";\n    }\n}\n```\n 3 在启动类上加入\n```\n@SpringBootApplication\n@EnableEurekaClient\n@EnableHystrix   //断路器\npublic class App {\n\n    public static void main(String[] args) {\n        SpringApplication.run(App.class, args);\n    }\n\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n}\n```\n\n","source":"_posts/SpringCloud微服务框架搭建.md","raw":"---\ntitle: SpringCloud微服务框架搭建\ndate: 2016-06-20 15:05:37\ncategories:\n  Spring Boot\ntags:\n  - SpringCloud\n---\n\n# 一、微服务架构\n## 1.1什么是分布式\n不同模块部署在不同服务器上\n作用：分布式解决网站高并发带来问题\n\n## 1.2什么是集群\n多台服务器部署相同应用构成一个集群\n作用：通过负载均衡设备共同对外提供服务\n\n## 1.3什么是RPC\nRPC 的全称是 Remote Procedure Call 是一种进程间通信方式。\n它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。\n比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决\n\n### 1.3.1restful、soap、rpc\n（1）RESTful是一种架构设计风格，提供了设计原则和约束条件，而不是架构。而满足这些约束条件和原则的应用程序或设计就是 RESTful架构或服务。\n（2）SOAP，简单对象访问协议是一种数据交换协议规范，\n是一种轻量的、简单的、基于XML的协议的规范。SOAP协议和HTTP协议一样，都是底层的通信协议，只是请求包的格式不同而已，SOAP包是XML格式的。\nSOAP的消息是基于xml并封装成了符合http协议，因此，它符合任何路由器、 防火墙或代理服务器的要求。\nsoap可以使用任何语言来完成，只要发送正确的soap请求即可，基于soap的服务可以在任何平台无需修改即可正常使用。\n（3）RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。\nRPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）\nRPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）\nRPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。\n### 1.3.2rpc远程调用框架\n几种比较典型的RPC的实现和调用框架。 \n（1）RMI实现，利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol) \n和java的原生序列化。 \n（2）Hessian，是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。 \n（3）thrift是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。\n（4）SpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。\n\n## 1.4什么是SOA\n业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力\n通过服务的组合和编排来实现上层的业务流程\n作用：简化维护,降低整体风险,伸缩灵活\n\n## 1.5什么是微服务\n架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行\n SOA到微服务架构的演进过程\n 作用：各服务可独立应用，组合服务也可系统应用(巨石应用[monolith]的简化实现策略-平台思想)\n\n## 1.6使用RPC http技术实现会员与订单系统通讯\n\n# 二、SpringCloud\nSpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。\n\n## 2.1、服务提供者与消费关系\n服务提供者:提供服务被人调用\n消费者:调用被人服务\n\n## 2.2、服务的注册与发现(Eureka )\n在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,eureka是一个服务注册和发现模块。\n  1 服务注册\n  2 创建eurekaserver项目\n  3 引入maven依赖\n\n![代码结构](https://upload-images.jianshu.io/upload_images/5548226-692713d14976044d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n以上是springcloud项目，eureka是注册中心，zuul是注册网关，ribbon和feign都是cloud的rpc远程调用。\nzuul主要是用来配置网关\n```\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.2.RELEASE</version>\n        <relativePath /> <!-- lookup parent from repository -->\n    </parent>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <!--eureka server -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka-server</artifactId>\n        </dependency>\n        <!-- spring boot test -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Dalston.RC1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n    <repositories>\n        <repository>\n            <id>spring-milestones</id>\n            <name>Spring Milestones</name>\n            <url>https://repo.spring.io/milestone</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n```\n 4 配置application.yml\n```\nserver:\n  port: 8761\neureka:\n  instance:\n    hostname: localhost\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n    serviceUrl:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n```\n 5 启动EurekaServer\n```\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n       SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n```\neureka.client.registerWithEureka=true #是否将自身注册\neureka.client.fetchRegistry=false #如果为true，启动时报警.\n\n 6 打开eureka server 界面的\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-8bd98f9a99397bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2.3、服务提供者\n创建一个服务提供者 (eureka client),当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。\n \n 1 创建项目eurekaclient\n 2 引入maven依赖\n```\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.2.RELEASE</version>\n        <relativePath /> <!-- lookup parent from repository -->\n    </parent>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Dalston.RC1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n    <repositories>\n        <repository>\n            <id>spring-milestones</id>\n            <name>Spring Milestones</name>\n            <url>https://repo.spring.io/milestone</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n```\n 3 application.yml配置\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8762\nspring:\n  application:\n    name: service-hi\n```\n 4 发布服务\n通过注解@EnableEurekaClient 表明自己是一个eurekaclient.\n```\n@SpringBootApplication\n@EnableEurekaClient\n@RestController\npublic class ServiceHiApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceHiApplication.class, args);\n    }\n\n    @Value(\"${server.port}\")\n    String port;\n\n    @RequestMapping(\"/hi\")\n    public String home(@RequestParam String name) {\n        return \"hi \" + name + \",i am from port:\" + port;\n    }\n\n}\n```\n 5 演示效果\n需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。 启动工程，打开http://localhost:8761 ，即eureka server 的网址：\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-da12e4ba2018f724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862\n这时打开 http://localhost:8762/hi?name=forezp ，你会在浏览器上看到 :\nhi forezp,i am from port:8762\n \n## 2.4、服务消费者（Feign）\n什么是Feign\nFeign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。\n它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。\nFeign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n简而言之：\nFeign 采用的是基于接口的注解\nFeign 整合了ribbon\n 准备工作\n继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.\n 准备工创建一个feign的服务\n 1 新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖\nspring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web，代码如下：\n```\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>1.5.2.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>\n        <java.version>1.8</java.version>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-feign</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n    <dependencyManagement>\n        <dependencies>\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Dalston.RC1</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n    <repositories>\n        <repository>\n            <id>spring-milestones</id>\n            <name>Spring Milestones</name>\n            <url>https://repo.spring.io/milestone</url>\n            <snapshots>\n                <enabled>false</enabled>\n            </snapshots>\n        </repository>\n    </repositories>\n```\n 2 application.yml配置\n在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为http://localhost:8761/eureka/ ，代码如下：\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka/\nserver:\n  port: 8765\nspring:\n  application:\n    name: service-feign\n```\n 3 定义一个feign接口\n```\n@FeignClient(value = \"service-hi\")\npublic interface SchedualServiceHi {\n    @RequestMapping(value = \"/hi\", method = RequestMethod.GET)\n    String sayHiFromClientOne(@RequestParam(value = \"name\") String name);\n}\n\n一个”/hi”的API接口\n@RestController\npublic class HiController {\n    @Autowired\n    SchedualServiceHi schedualServiceHi;\n    @RequestMapping(value = \"/hi\",method = RequestMethod.GET)\n    public String sayHi(@RequestParam String name){\n        return schedualServiceHi.sayHiFromClientOne(name);\n    }\n}\n\n启动方式\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class SericeFeign {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SericeFeign.class, args);\n    }\n\n}\n```\n 4 演示效果\n启动程序，多次访问http://localhost:8765/hi?name=forezp(http://localhost:8765/hi?name=forezp),浏览器交替显示：\n\nhi forezp,i am from port:8762\n\nhi forezp,i am from port:8763\n\n\n## 2.5、Hystrix断路器\n在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n为了解决这个问题，业界提出了断路器模型。\n### 2.5.1、什么是Hystrix\nNetflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-2fbf1a17cb61fe3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。\n\n![eureka server 界面](https://upload-images.jianshu.io/upload_images/5548226-f2b5c67fcf1be95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。\n准备工作\n这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。\n 1 在ribbon使用断路器\n改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖：\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-hystrix</artifactId>\n</dependency>\n```\n 2 改造service\n改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi,”+name+”,sorry,error!”，代码如下：\n```\n@Service\npublic class HelloService {\n\n    @Autowired\n    RestTemplate restTemplate;\n\n    @HystrixCommand(fallbackMethod = \"hiError\")\n    public String hiService(String name) {\n        return restTemplate.getForObject(\"http://SERVICE-HI/hi?name=\" + name, String.class);\n    }\n\n    public String hiError(String name) {\n        return \"hi,\" + name + \",sorry,error!\";\n    }\n}\n```\n 3 在启动类上加入\n```\n@SpringBootApplication\n@EnableEurekaClient\n@EnableHystrix   //断路器\npublic class App {\n\n    public static void main(String[] args) {\n        SpringApplication.run(App.class, args);\n    }\n\n    @Bean\n    @LoadBalanced\n    RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n}\n```\n\n","slug":"SpringCloud微服务框架搭建","published":1,"updated":"2018-05-03T03:12:59.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja39e000s44eij5wlhka8","content":"<h1 id=\"一、微服务架构\"><a href=\"#一、微服务架构\" class=\"headerlink\" title=\"一、微服务架构\"></a>一、微服务架构</h1><h2 id=\"1-1什么是分布式\"><a href=\"#1-1什么是分布式\" class=\"headerlink\" title=\"1.1什么是分布式\"></a>1.1什么是分布式</h2><p>不同模块部署在不同服务器上<br>作用：分布式解决网站高并发带来问题</p>\n<h2 id=\"1-2什么是集群\"><a href=\"#1-2什么是集群\" class=\"headerlink\" title=\"1.2什么是集群\"></a>1.2什么是集群</h2><p>多台服务器部署相同应用构成一个集群<br>作用：通过负载均衡设备共同对外提供服务</p>\n<h2 id=\"1-3什么是RPC\"><a href=\"#1-3什么是RPC\" class=\"headerlink\" title=\"1.3什么是RPC\"></a>1.3什么是RPC</h2><p>RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。<br>它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。<br>比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决</p>\n<h3 id=\"1-3-1restful、soap、rpc\"><a href=\"#1-3-1restful、soap、rpc\" class=\"headerlink\" title=\"1.3.1restful、soap、rpc\"></a>1.3.1restful、soap、rpc</h3><p>（1）RESTful是一种架构设计风格，提供了设计原则和约束条件，而不是架构。而满足这些约束条件和原则的应用程序或设计就是 RESTful架构或服务。<br>（2）SOAP，简单对象访问协议是一种数据交换协议规范，<br>是一种轻量的、简单的、基于XML的协议的规范。SOAP协议和HTTP协议一样，都是底层的通信协议，只是请求包的格式不同而已，SOAP包是XML格式的。<br>SOAP的消息是基于xml并封装成了符合http协议，因此，它符合任何路由器、 防火墙或代理服务器的要求。<br>soap可以使用任何语言来完成，只要发送正确的soap请求即可，基于soap的服务可以在任何平台无需修改即可正常使用。<br>（3）RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。<br>RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）<br>RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）<br>RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</p>\n<h3 id=\"1-3-2rpc远程调用框架\"><a href=\"#1-3-2rpc远程调用框架\" class=\"headerlink\" title=\"1.3.2rpc远程调用框架\"></a>1.3.2rpc远程调用框架</h3><p>几种比较典型的RPC的实现和调用框架。<br>（1）RMI实现，利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol)<br>和java的原生序列化。<br>（2）Hessian，是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。<br>（3）thrift是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。<br>（4）SpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。</p>\n<h2 id=\"1-4什么是SOA\"><a href=\"#1-4什么是SOA\" class=\"headerlink\" title=\"1.4什么是SOA\"></a>1.4什么是SOA</h2><p>业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力<br>通过服务的组合和编排来实现上层的业务流程<br>作用：简化维护,降低整体风险,伸缩灵活</p>\n<h2 id=\"1-5什么是微服务\"><a href=\"#1-5什么是微服务\" class=\"headerlink\" title=\"1.5什么是微服务\"></a>1.5什么是微服务</h2><p>架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行<br> SOA到微服务架构的演进过程<br> 作用：各服务可独立应用，组合服务也可系统应用(巨石应用[monolith]的简化实现策略-平台思想)</p>\n<h2 id=\"1-6使用RPC-http技术实现会员与订单系统通讯\"><a href=\"#1-6使用RPC-http技术实现会员与订单系统通讯\" class=\"headerlink\" title=\"1.6使用RPC http技术实现会员与订单系统通讯\"></a>1.6使用RPC http技术实现会员与订单系统通讯</h2><h1 id=\"二、SpringCloud\"><a href=\"#二、SpringCloud\" class=\"headerlink\" title=\"二、SpringCloud\"></a>二、SpringCloud</h1><p>SpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。</p>\n<h2 id=\"2-1、服务提供者与消费关系\"><a href=\"#2-1、服务提供者与消费关系\" class=\"headerlink\" title=\"2.1、服务提供者与消费关系\"></a>2.1、服务提供者与消费关系</h2><p>服务提供者:提供服务被人调用<br>消费者:调用被人服务</p>\n<h2 id=\"2-2、服务的注册与发现-Eureka\"><a href=\"#2-2、服务的注册与发现-Eureka\" class=\"headerlink\" title=\"2.2、服务的注册与发现(Eureka )\"></a>2.2、服务的注册与发现(Eureka )</h2><p>在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,eureka是一个服务注册和发现模块。<br>  1 服务注册<br>  2 创建eurekaserver项目<br>  3 引入maven依赖</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-692713d14976044d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码结构\"></p>\n<p>以上是springcloud项目，eureka是注册中心，zuul是注册网关，ribbon和feign都是cloud的rpc远程调用。<br>zuul主要是用来配置网关<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;parent&gt;</div><div class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class=\"line\">        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</div><div class=\"line\">        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</div><div class=\"line\">    &lt;/parent&gt;</div><div class=\"line\">    &lt;properties&gt;</div><div class=\"line\">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class=\"line\">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class=\"line\">        &lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class=\"line\">    &lt;/properties&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;dependencies&gt;</div><div class=\"line\">        &lt;!--eureka server --&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;!-- spring boot test --&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">    &lt;/dependencies&gt;</div><div class=\"line\">    &lt;dependencyManagement&gt;</div><div class=\"line\">        &lt;dependencies&gt;</div><div class=\"line\">            &lt;dependency&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class=\"line\">                &lt;version&gt;Dalston.RC1&lt;/version&gt;</div><div class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</div><div class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</div><div class=\"line\">            &lt;/dependency&gt;</div><div class=\"line\">        &lt;/dependencies&gt;</div><div class=\"line\">    &lt;/dependencyManagement&gt;</div><div class=\"line\">    &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">            &lt;plugin&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">    &lt;/build&gt;</div><div class=\"line\">    &lt;repositories&gt;</div><div class=\"line\">        &lt;repository&gt;</div><div class=\"line\">            &lt;id&gt;spring-milestones&lt;/id&gt;</div><div class=\"line\">            &lt;name&gt;Spring Milestones&lt;/name&gt;</div><div class=\"line\">            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;</div><div class=\"line\">            &lt;snapshots&gt;</div><div class=\"line\">                &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">            &lt;/snapshots&gt;</div><div class=\"line\">        &lt;/repository&gt;</div><div class=\"line\">    &lt;/repositories&gt;</div></pre></td></tr></table></figure></p>\n<p> 4 配置application.yml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">server:</div><div class=\"line\">  port: 8761</div><div class=\"line\">eureka:</div><div class=\"line\">  instance:</div><div class=\"line\">    hostname: localhost</div><div class=\"line\">  client:</div><div class=\"line\">    registerWithEureka: false</div><div class=\"line\">    fetchRegistry: false</div><div class=\"line\">    serviceUrl:</div><div class=\"line\">      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</div></pre></td></tr></table></figure></p>\n<p> 5 启动EurekaServer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableEurekaServer</div><div class=\"line\">public class EurekaServerApplication &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">       SpringApplication.run(EurekaServerApplication.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>eureka.client.registerWithEureka=true #是否将自身注册<br>eureka.client.fetchRegistry=false #如果为true，启动时报警.</p>\n<p> 6 打开eureka server 界面的</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-8bd98f9a99397bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<h2 id=\"2-3、服务提供者\"><a href=\"#2-3、服务提供者\" class=\"headerlink\" title=\"2.3、服务提供者\"></a>2.3、服务提供者</h2><p>创建一个服务提供者 (eureka client),当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。</p>\n<p> 1 创建项目eurekaclient<br> 2 引入maven依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;parent&gt;</div><div class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class=\"line\">        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</div><div class=\"line\">        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</div><div class=\"line\">    &lt;/parent&gt;</div><div class=\"line\">    &lt;properties&gt;</div><div class=\"line\">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class=\"line\">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class=\"line\">        &lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class=\"line\">    &lt;/properties&gt;</div><div class=\"line\">    &lt;dependencies&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">    &lt;/dependencies&gt;</div><div class=\"line\">    &lt;dependencyManagement&gt;</div><div class=\"line\">        &lt;dependencies&gt;</div><div class=\"line\">            &lt;dependency&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class=\"line\">                &lt;version&gt;Dalston.RC1&lt;/version&gt;</div><div class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</div><div class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</div><div class=\"line\">            &lt;/dependency&gt;</div><div class=\"line\">        &lt;/dependencies&gt;</div><div class=\"line\">    &lt;/dependencyManagement&gt;</div><div class=\"line\">    &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">            &lt;plugin&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">    &lt;/build&gt;</div><div class=\"line\">    &lt;repositories&gt;</div><div class=\"line\">        &lt;repository&gt;</div><div class=\"line\">            &lt;id&gt;spring-milestones&lt;/id&gt;</div><div class=\"line\">            &lt;name&gt;Spring Milestones&lt;/name&gt;</div><div class=\"line\">            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;</div><div class=\"line\">            &lt;snapshots&gt;</div><div class=\"line\">                &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">            &lt;/snapshots&gt;</div><div class=\"line\">        &lt;/repository&gt;</div><div class=\"line\">    &lt;/repositories&gt;</div></pre></td></tr></table></figure></p>\n<p> 3 application.yml配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">eureka:</div><div class=\"line\">  client:</div><div class=\"line\">    serviceUrl:</div><div class=\"line\">      defaultZone: http://localhost:8761/eureka/</div><div class=\"line\">server:</div><div class=\"line\">  port: 8762</div><div class=\"line\">spring:</div><div class=\"line\">  application:</div><div class=\"line\">    name: service-hi</div></pre></td></tr></table></figure></p>\n<p> 4 发布服务<br>通过注解@EnableEurekaClient 表明自己是一个eurekaclient.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableEurekaClient</div><div class=\"line\">@RestController</div><div class=\"line\">public class ServiceHiApplication &#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        SpringApplication.run(ServiceHiApplication.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Value(&quot;$&#123;server.port&#125;&quot;)</div><div class=\"line\">    String port;</div><div class=\"line\"></div><div class=\"line\">    @RequestMapping(&quot;/hi&quot;)</div><div class=\"line\">    public String home(@RequestParam String name) &#123;</div><div class=\"line\">        return &quot;hi &quot; + name + &quot;,i am from port:&quot; + port;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 5 演示效果<br>需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。 启动工程，打开<a href=\"http://localhost:8761\" target=\"_blank\" rel=\"external\">http://localhost:8761</a> ，即eureka server 的网址：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-da12e4ba2018f724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<p>你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862<br>这时打开 <a href=\"http://localhost:8762/hi?name=forezp\" target=\"_blank\" rel=\"external\">http://localhost:8762/hi?name=forezp</a> ，你会在浏览器上看到 :<br>hi forezp,i am from port:8762</p>\n<h2 id=\"2-4、服务消费者（Feign）\"><a href=\"#2-4、服务消费者（Feign）\" class=\"headerlink\" title=\"2.4、服务消费者（Feign）\"></a>2.4、服务消费者（Feign）</h2><p>什么是Feign<br>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。<br>它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。<br>Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。<br>简而言之：<br>Feign 采用的是基于接口的注解<br>Feign 整合了ribbon<br> 准备工作<br>继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.<br> 准备工创建一个feign的服务<br> 1 新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖<br>spring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;parent&gt;</div><div class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class=\"line\">        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</div><div class=\"line\">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class=\"line\">    &lt;/parent&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;properties&gt;</div><div class=\"line\">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class=\"line\">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class=\"line\">        &lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class=\"line\">    &lt;/properties&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;dependencies&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">    &lt;/dependencies&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;dependencyManagement&gt;</div><div class=\"line\">        &lt;dependencies&gt;</div><div class=\"line\">            &lt;dependency&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class=\"line\">                &lt;version&gt;Dalston.RC1&lt;/version&gt;</div><div class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</div><div class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</div><div class=\"line\">            &lt;/dependency&gt;</div><div class=\"line\">        &lt;/dependencies&gt;</div><div class=\"line\">    &lt;/dependencyManagement&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">            &lt;plugin&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">    &lt;/build&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;repositories&gt;</div><div class=\"line\">        &lt;repository&gt;</div><div class=\"line\">            &lt;id&gt;spring-milestones&lt;/id&gt;</div><div class=\"line\">            &lt;name&gt;Spring Milestones&lt;/name&gt;</div><div class=\"line\">            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;</div><div class=\"line\">            &lt;snapshots&gt;</div><div class=\"line\">                &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">            &lt;/snapshots&gt;</div><div class=\"line\">        &lt;/repository&gt;</div><div class=\"line\">    &lt;/repositories&gt;</div></pre></td></tr></table></figure></p>\n<p> 2 application.yml配置<br>在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为<a href=\"http://localhost:8761/eureka/\" target=\"_blank\" rel=\"external\">http://localhost:8761/eureka/</a> ，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">eureka:</div><div class=\"line\">  client:</div><div class=\"line\">    serviceUrl:</div><div class=\"line\">      defaultZone: http://localhost:8761/eureka/</div><div class=\"line\">server:</div><div class=\"line\">  port: 8765</div><div class=\"line\">spring:</div><div class=\"line\">  application:</div><div class=\"line\">    name: service-feign</div></pre></td></tr></table></figure></p>\n<p> 3 定义一个feign接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">@FeignClient(value = &quot;service-hi&quot;)</div><div class=\"line\">public interface SchedualServiceHi &#123;</div><div class=\"line\">    @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET)</div><div class=\"line\">    String sayHiFromClientOne(@RequestParam(value = &quot;name&quot;) String name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">一个”/hi”的API接口</div><div class=\"line\">@RestController</div><div class=\"line\">public class HiController &#123;</div><div class=\"line\">    @Autowired</div><div class=\"line\">    SchedualServiceHi schedualServiceHi;</div><div class=\"line\">    @RequestMapping(value = &quot;/hi&quot;,method = RequestMethod.GET)</div><div class=\"line\">    public String sayHi(@RequestParam String name)&#123;</div><div class=\"line\">        return schedualServiceHi.sayHiFromClientOne(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">启动方式</div><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableDiscoveryClient</div><div class=\"line\">@EnableFeignClients</div><div class=\"line\">public class SericeFeign &#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        SpringApplication.run(SericeFeign.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 4 演示效果<br>启动程序，多次访问<a href=\"http://localhost:8765/hi?name=forezp(http://localhost:8765/hi?name=forezp),浏览器交替显示：\" target=\"_blank\" rel=\"external\">http://localhost:8765/hi?name=forezp(http://localhost:8765/hi?name=forezp),浏览器交替显示：</a></p>\n<p>hi forezp,i am from port:8762</p>\n<p>hi forezp,i am from port:8763</p>\n<h2 id=\"2-5、Hystrix断路器\"><a href=\"#2-5、Hystrix断路器\" class=\"headerlink\" title=\"2.5、Hystrix断路器\"></a>2.5、Hystrix断路器</h2><p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。<br>为了解决这个问题，业界提出了断路器模型。</p>\n<h3 id=\"2-5-1、什么是Hystrix\"><a href=\"#2-5-1、什么是Hystrix\" class=\"headerlink\" title=\"2.5.1、什么是Hystrix\"></a>2.5.1、什么是Hystrix</h3><p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-2fbf1a17cb61fe3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-f2b5c67fcf1be95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。<br>准备工作<br>这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。<br> 1 在ribbon使用断路器<br>改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>\n<p> 2 改造service<br>改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi,”+name+”,sorry,error!”，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Service</div><div class=\"line\">public class HelloService &#123;</div><div class=\"line\"></div><div class=\"line\">    @Autowired</div><div class=\"line\">    RestTemplate restTemplate;</div><div class=\"line\"></div><div class=\"line\">    @HystrixCommand(fallbackMethod = &quot;hiError&quot;)</div><div class=\"line\">    public String hiService(String name) &#123;</div><div class=\"line\">        return restTemplate.getForObject(&quot;http://SERVICE-HI/hi?name=&quot; + name, String.class);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String hiError(String name) &#123;</div><div class=\"line\">        return &quot;hi,&quot; + name + &quot;,sorry,error!&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 3 在启动类上加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableEurekaClient</div><div class=\"line\">@EnableHystrix   //断路器</div><div class=\"line\">public class App &#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        SpringApplication.run(App.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Bean</div><div class=\"line\">    @LoadBalanced</div><div class=\"line\">    RestTemplate restTemplate() &#123;</div><div class=\"line\">        return new RestTemplate();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、微服务架构\"><a href=\"#一、微服务架构\" class=\"headerlink\" title=\"一、微服务架构\"></a>一、微服务架构</h1><h2 id=\"1-1什么是分布式\"><a href=\"#1-1什么是分布式\" class=\"headerlink\" title=\"1.1什么是分布式\"></a>1.1什么是分布式</h2><p>不同模块部署在不同服务器上<br>作用：分布式解决网站高并发带来问题</p>\n<h2 id=\"1-2什么是集群\"><a href=\"#1-2什么是集群\" class=\"headerlink\" title=\"1.2什么是集群\"></a>1.2什么是集群</h2><p>多台服务器部署相同应用构成一个集群<br>作用：通过负载均衡设备共同对外提供服务</p>\n<h2 id=\"1-3什么是RPC\"><a href=\"#1-3什么是RPC\" class=\"headerlink\" title=\"1.3什么是RPC\"></a>1.3什么是RPC</h2><p>RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。<br>它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。<br>比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决</p>\n<h3 id=\"1-3-1restful、soap、rpc\"><a href=\"#1-3-1restful、soap、rpc\" class=\"headerlink\" title=\"1.3.1restful、soap、rpc\"></a>1.3.1restful、soap、rpc</h3><p>（1）RESTful是一种架构设计风格，提供了设计原则和约束条件，而不是架构。而满足这些约束条件和原则的应用程序或设计就是 RESTful架构或服务。<br>（2）SOAP，简单对象访问协议是一种数据交换协议规范，<br>是一种轻量的、简单的、基于XML的协议的规范。SOAP协议和HTTP协议一样，都是底层的通信协议，只是请求包的格式不同而已，SOAP包是XML格式的。<br>SOAP的消息是基于xml并封装成了符合http协议，因此，它符合任何路由器、 防火墙或代理服务器的要求。<br>soap可以使用任何语言来完成，只要发送正确的soap请求即可，基于soap的服务可以在任何平台无需修改即可正常使用。<br>（3）RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。<br>RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）<br>RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）<br>RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</p>\n<h3 id=\"1-3-2rpc远程调用框架\"><a href=\"#1-3-2rpc远程调用框架\" class=\"headerlink\" title=\"1.3.2rpc远程调用框架\"></a>1.3.2rpc远程调用框架</h3><p>几种比较典型的RPC的实现和调用框架。<br>（1）RMI实现，利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol)<br>和java的原生序列化。<br>（2）Hessian，是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。<br>（3）thrift是一种可伸缩的跨语言服务的软件框架。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。<br>（4）SpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。</p>\n<h2 id=\"1-4什么是SOA\"><a href=\"#1-4什么是SOA\" class=\"headerlink\" title=\"1.4什么是SOA\"></a>1.4什么是SOA</h2><p>业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力<br>通过服务的组合和编排来实现上层的业务流程<br>作用：简化维护,降低整体风险,伸缩灵活</p>\n<h2 id=\"1-5什么是微服务\"><a href=\"#1-5什么是微服务\" class=\"headerlink\" title=\"1.5什么是微服务\"></a>1.5什么是微服务</h2><p>架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行<br> SOA到微服务架构的演进过程<br> 作用：各服务可独立应用，组合服务也可系统应用(巨石应用[monolith]的简化实现策略-平台思想)</p>\n<h2 id=\"1-6使用RPC-http技术实现会员与订单系统通讯\"><a href=\"#1-6使用RPC-http技术实现会员与订单系统通讯\" class=\"headerlink\" title=\"1.6使用RPC http技术实现会员与订单系统通讯\"></a>1.6使用RPC http技术实现会员与订单系统通讯</h2><h1 id=\"二、SpringCloud\"><a href=\"#二、SpringCloud\" class=\"headerlink\" title=\"二、SpringCloud\"></a>二、SpringCloud</h1><p>SpringCloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。</p>\n<h2 id=\"2-1、服务提供者与消费关系\"><a href=\"#2-1、服务提供者与消费关系\" class=\"headerlink\" title=\"2.1、服务提供者与消费关系\"></a>2.1、服务提供者与消费关系</h2><p>服务提供者:提供服务被人调用<br>消费者:调用被人服务</p>\n<h2 id=\"2-2、服务的注册与发现-Eureka\"><a href=\"#2-2、服务的注册与发现-Eureka\" class=\"headerlink\" title=\"2.2、服务的注册与发现(Eureka )\"></a>2.2、服务的注册与发现(Eureka )</h2><p>在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,eureka是一个服务注册和发现模块。<br>  1 服务注册<br>  2 创建eurekaserver项目<br>  3 引入maven依赖</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-692713d14976044d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代码结构\"></p>\n<p>以上是springcloud项目，eureka是注册中心，zuul是注册网关，ribbon和feign都是cloud的rpc远程调用。<br>zuul主要是用来配置网关<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;parent&gt;</div><div class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class=\"line\">        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</div><div class=\"line\">        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</div><div class=\"line\">    &lt;/parent&gt;</div><div class=\"line\">    &lt;properties&gt;</div><div class=\"line\">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class=\"line\">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class=\"line\">        &lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class=\"line\">    &lt;/properties&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;dependencies&gt;</div><div class=\"line\">        &lt;!--eureka server --&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;!-- spring boot test --&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">    &lt;/dependencies&gt;</div><div class=\"line\">    &lt;dependencyManagement&gt;</div><div class=\"line\">        &lt;dependencies&gt;</div><div class=\"line\">            &lt;dependency&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class=\"line\">                &lt;version&gt;Dalston.RC1&lt;/version&gt;</div><div class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</div><div class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</div><div class=\"line\">            &lt;/dependency&gt;</div><div class=\"line\">        &lt;/dependencies&gt;</div><div class=\"line\">    &lt;/dependencyManagement&gt;</div><div class=\"line\">    &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">            &lt;plugin&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">    &lt;/build&gt;</div><div class=\"line\">    &lt;repositories&gt;</div><div class=\"line\">        &lt;repository&gt;</div><div class=\"line\">            &lt;id&gt;spring-milestones&lt;/id&gt;</div><div class=\"line\">            &lt;name&gt;Spring Milestones&lt;/name&gt;</div><div class=\"line\">            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;</div><div class=\"line\">            &lt;snapshots&gt;</div><div class=\"line\">                &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">            &lt;/snapshots&gt;</div><div class=\"line\">        &lt;/repository&gt;</div><div class=\"line\">    &lt;/repositories&gt;</div></pre></td></tr></table></figure></p>\n<p> 4 配置application.yml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">server:</div><div class=\"line\">  port: 8761</div><div class=\"line\">eureka:</div><div class=\"line\">  instance:</div><div class=\"line\">    hostname: localhost</div><div class=\"line\">  client:</div><div class=\"line\">    registerWithEureka: false</div><div class=\"line\">    fetchRegistry: false</div><div class=\"line\">    serviceUrl:</div><div class=\"line\">      defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</div></pre></td></tr></table></figure></p>\n<p> 5 启动EurekaServer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableEurekaServer</div><div class=\"line\">public class EurekaServerApplication &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">       SpringApplication.run(EurekaServerApplication.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>eureka.client.registerWithEureka=true #是否将自身注册<br>eureka.client.fetchRegistry=false #如果为true，启动时报警.</p>\n<p> 6 打开eureka server 界面的</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-8bd98f9a99397bee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<h2 id=\"2-3、服务提供者\"><a href=\"#2-3、服务提供者\" class=\"headerlink\" title=\"2.3、服务提供者\"></a>2.3、服务提供者</h2><p>创建一个服务提供者 (eureka client),当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。</p>\n<p> 1 创建项目eurekaclient<br> 2 引入maven依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;parent&gt;</div><div class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class=\"line\">        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</div><div class=\"line\">        &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;</div><div class=\"line\">    &lt;/parent&gt;</div><div class=\"line\">    &lt;properties&gt;</div><div class=\"line\">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class=\"line\">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class=\"line\">        &lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class=\"line\">    &lt;/properties&gt;</div><div class=\"line\">    &lt;dependencies&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">    &lt;/dependencies&gt;</div><div class=\"line\">    &lt;dependencyManagement&gt;</div><div class=\"line\">        &lt;dependencies&gt;</div><div class=\"line\">            &lt;dependency&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class=\"line\">                &lt;version&gt;Dalston.RC1&lt;/version&gt;</div><div class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</div><div class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</div><div class=\"line\">            &lt;/dependency&gt;</div><div class=\"line\">        &lt;/dependencies&gt;</div><div class=\"line\">    &lt;/dependencyManagement&gt;</div><div class=\"line\">    &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">            &lt;plugin&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">    &lt;/build&gt;</div><div class=\"line\">    &lt;repositories&gt;</div><div class=\"line\">        &lt;repository&gt;</div><div class=\"line\">            &lt;id&gt;spring-milestones&lt;/id&gt;</div><div class=\"line\">            &lt;name&gt;Spring Milestones&lt;/name&gt;</div><div class=\"line\">            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;</div><div class=\"line\">            &lt;snapshots&gt;</div><div class=\"line\">                &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">            &lt;/snapshots&gt;</div><div class=\"line\">        &lt;/repository&gt;</div><div class=\"line\">    &lt;/repositories&gt;</div></pre></td></tr></table></figure></p>\n<p> 3 application.yml配置<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">eureka:</div><div class=\"line\">  client:</div><div class=\"line\">    serviceUrl:</div><div class=\"line\">      defaultZone: http://localhost:8761/eureka/</div><div class=\"line\">server:</div><div class=\"line\">  port: 8762</div><div class=\"line\">spring:</div><div class=\"line\">  application:</div><div class=\"line\">    name: service-hi</div></pre></td></tr></table></figure></p>\n<p> 4 发布服务<br>通过注解@EnableEurekaClient 表明自己是一个eurekaclient.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableEurekaClient</div><div class=\"line\">@RestController</div><div class=\"line\">public class ServiceHiApplication &#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        SpringApplication.run(ServiceHiApplication.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Value(&quot;$&#123;server.port&#125;&quot;)</div><div class=\"line\">    String port;</div><div class=\"line\"></div><div class=\"line\">    @RequestMapping(&quot;/hi&quot;)</div><div class=\"line\">    public String home(@RequestParam String name) &#123;</div><div class=\"line\">        return &quot;hi &quot; + name + &quot;,i am from port:&quot; + port;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 5 演示效果<br>需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。 启动工程，打开<a href=\"http://localhost:8761\" target=\"_blank\" rel=\"external\">http://localhost:8761</a> ，即eureka server 的网址：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-da12e4ba2018f724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<p>你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862<br>这时打开 <a href=\"http://localhost:8762/hi?name=forezp\" target=\"_blank\" rel=\"external\">http://localhost:8762/hi?name=forezp</a> ，你会在浏览器上看到 :<br>hi forezp,i am from port:8762</p>\n<h2 id=\"2-4、服务消费者（Feign）\"><a href=\"#2-4、服务消费者（Feign）\" class=\"headerlink\" title=\"2.4、服务消费者（Feign）\"></a>2.4、服务消费者（Feign）</h2><p>什么是Feign<br>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。<br>它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。<br>Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。<br>简而言之：<br>Feign 采用的是基于接口的注解<br>Feign 整合了ribbon<br> 准备工作<br>继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.<br> 准备工创建一个feign的服务<br> 1 新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖<br>spring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;parent&gt;</div><div class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</div><div class=\"line\">        &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;</div><div class=\"line\">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</div><div class=\"line\">    &lt;/parent&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;properties&gt;</div><div class=\"line\">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</div><div class=\"line\">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</div><div class=\"line\">        &lt;java.version&gt;1.8&lt;/java.version&gt;</div><div class=\"line\">    &lt;/properties&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;dependencies&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\"></div><div class=\"line\">        &lt;dependency&gt;</div><div class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</div><div class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</div><div class=\"line\">        &lt;/dependency&gt;</div><div class=\"line\">    &lt;/dependencies&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;dependencyManagement&gt;</div><div class=\"line\">        &lt;dependencies&gt;</div><div class=\"line\">            &lt;dependency&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</div><div class=\"line\">                &lt;version&gt;Dalston.RC1&lt;/version&gt;</div><div class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</div><div class=\"line\">                &lt;scope&gt;import&lt;/scope&gt;</div><div class=\"line\">            &lt;/dependency&gt;</div><div class=\"line\">        &lt;/dependencies&gt;</div><div class=\"line\">    &lt;/dependencyManagement&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">            &lt;plugin&gt;</div><div class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">    &lt;/build&gt;</div><div class=\"line\"></div><div class=\"line\">    &lt;repositories&gt;</div><div class=\"line\">        &lt;repository&gt;</div><div class=\"line\">            &lt;id&gt;spring-milestones&lt;/id&gt;</div><div class=\"line\">            &lt;name&gt;Spring Milestones&lt;/name&gt;</div><div class=\"line\">            &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;</div><div class=\"line\">            &lt;snapshots&gt;</div><div class=\"line\">                &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">            &lt;/snapshots&gt;</div><div class=\"line\">        &lt;/repository&gt;</div><div class=\"line\">    &lt;/repositories&gt;</div></pre></td></tr></table></figure></p>\n<p> 2 application.yml配置<br>在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为<a href=\"http://localhost:8761/eureka/\" target=\"_blank\" rel=\"external\">http://localhost:8761/eureka/</a> ，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">eureka:</div><div class=\"line\">  client:</div><div class=\"line\">    serviceUrl:</div><div class=\"line\">      defaultZone: http://localhost:8761/eureka/</div><div class=\"line\">server:</div><div class=\"line\">  port: 8765</div><div class=\"line\">spring:</div><div class=\"line\">  application:</div><div class=\"line\">    name: service-feign</div></pre></td></tr></table></figure></p>\n<p> 3 定义一个feign接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">@FeignClient(value = &quot;service-hi&quot;)</div><div class=\"line\">public interface SchedualServiceHi &#123;</div><div class=\"line\">    @RequestMapping(value = &quot;/hi&quot;, method = RequestMethod.GET)</div><div class=\"line\">    String sayHiFromClientOne(@RequestParam(value = &quot;name&quot;) String name);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">一个”/hi”的API接口</div><div class=\"line\">@RestController</div><div class=\"line\">public class HiController &#123;</div><div class=\"line\">    @Autowired</div><div class=\"line\">    SchedualServiceHi schedualServiceHi;</div><div class=\"line\">    @RequestMapping(value = &quot;/hi&quot;,method = RequestMethod.GET)</div><div class=\"line\">    public String sayHi(@RequestParam String name)&#123;</div><div class=\"line\">        return schedualServiceHi.sayHiFromClientOne(name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">启动方式</div><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableDiscoveryClient</div><div class=\"line\">@EnableFeignClients</div><div class=\"line\">public class SericeFeign &#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        SpringApplication.run(SericeFeign.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 4 演示效果<br>启动程序，多次访问<a href=\"http://localhost:8765/hi?name=forezp(http://localhost:8765/hi?name=forezp),浏览器交替显示：\" target=\"_blank\" rel=\"external\">http://localhost:8765/hi?name=forezp(http://localhost:8765/hi?name=forezp),浏览器交替显示：</a></p>\n<p>hi forezp,i am from port:8762</p>\n<p>hi forezp,i am from port:8763</p>\n<h2 id=\"2-5、Hystrix断路器\"><a href=\"#2-5、Hystrix断路器\" class=\"headerlink\" title=\"2.5、Hystrix断路器\"></a>2.5、Hystrix断路器</h2><p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。<br>为了解决这个问题，业界提出了断路器模型。</p>\n<h3 id=\"2-5-1、什么是Hystrix\"><a href=\"#2-5-1、什么是Hystrix\" class=\"headerlink\" title=\"2.5.1、什么是Hystrix\"></a>2.5.1、什么是Hystrix</h3><p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-2fbf1a17cb61fe3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5548226-f2b5c67fcf1be95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"eureka server 界面\"></p>\n<p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。<br>准备工作<br>这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。<br> 1 在ribbon使用断路器<br>改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;dependency&gt;</div><div class=\"line\">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</div><div class=\"line\">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>\n<p> 2 改造service<br>改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi,”+name+”,sorry,error!”，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Service</div><div class=\"line\">public class HelloService &#123;</div><div class=\"line\"></div><div class=\"line\">    @Autowired</div><div class=\"line\">    RestTemplate restTemplate;</div><div class=\"line\"></div><div class=\"line\">    @HystrixCommand(fallbackMethod = &quot;hiError&quot;)</div><div class=\"line\">    public String hiService(String name) &#123;</div><div class=\"line\">        return restTemplate.getForObject(&quot;http://SERVICE-HI/hi?name=&quot; + name, String.class);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public String hiError(String name) &#123;</div><div class=\"line\">        return &quot;hi,&quot; + name + &quot;,sorry,error!&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 3 在启动类上加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SpringBootApplication</div><div class=\"line\">@EnableEurekaClient</div><div class=\"line\">@EnableHystrix   //断路器</div><div class=\"line\">public class App &#123;</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        SpringApplication.run(App.class, args);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Bean</div><div class=\"line\">    @LoadBalanced</div><div class=\"line\">    RestTemplate restTemplate() &#123;</div><div class=\"line\">        return new RestTemplate();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"Docker常用命令","date":"2017-06-11T09:28:43.000Z","_content":"\n# 前言\n从技术老大那里听说了docker，闲下来之后就简单了解了一下，发现真的是一个好用的不得了的工具。遂周末去图书馆找了下相关资料，学习下姿势。说不定哪天用上了呢😝。在看资料的过程中，发现有不少命令都不知道什么意思，所以干脆做了一个整理，以备以后查阅。ps：在docker命令后输入 -h 参数，可查看详细命令。我也是参照某本书上的命令整理的，也不是很全，待以后遇到了继续补充。\n> 文中 =[] 表示设置选项时可以设置不同的值，并且可以多次使用 如： -p 8000:80 -p 8080:8080\n> 命令后面的 =false 表示默认值为 false =\"\" 表示默认值为空\n> 若用户不属于docker组，可能需要sudo执行\n\n# docker基础命令\n> docker <选项><命令><参数>\n\n`--api-enable-cors=false` 使用API时，启用CORS（cross-origin resource sharing）\n`-b 、--bridge=\"\"` 使用事先创建的网桥接口。若设置为none，则不在容器内使用网络\n`--bip=\"\"` 使用CIDR标记法设置docker 的IP带宽。该选项不能与-b选项同时使用\n```sh\n如：`-bip=\"192.168.0.0/24\"`\n```\n`-D 、--debug` 启用调试模式\n`-d 、--deamon=false` 以守护进程模式运行\n`--dns` 设置docker要使用的DNS服务器\n`--dns-search=[]` 设置docker要使用的DNS搜索域。若设置为：example.com，则向服务器查询hello时，将首先查找hello.example.com\n`-e、--exec-drive=\"native\"` 设置docker运行驱动，可设置为Native与lxc\n`--fixed-cidr=\"\"` 固定分配IPv4地址的带宽。该IP地址必须在-b选项设置的网桥网络或--bip设置的IP网段内\n`-G、--group=\"docker\"` 以守护进程模式运行时，使用-H选项创建Unix套接字后，设置该Unix套接字所在的组。使用\"\"空字符串表示不设置分组\n`-g、 --graph=\"/var/lib/docker\"` 设置docker使用目录的顶层路径\n-H、--host[] 以守护进程模式运行时，设置套接字路径。ls\n\n--icc=true 开启容器间通信\n--insecure-registry=[] 使用私有证书搭建docker注册服务器时，设置docker注册服务器域名\n--ip=0.0.0.0 使用docker run 命令时-p选项将端口暴露在外时，设置要绑定的默认IP地址\n--ip-forward=true 开启net.ipv4.ip_forward\n--ip-masq=true 为网桥上的IP地址开启IP伪装（masquerading）\n--iptables=true 开启iptables规则\n--mtu=0 设置容器的网络最大传输单元（MTU, Maxmum transmission unit）若不设置，则使用路由器的默认MTU或者设置为1500\n-p、--pidfile=\"/var/run/docker.pid\" 设置PID文件路径\n-registry-mirror=[] 设置docker registry 的镜像地址\n-s、--storage-driver=[] 设置储存驱动，默认为auto，也可以设置为drivcemapper\n--selinux-enabled=false开启SELinux SELinux尚不支持BTRFS储存驱动\n--storage-opt 设置存储驱动选项\n--tls=false 使用TLS\n--tlscacert=\"/home/exapmleuser/.docker/ca.pem\" 设置要在远程证书中使用的CA证书文件的路径\n--tlscert=\"/home/exapmleuser/.docker/cert.pem\" 设置证书文件路径\n--tlskey=\"/home/exapmleuser/.docker/key.pem\" 设置密匙文件路径\ntlsverify=\"false\" 使用TLS远程证书，守护进程与客户端全部使用证书验证\n-v、--version=false 打印版本信息\n# attach命令\n> attach命令用于将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器\n> docker attach <选项><容器名称, id>\n\n--no-stdin=false 不连接标准输入\n--sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样）但不传送SIGCHLD、SIGKILL、SIGSTOP信号。经常使用的信号如下：\n```sh\nSIGINT：interrupt信号，输入Ctrl + c 时发生\nSIGQUIT：Quit信号，输入Ctrl + \\ 时发生\nEOF：终止attach状态，输入Ctrl + d 时发生\n```\n一般会先运行Bash等shell，然后使用docker attach 命令连接到容器，在运行各种命令\n```sh\ndocker run -it --name hello ubuntu /bin/bash\ndocker attach hello\n```\n# build 命令\n> build命令使用Dockerfile文件创建镜像\n> docker build <选项><Dockerfile路径>\n\nDockerfile 路径可以使是本地路径，也可以是URL路径。若设置为 - ，则从标准输入获取Dockerfile的内容\n--force-rm=false 创建镜像失败时，删除临时容器\n--no-cache=false 不使用之前构建中创建的缓存。\n-q、--quiet=false 不显示Dockerfile的RUN运行的输出结果\n--rm=true 创建镜像成功时，删除临时容器\n-t、--tag=\"\" 设置注册名称、镜像名称、标签。格式为 <注册名称>/<镜像名称>:<标签>（标签默认为latest）\n# commit 命令\n> commit命令用于从容器的修改项创建显得镜像\n> docker commit <选项><容器名称，id>/<镜像名称>:<标签>\n\n-a、--author=\"\" 设置奖项创建者的有关信息\n-m、--message=\"\" 设置有关变更事项的日志信息\n-p、--pause=true 创建镜像是暂停容器\n# cp 命令\n> cp命令用于将容器的目录或文件复制的到主机。若将cp命令中的路径设置为目录，则将该目录下的所有内容复制到主机\n\ndocker cp <容器名称>:<路径><主机路径>\n```sh\n$ docker cp hello:/etc . 将容器内的整个/etc 目录复制到主机当前文件夹下\n```\n# create 命令\n> create 命令使用指定的镜像创建容器。与run命令不同，使用create命令只能创建容器而并不启动\n> docker create <选项><镜像名称,id><命令><参数>\n\n-a 、--attach=[] 将标准输入、标准输出、标准错误链接到容器\n--attach=\"stdin\"\n\n--add-host=[] 向容器的/etc/hosts添加主机名与IP地址\n--add-host=hello:192.168.0.233\n\n-C、--cpu-shares=0 设置cup资源分配。默认是这值为1024，各值为相对值\n若设置为--cpu-shares=2048, 则分配默认值为2倍的CPU资源\n在Linux内核的cgroups中使用该设置的值\n--cap-add[] 设置容器中使用的cgroups的特定Capablity。若设置为ALL，则使用所有的Capablity\n--cap-drop=[] 从容器删除cgroup的特定Capablity\n--cidfile=\"\" 设置cid文件路径。cid中存储着所创建容器的id\n--cpuset=\"\" 在多核CPU中设置要运行容器的核心数\n若设置--cpuset=\"0,1\" 则使用第一与第二个cup\n若这是--cupset=\"0-2\" 则使用从第一到第三个cup\n--device=[] 添加主机设备到容器，格式为<主机设备>:<容器设备>\n若设置为 --device=\"/dev/sda1:/dev/sda1\",则在容器中也可以使用主机的/dev/sda1块设备\n\n--dns=[] 设置容器中要用到的DNS服务器\n--dns-search=[] 设置docker要使用的DNS搜索域。\n-e、--env=[] 向容器设置环境变量。一般用于传递设置或者密码\n如：-e MYSQL_ROOT_PASSWORD=root\n--entrypoint=\"\" 忽略Dockerfile的ENTRYPOINT设置，强制设置为其他值。\n如：--entrypoint=\"/bin/bash\"\n--env-file=[] 向容器应用设置环境变量文件\n--expose=[] 仅连接容器的端口与主机，并不暴露在外\n--expose=\"3306\"\n-h、--hostname=\"\" 设置容器主机名\n-i、--interactive=false 激活标准输入，即使未与容器连接（attach），也维持标准输入。一般使用该选项向Bash输入命令\n--link=[] 进行容器连接，格式为<容器名称>:<别名>\n--link mysql-server:mysql\n\n--lxc-conf=[] 若使用LXC驱动，则可以设置LXC选项\n--lxc-conf=\"lxc.cgroup.cpuset.cpu = 0,1\"    \n\n-m、--memory=\"\" 设置内存限制，格式为<数字><单位>，单位可以使用b,k,m,g\n--memory=\"512m\"\n--name 设置容器名称\n--net=\"bridge\" 设置容器的网络模式（选项可以是：bridge,none,container,host）\n-P、--publish-all=false 将连接到主机的容器的所有端口暴露在外\n-p、--publish=[] 将连接到主机的容器的特定端口暴露在外。一般主要用于暴露web服务器的端口\n--privileged=false 在容器内部使用主机的所有Linux内核功能\n--restart=\"\" 设置容器内部进程终止时重启策略\n--restart=no 即使进程终止也不重启\n--restart=\"on-failure\" 仅当进程的Exit Code 不为0时执行重启。也可以设置重置次数。若不设置重试次数，这不断重启。如 --restart=\"no-failure:10\"\n--restart=\"always\" 不受Exit Code的影响，总是重启\n--security-opt=[] 设置SELinux、AppArmor 选项\n-t、--tty=false 使用TTY模式（pseudo-TTY）。若要使用Bash，则必须设置该选项。若不设置该选项，则可以输入命令，但不显示shell\n-u、--user=\"\" 设置容器运行时要使用的Linux用户账户与UID\n-v、--volume=[] 设置数据卷。设置要与主机共享目录，不将文件保存到容器，而直接保存到主机。在主机目录后添加 :ro、:rw进行读写设置，默认为:rw。\n--volumes-from=[] 连接数据卷容器，设置格式为<容器名，id>:<:ro, :rw> 默认情形下，读写设置遵从-v选项的设置。\n-w、--workdir=\"\" 设置容器内部要运行进程的目录\n运行如下命令，创建容器\n```sh\n$ docker create -it --name hello ubuntu /bin/bash\n若想使用刚刚创建的容器，则必须使用docker start 命令启动容器\n$ docker start hello\n进入容器内部\n$ docker attach hello\n···\n# diff 命令\n> diff命令用于检查容器文件系统的修改\n> docker diff <容器名称，id>\n\n比较文件是否修改的标准是容器创建时的镜像内容\nA：添加的文件\nC：修改的文件\nD：删除的文件\n# events 命令\n> events命令用于实时输出Docker服务器中发生的事件\n```sh\ndocker events\n```\n--since=\"\" 输出特定的timestamp之后的事件\n--until=\"\" 输出特定的timestamp之前的事件\n运行docker events命令，进入待机状态\n```sh\n$ docker events\n```\n在另一终端，运行容器\n```sh\n$ docker start hello #假设容器已存在\n```\n就会在刚刚的docker events 命令窗口看到 运行hello 容器的事件\n# exec 命令\n> exec命令用于从外部运行容器内部的命令\n> docker exec <选项><容器名称，id><命令><参数>\n\n-d、--detach=false 以后台模式运行命令\n-i、--interactive=false 开启标准输入，即使未与容器连接，也维持标准输入\n-t、--tty=false 使用TTY模式（pseudo-TTY）若要使用bash，则必须设置该选项。若不设置该选项，则虽然输入命令，但不显示shell\n运行如下命令，创建容器\n```sh\n$ docker run -d --name hello ubuntu /bin/bash -c \"while true; do echo Hello World; sleep 1; done\"\n设置每隔一秒输出一次hello world。在此状态下，运行容器内部的/bin/bash,连接至bash shell ，如下所示。连接bash shell 时，只有使用 -i -t 选项才能输入命令并查看结果\n$ docker exec -it hello /bin/bash  #连接容器\n$ ps ax  # 查看进程\n```\n若在容器内部运行ps ax 命令，则可以看到由docker exec 命令运行的其他/bin/bash，与输出hello world 的/bin/bash 不是同一个。输入exit命令退出Bash shell后，容器不会停止，而会继续运行。像这样，灵活使用 docker exec 命令将Bash shell 连接到正在运行守护进程的容器上，并行多种操作\n如下：不连接Bash shell，而使用apt-get等命令，在容器内安装redis-server包，\n```sh\n$ docker exec hello apt-get update\n$ docker exec hello apt-get install -y redis-server\n$ docker exec -d hello redis-server # 后台运行rides-server\n```\n# export 命令\n> export命令将用于将容器的文件系统导出为tar文件包\n\ndocker export <容器名称，id>\n只运行docker export 命令后，由于容器的内容会输出到标准输出，所以必须设置重定向\n```sh\n$ docker run -it -d --name hello ubuntu /bin/bash\n$ docker export hello > hello.tar\n```\n# history 命令\n> history 命令用于显示镜像的历史。此处的历史依据Dockerfile文件中的设置创建。\n> docker history <选项><镜像名称，id>\n\n--no-trunc=false 输出所有因内容过长而省略的部分\n-q、--quiet=false 只显示镜像id\n# images 命令\n> images命令用于输出镜像列表\n> docker images <选项><镜像名称，id>\n\n-a、--all=false 列出所有镜像，包括父镜像\n-f、--filter=[] 设置输出结果过滤。若设置为\"dangling=true\"，则只输出无名镜像\n--no-trunc=false 显示所有因内容过长而省略的部分\n# import 命令\n> import命令用于从压缩为tar文件（.tar .tar.gz .tgz .bzip .tar.xz .txz）的文件系统创建镜像\n> docker import <tar文件的URL或者 - ><注册名称>/<镜像名称>:<标签>\n\n使用import命令时，可以设置tar文件的URL，若设置为 - ，则从标准输入接收tar文件的内容。既可以使用由docker export 命令创建的tar文件，也可以直接组织文件系统。\n```sh\n$ docker import http://example.com/hello.tar.zg hello\n```\n下列命令中使用本地的 hello.tar 文件的内容通过管道传递给 docker import 命令\n```sh\n$ cat hello.tar | docker import - hello\n```\n若想将当前目录的内容直接创建为镜像：\n```sh\n$ tar -c . | docker import - hello\n```\n# info 命令\n> info命令用于显示当前系统信息、docker容器、镜像个数、设置等信息。\n\ndocker info\ninspect 命令\ninspect 命令用于以JSON格式显示容器与镜像的详细信息\ndocker inspect <选项><容器或镜像名称，id>\n-f、--format=\"\" 只显示指定信息。如：\"{{.NetworkSettings.IPAddress}}\" 使用 . 来设置JSON文档的下层项目\n下面命令显示容器的IP地址\n```sh\n$ docker run -it -d --name hello ubuntu /bin/bash\n$ docker inspect -f \"{{.NetworkSettings.IPAddress}}\" hello\n```\n下面命令只从容器的详细信息中抽取特定部分，并按照所希望的格式显示\n```sh\n$ docker run -it -d --name hello -p 8000:80 -p 8080:8080 ubuntu /bin/bash\n$ docker inspect -f '{{range $p, $conf := .NetworkSettings.Ports}} {{$p}} -> {{(index $conf 0).HostPort}} {{end}}' hello\n```\n此处使用 {{range $p, $conf := .NetworkSettings.Ports}} 循环访问 .NetworkSettings.Ports 的值，并代入 $p $conf。然后输出$p,并将$conf数组的第一项 (index $conf 0) 的 .HostPort 输出。\n另：.NetworkSettings.Ports 是一个map类型数据结构：\n map[80/tcp:[{0.0.0.0 8000}] 8080/tcp:[{0.0.0.0 8080}]]\n\n# kill 命令\n> kill命令用于向容器发送KILL信号，从而关闭容器（推荐使用更优雅温和的 docker stop 命令)\n> docker <选项><容器名称，id>\n\n-s、--signal=\"KILL\" 发送特定信号\n# load 命令\n> load命令用于从tar文件创建镜像\n> docker load <选项>\n\n将tar文件发送到 docker load 命令的标准输入，然后创建镜像。tar文件由 docker save 命令创建，包含镜像名称与标签。\n-i、--input=\"\" 不使用标准输入，设置文件路径并创建镜像。\n```sh\n$ docker save myimages > myimages.tar  #将已存在的镜像保存为tar文件\n$ docker load < myimages.tar  #在另一台电脑从tar文件创建镜像\n```sh\n#login 命令\n>login命令用于登录Docker 的注册服务器\n>docker login <选项><Docker 注册服务器的URL>\n\n若不设置注册服务器的地址，则默认登录dockerhub（api https://index.docker.io/v1/）\n-e、--email=\"\" 设置登录时使用的电子邮件\n-p、--password=\"\" 设置登录密码\n-u、--username=\"\" 设置登录时使用的账号\n# logout 命令\n> logout命令用于从Docker注册服务器中登出\n> docker logout <选项><Docker 注册服务器的URL>\n\n若不设置注册服务器的地址，则默认为dockerhub（api https://index.docker.io/v1/）\n# logs 命令\n> logs命令用于输出容器日志\n>docker logs <容器名称，id>\n\n-f、--follow=false 一直输出实时日志\n-t、--timestamp=false 在登录时显示时间值\n--tail=\"all\" 指定数字，只从日志中输出一定个数\n# port 命令\n> port命令用于查看容器的某个端口是否处于开放状态\n> docker port <容器名称，id><端口>\n\n# pause 命令\n> pause命令用于暂停容器中正在运行的所有进程\n> docker pause <容器名称，id>","source":"_posts/Docker常用命令.md","raw":"---\ntitle: Docker常用命令\ndate: 2017-06-11 17:28:43\ncategories:\n  Server\ntags: \n  - Docker\n  - Technology\n---\n\n# 前言\n从技术老大那里听说了docker，闲下来之后就简单了解了一下，发现真的是一个好用的不得了的工具。遂周末去图书馆找了下相关资料，学习下姿势。说不定哪天用上了呢😝。在看资料的过程中，发现有不少命令都不知道什么意思，所以干脆做了一个整理，以备以后查阅。ps：在docker命令后输入 -h 参数，可查看详细命令。我也是参照某本书上的命令整理的，也不是很全，待以后遇到了继续补充。\n> 文中 =[] 表示设置选项时可以设置不同的值，并且可以多次使用 如： -p 8000:80 -p 8080:8080\n> 命令后面的 =false 表示默认值为 false =\"\" 表示默认值为空\n> 若用户不属于docker组，可能需要sudo执行\n\n# docker基础命令\n> docker <选项><命令><参数>\n\n`--api-enable-cors=false` 使用API时，启用CORS（cross-origin resource sharing）\n`-b 、--bridge=\"\"` 使用事先创建的网桥接口。若设置为none，则不在容器内使用网络\n`--bip=\"\"` 使用CIDR标记法设置docker 的IP带宽。该选项不能与-b选项同时使用\n```sh\n如：`-bip=\"192.168.0.0/24\"`\n```\n`-D 、--debug` 启用调试模式\n`-d 、--deamon=false` 以守护进程模式运行\n`--dns` 设置docker要使用的DNS服务器\n`--dns-search=[]` 设置docker要使用的DNS搜索域。若设置为：example.com，则向服务器查询hello时，将首先查找hello.example.com\n`-e、--exec-drive=\"native\"` 设置docker运行驱动，可设置为Native与lxc\n`--fixed-cidr=\"\"` 固定分配IPv4地址的带宽。该IP地址必须在-b选项设置的网桥网络或--bip设置的IP网段内\n`-G、--group=\"docker\"` 以守护进程模式运行时，使用-H选项创建Unix套接字后，设置该Unix套接字所在的组。使用\"\"空字符串表示不设置分组\n`-g、 --graph=\"/var/lib/docker\"` 设置docker使用目录的顶层路径\n-H、--host[] 以守护进程模式运行时，设置套接字路径。ls\n\n--icc=true 开启容器间通信\n--insecure-registry=[] 使用私有证书搭建docker注册服务器时，设置docker注册服务器域名\n--ip=0.0.0.0 使用docker run 命令时-p选项将端口暴露在外时，设置要绑定的默认IP地址\n--ip-forward=true 开启net.ipv4.ip_forward\n--ip-masq=true 为网桥上的IP地址开启IP伪装（masquerading）\n--iptables=true 开启iptables规则\n--mtu=0 设置容器的网络最大传输单元（MTU, Maxmum transmission unit）若不设置，则使用路由器的默认MTU或者设置为1500\n-p、--pidfile=\"/var/run/docker.pid\" 设置PID文件路径\n-registry-mirror=[] 设置docker registry 的镜像地址\n-s、--storage-driver=[] 设置储存驱动，默认为auto，也可以设置为drivcemapper\n--selinux-enabled=false开启SELinux SELinux尚不支持BTRFS储存驱动\n--storage-opt 设置存储驱动选项\n--tls=false 使用TLS\n--tlscacert=\"/home/exapmleuser/.docker/ca.pem\" 设置要在远程证书中使用的CA证书文件的路径\n--tlscert=\"/home/exapmleuser/.docker/cert.pem\" 设置证书文件路径\n--tlskey=\"/home/exapmleuser/.docker/key.pem\" 设置密匙文件路径\ntlsverify=\"false\" 使用TLS远程证书，守护进程与客户端全部使用证书验证\n-v、--version=false 打印版本信息\n# attach命令\n> attach命令用于将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器\n> docker attach <选项><容器名称, id>\n\n--no-stdin=false 不连接标准输入\n--sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样）但不传送SIGCHLD、SIGKILL、SIGSTOP信号。经常使用的信号如下：\n```sh\nSIGINT：interrupt信号，输入Ctrl + c 时发生\nSIGQUIT：Quit信号，输入Ctrl + \\ 时发生\nEOF：终止attach状态，输入Ctrl + d 时发生\n```\n一般会先运行Bash等shell，然后使用docker attach 命令连接到容器，在运行各种命令\n```sh\ndocker run -it --name hello ubuntu /bin/bash\ndocker attach hello\n```\n# build 命令\n> build命令使用Dockerfile文件创建镜像\n> docker build <选项><Dockerfile路径>\n\nDockerfile 路径可以使是本地路径，也可以是URL路径。若设置为 - ，则从标准输入获取Dockerfile的内容\n--force-rm=false 创建镜像失败时，删除临时容器\n--no-cache=false 不使用之前构建中创建的缓存。\n-q、--quiet=false 不显示Dockerfile的RUN运行的输出结果\n--rm=true 创建镜像成功时，删除临时容器\n-t、--tag=\"\" 设置注册名称、镜像名称、标签。格式为 <注册名称>/<镜像名称>:<标签>（标签默认为latest）\n# commit 命令\n> commit命令用于从容器的修改项创建显得镜像\n> docker commit <选项><容器名称，id>/<镜像名称>:<标签>\n\n-a、--author=\"\" 设置奖项创建者的有关信息\n-m、--message=\"\" 设置有关变更事项的日志信息\n-p、--pause=true 创建镜像是暂停容器\n# cp 命令\n> cp命令用于将容器的目录或文件复制的到主机。若将cp命令中的路径设置为目录，则将该目录下的所有内容复制到主机\n\ndocker cp <容器名称>:<路径><主机路径>\n```sh\n$ docker cp hello:/etc . 将容器内的整个/etc 目录复制到主机当前文件夹下\n```\n# create 命令\n> create 命令使用指定的镜像创建容器。与run命令不同，使用create命令只能创建容器而并不启动\n> docker create <选项><镜像名称,id><命令><参数>\n\n-a 、--attach=[] 将标准输入、标准输出、标准错误链接到容器\n--attach=\"stdin\"\n\n--add-host=[] 向容器的/etc/hosts添加主机名与IP地址\n--add-host=hello:192.168.0.233\n\n-C、--cpu-shares=0 设置cup资源分配。默认是这值为1024，各值为相对值\n若设置为--cpu-shares=2048, 则分配默认值为2倍的CPU资源\n在Linux内核的cgroups中使用该设置的值\n--cap-add[] 设置容器中使用的cgroups的特定Capablity。若设置为ALL，则使用所有的Capablity\n--cap-drop=[] 从容器删除cgroup的特定Capablity\n--cidfile=\"\" 设置cid文件路径。cid中存储着所创建容器的id\n--cpuset=\"\" 在多核CPU中设置要运行容器的核心数\n若设置--cpuset=\"0,1\" 则使用第一与第二个cup\n若这是--cupset=\"0-2\" 则使用从第一到第三个cup\n--device=[] 添加主机设备到容器，格式为<主机设备>:<容器设备>\n若设置为 --device=\"/dev/sda1:/dev/sda1\",则在容器中也可以使用主机的/dev/sda1块设备\n\n--dns=[] 设置容器中要用到的DNS服务器\n--dns-search=[] 设置docker要使用的DNS搜索域。\n-e、--env=[] 向容器设置环境变量。一般用于传递设置或者密码\n如：-e MYSQL_ROOT_PASSWORD=root\n--entrypoint=\"\" 忽略Dockerfile的ENTRYPOINT设置，强制设置为其他值。\n如：--entrypoint=\"/bin/bash\"\n--env-file=[] 向容器应用设置环境变量文件\n--expose=[] 仅连接容器的端口与主机，并不暴露在外\n--expose=\"3306\"\n-h、--hostname=\"\" 设置容器主机名\n-i、--interactive=false 激活标准输入，即使未与容器连接（attach），也维持标准输入。一般使用该选项向Bash输入命令\n--link=[] 进行容器连接，格式为<容器名称>:<别名>\n--link mysql-server:mysql\n\n--lxc-conf=[] 若使用LXC驱动，则可以设置LXC选项\n--lxc-conf=\"lxc.cgroup.cpuset.cpu = 0,1\"    \n\n-m、--memory=\"\" 设置内存限制，格式为<数字><单位>，单位可以使用b,k,m,g\n--memory=\"512m\"\n--name 设置容器名称\n--net=\"bridge\" 设置容器的网络模式（选项可以是：bridge,none,container,host）\n-P、--publish-all=false 将连接到主机的容器的所有端口暴露在外\n-p、--publish=[] 将连接到主机的容器的特定端口暴露在外。一般主要用于暴露web服务器的端口\n--privileged=false 在容器内部使用主机的所有Linux内核功能\n--restart=\"\" 设置容器内部进程终止时重启策略\n--restart=no 即使进程终止也不重启\n--restart=\"on-failure\" 仅当进程的Exit Code 不为0时执行重启。也可以设置重置次数。若不设置重试次数，这不断重启。如 --restart=\"no-failure:10\"\n--restart=\"always\" 不受Exit Code的影响，总是重启\n--security-opt=[] 设置SELinux、AppArmor 选项\n-t、--tty=false 使用TTY模式（pseudo-TTY）。若要使用Bash，则必须设置该选项。若不设置该选项，则可以输入命令，但不显示shell\n-u、--user=\"\" 设置容器运行时要使用的Linux用户账户与UID\n-v、--volume=[] 设置数据卷。设置要与主机共享目录，不将文件保存到容器，而直接保存到主机。在主机目录后添加 :ro、:rw进行读写设置，默认为:rw。\n--volumes-from=[] 连接数据卷容器，设置格式为<容器名，id>:<:ro, :rw> 默认情形下，读写设置遵从-v选项的设置。\n-w、--workdir=\"\" 设置容器内部要运行进程的目录\n运行如下命令，创建容器\n```sh\n$ docker create -it --name hello ubuntu /bin/bash\n若想使用刚刚创建的容器，则必须使用docker start 命令启动容器\n$ docker start hello\n进入容器内部\n$ docker attach hello\n···\n# diff 命令\n> diff命令用于检查容器文件系统的修改\n> docker diff <容器名称，id>\n\n比较文件是否修改的标准是容器创建时的镜像内容\nA：添加的文件\nC：修改的文件\nD：删除的文件\n# events 命令\n> events命令用于实时输出Docker服务器中发生的事件\n```sh\ndocker events\n```\n--since=\"\" 输出特定的timestamp之后的事件\n--until=\"\" 输出特定的timestamp之前的事件\n运行docker events命令，进入待机状态\n```sh\n$ docker events\n```\n在另一终端，运行容器\n```sh\n$ docker start hello #假设容器已存在\n```\n就会在刚刚的docker events 命令窗口看到 运行hello 容器的事件\n# exec 命令\n> exec命令用于从外部运行容器内部的命令\n> docker exec <选项><容器名称，id><命令><参数>\n\n-d、--detach=false 以后台模式运行命令\n-i、--interactive=false 开启标准输入，即使未与容器连接，也维持标准输入\n-t、--tty=false 使用TTY模式（pseudo-TTY）若要使用bash，则必须设置该选项。若不设置该选项，则虽然输入命令，但不显示shell\n运行如下命令，创建容器\n```sh\n$ docker run -d --name hello ubuntu /bin/bash -c \"while true; do echo Hello World; sleep 1; done\"\n设置每隔一秒输出一次hello world。在此状态下，运行容器内部的/bin/bash,连接至bash shell ，如下所示。连接bash shell 时，只有使用 -i -t 选项才能输入命令并查看结果\n$ docker exec -it hello /bin/bash  #连接容器\n$ ps ax  # 查看进程\n```\n若在容器内部运行ps ax 命令，则可以看到由docker exec 命令运行的其他/bin/bash，与输出hello world 的/bin/bash 不是同一个。输入exit命令退出Bash shell后，容器不会停止，而会继续运行。像这样，灵活使用 docker exec 命令将Bash shell 连接到正在运行守护进程的容器上，并行多种操作\n如下：不连接Bash shell，而使用apt-get等命令，在容器内安装redis-server包，\n```sh\n$ docker exec hello apt-get update\n$ docker exec hello apt-get install -y redis-server\n$ docker exec -d hello redis-server # 后台运行rides-server\n```\n# export 命令\n> export命令将用于将容器的文件系统导出为tar文件包\n\ndocker export <容器名称，id>\n只运行docker export 命令后，由于容器的内容会输出到标准输出，所以必须设置重定向\n```sh\n$ docker run -it -d --name hello ubuntu /bin/bash\n$ docker export hello > hello.tar\n```\n# history 命令\n> history 命令用于显示镜像的历史。此处的历史依据Dockerfile文件中的设置创建。\n> docker history <选项><镜像名称，id>\n\n--no-trunc=false 输出所有因内容过长而省略的部分\n-q、--quiet=false 只显示镜像id\n# images 命令\n> images命令用于输出镜像列表\n> docker images <选项><镜像名称，id>\n\n-a、--all=false 列出所有镜像，包括父镜像\n-f、--filter=[] 设置输出结果过滤。若设置为\"dangling=true\"，则只输出无名镜像\n--no-trunc=false 显示所有因内容过长而省略的部分\n# import 命令\n> import命令用于从压缩为tar文件（.tar .tar.gz .tgz .bzip .tar.xz .txz）的文件系统创建镜像\n> docker import <tar文件的URL或者 - ><注册名称>/<镜像名称>:<标签>\n\n使用import命令时，可以设置tar文件的URL，若设置为 - ，则从标准输入接收tar文件的内容。既可以使用由docker export 命令创建的tar文件，也可以直接组织文件系统。\n```sh\n$ docker import http://example.com/hello.tar.zg hello\n```\n下列命令中使用本地的 hello.tar 文件的内容通过管道传递给 docker import 命令\n```sh\n$ cat hello.tar | docker import - hello\n```\n若想将当前目录的内容直接创建为镜像：\n```sh\n$ tar -c . | docker import - hello\n```\n# info 命令\n> info命令用于显示当前系统信息、docker容器、镜像个数、设置等信息。\n\ndocker info\ninspect 命令\ninspect 命令用于以JSON格式显示容器与镜像的详细信息\ndocker inspect <选项><容器或镜像名称，id>\n-f、--format=\"\" 只显示指定信息。如：\"{{.NetworkSettings.IPAddress}}\" 使用 . 来设置JSON文档的下层项目\n下面命令显示容器的IP地址\n```sh\n$ docker run -it -d --name hello ubuntu /bin/bash\n$ docker inspect -f \"{{.NetworkSettings.IPAddress}}\" hello\n```\n下面命令只从容器的详细信息中抽取特定部分，并按照所希望的格式显示\n```sh\n$ docker run -it -d --name hello -p 8000:80 -p 8080:8080 ubuntu /bin/bash\n$ docker inspect -f '{{range $p, $conf := .NetworkSettings.Ports}} {{$p}} -> {{(index $conf 0).HostPort}} {{end}}' hello\n```\n此处使用 {{range $p, $conf := .NetworkSettings.Ports}} 循环访问 .NetworkSettings.Ports 的值，并代入 $p $conf。然后输出$p,并将$conf数组的第一项 (index $conf 0) 的 .HostPort 输出。\n另：.NetworkSettings.Ports 是一个map类型数据结构：\n map[80/tcp:[{0.0.0.0 8000}] 8080/tcp:[{0.0.0.0 8080}]]\n\n# kill 命令\n> kill命令用于向容器发送KILL信号，从而关闭容器（推荐使用更优雅温和的 docker stop 命令)\n> docker <选项><容器名称，id>\n\n-s、--signal=\"KILL\" 发送特定信号\n# load 命令\n> load命令用于从tar文件创建镜像\n> docker load <选项>\n\n将tar文件发送到 docker load 命令的标准输入，然后创建镜像。tar文件由 docker save 命令创建，包含镜像名称与标签。\n-i、--input=\"\" 不使用标准输入，设置文件路径并创建镜像。\n```sh\n$ docker save myimages > myimages.tar  #将已存在的镜像保存为tar文件\n$ docker load < myimages.tar  #在另一台电脑从tar文件创建镜像\n```sh\n#login 命令\n>login命令用于登录Docker 的注册服务器\n>docker login <选项><Docker 注册服务器的URL>\n\n若不设置注册服务器的地址，则默认登录dockerhub（api https://index.docker.io/v1/）\n-e、--email=\"\" 设置登录时使用的电子邮件\n-p、--password=\"\" 设置登录密码\n-u、--username=\"\" 设置登录时使用的账号\n# logout 命令\n> logout命令用于从Docker注册服务器中登出\n> docker logout <选项><Docker 注册服务器的URL>\n\n若不设置注册服务器的地址，则默认为dockerhub（api https://index.docker.io/v1/）\n# logs 命令\n> logs命令用于输出容器日志\n>docker logs <容器名称，id>\n\n-f、--follow=false 一直输出实时日志\n-t、--timestamp=false 在登录时显示时间值\n--tail=\"all\" 指定数字，只从日志中输出一定个数\n# port 命令\n> port命令用于查看容器的某个端口是否处于开放状态\n> docker port <容器名称，id><端口>\n\n# pause 命令\n> pause命令用于暂停容器中正在运行的所有进程\n> docker pause <容器名称，id>","slug":"Docker常用命令","published":1,"updated":"2017-09-08T10:19:34.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja39i000v44ei3ip2p3fa","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>从技术老大那里听说了docker，闲下来之后就简单了解了一下，发现真的是一个好用的不得了的工具。遂周末去图书馆找了下相关资料，学习下姿势。说不定哪天用上了呢😝。在看资料的过程中，发现有不少命令都不知道什么意思，所以干脆做了一个整理，以备以后查阅。ps：在docker命令后输入 -h 参数，可查看详细命令。我也是参照某本书上的命令整理的，也不是很全，待以后遇到了继续补充。</p>\n<blockquote>\n<p>文中 =[] 表示设置选项时可以设置不同的值，并且可以多次使用 如： -p 8000:80 -p 8080:8080<br>命令后面的 =false 表示默认值为 false =”” 表示默认值为空<br>若用户不属于docker组，可能需要sudo执行</p>\n</blockquote>\n<h1 id=\"docker基础命令\"><a href=\"#docker基础命令\" class=\"headerlink\" title=\"docker基础命令\"></a>docker基础命令</h1><blockquote>\n<p>docker &lt;选项&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p><code>--api-enable-cors=false</code> 使用API时，启用CORS（cross-origin resource sharing）<br><code>-b 、--bridge=&quot;&quot;</code> 使用事先创建的网桥接口。若设置为none，则不在容器内使用网络<br><code>--bip=&quot;&quot;</code> 使用CIDR标记法设置docker 的IP带宽。该选项不能与-b选项同时使用<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：`-bip=<span class=\"string\">\"192.168.0.0/24\"</span>`</div></pre></td></tr></table></figure></p>\n<p><code>-D 、--debug</code> 启用调试模式<br><code>-d 、--deamon=false</code> 以守护进程模式运行<br><code>--dns</code> 设置docker要使用的DNS服务器<br><code>--dns-search=[]</code> 设置docker要使用的DNS搜索域。若设置为：example.com，则向服务器查询hello时，将首先查找hello.example.com<br><code>-e、--exec-drive=&quot;native&quot;</code> 设置docker运行驱动，可设置为Native与lxc<br><code>--fixed-cidr=&quot;&quot;</code> 固定分配IPv4地址的带宽。该IP地址必须在-b选项设置的网桥网络或–bip设置的IP网段内<br><code>-G、--group=&quot;docker&quot;</code> 以守护进程模式运行时，使用-H选项创建Unix套接字后，设置该Unix套接字所在的组。使用””空字符串表示不设置分组<br><code>-g、 --graph=&quot;/var/lib/docker&quot;</code> 设置docker使用目录的顶层路径<br>-H、–host[] 以守护进程模式运行时，设置套接字路径。ls</p>\n<p>–icc=true 开启容器间通信<br>–insecure-registry=[] 使用私有证书搭建docker注册服务器时，设置docker注册服务器域名<br>–ip=0.0.0.0 使用docker run 命令时-p选项将端口暴露在外时，设置要绑定的默认IP地址<br>–ip-forward=true 开启net.ipv4.ip_forward<br>–ip-masq=true 为网桥上的IP地址开启IP伪装（masquerading）<br>–iptables=true 开启iptables规则<br>–mtu=0 设置容器的网络最大传输单元（MTU, Maxmum transmission unit）若不设置，则使用路由器的默认MTU或者设置为1500<br>-p、–pidfile=”/var/run/docker.pid” 设置PID文件路径<br>-registry-mirror=[] 设置docker registry 的镜像地址<br>-s、–storage-driver=[] 设置储存驱动，默认为auto，也可以设置为drivcemapper<br>–selinux-enabled=false开启SELinux SELinux尚不支持BTRFS储存驱动<br>–storage-opt 设置存储驱动选项<br>–tls=false 使用TLS<br>–tlscacert=”/home/exapmleuser/.docker/ca.pem” 设置要在远程证书中使用的CA证书文件的路径<br>–tlscert=”/home/exapmleuser/.docker/cert.pem” 设置证书文件路径<br>–tlskey=”/home/exapmleuser/.docker/key.pem” 设置密匙文件路径<br>tlsverify=”false” 使用TLS远程证书，守护进程与客户端全部使用证书验证<br>-v、–version=false 打印版本信息</p>\n<h1 id=\"attach命令\"><a href=\"#attach命令\" class=\"headerlink\" title=\"attach命令\"></a>attach命令</h1><blockquote>\n<p>attach命令用于将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器<br>docker attach &lt;选项&gt;&lt;容器名称, id&gt;</p>\n</blockquote>\n<p>–no-stdin=false 不连接标准输入<br>–sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样）但不传送SIGCHLD、SIGKILL、SIGSTOP信号。经常使用的信号如下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SIGINT：interrupt信号，输入Ctrl + c 时发生</div><div class=\"line\">SIGQUIT：Quit信号，输入Ctrl + \\ 时发生</div><div class=\"line\">EOF：终止attach状态，输入Ctrl + d 时发生</div></pre></td></tr></table></figure></p>\n<p>一般会先运行Bash等shell，然后使用docker attach 命令连接到容器，在运行各种命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -it --name hello ubuntu /bin/bash</div><div class=\"line\">docker attach hello</div></pre></td></tr></table></figure></p>\n<h1 id=\"build-命令\"><a href=\"#build-命令\" class=\"headerlink\" title=\"build 命令\"></a>build 命令</h1><blockquote>\n<p>build命令使用Dockerfile文件创建镜像<br>docker build &lt;选项&gt;<dockerfile路径></dockerfile路径></p>\n</blockquote>\n<p>Dockerfile 路径可以使是本地路径，也可以是URL路径。若设置为 - ，则从标准输入获取Dockerfile的内容<br>–force-rm=false 创建镜像失败时，删除临时容器<br>–no-cache=false 不使用之前构建中创建的缓存。<br>-q、–quiet=false 不显示Dockerfile的RUN运行的输出结果<br>–rm=true 创建镜像成功时，删除临时容器<br>-t、–tag=”” 设置注册名称、镜像名称、标签。格式为 &lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt;（标签默认为latest）</p>\n<h1 id=\"commit-命令\"><a href=\"#commit-命令\" class=\"headerlink\" title=\"commit 命令\"></a>commit 命令</h1><blockquote>\n<p>commit命令用于从容器的修改项创建显得镜像<br>docker commit &lt;选项&gt;&lt;容器名称，id&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-a、–author=”” 设置奖项创建者的有关信息<br>-m、–message=”” 设置有关变更事项的日志信息<br>-p、–pause=true 创建镜像是暂停容器</p>\n<h1 id=\"cp-命令\"><a href=\"#cp-命令\" class=\"headerlink\" title=\"cp 命令\"></a>cp 命令</h1><blockquote>\n<p>cp命令用于将容器的目录或文件复制的到主机。若将cp命令中的路径设置为目录，则将该目录下的所有内容复制到主机</p>\n</blockquote>\n<p>docker cp &lt;容器名称&gt;:&lt;路径&gt;&lt;主机路径&gt;<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker cp hello:/etc . 将容器内的整个/etc 目录复制到主机当前文件夹下</div></pre></td></tr></table></figure></p>\n<h1 id=\"create-命令\"><a href=\"#create-命令\" class=\"headerlink\" title=\"create 命令\"></a>create 命令</h1><blockquote>\n<p>create 命令使用指定的镜像创建容器。与run命令不同，使用create命令只能创建容器而并不启动<br>docker create &lt;选项&gt;&lt;镜像名称,id&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p>-a 、–attach=[] 将标准输入、标准输出、标准错误链接到容器<br>–attach=”stdin”</p>\n<p>–add-host=[] 向容器的/etc/hosts添加主机名与IP地址<br>–add-host=hello:192.168.0.233</p>\n<p>-C、–cpu-shares=0 设置cup资源分配。默认是这值为1024，各值为相对值<br>若设置为–cpu-shares=2048, 则分配默认值为2倍的CPU资源<br>在Linux内核的cgroups中使用该设置的值<br>–cap-add[] 设置容器中使用的cgroups的特定Capablity。若设置为ALL，则使用所有的Capablity<br>–cap-drop=[] 从容器删除cgroup的特定Capablity<br>–cidfile=”” 设置cid文件路径。cid中存储着所创建容器的id<br>–cpuset=”” 在多核CPU中设置要运行容器的核心数<br>若设置–cpuset=”0,1” 则使用第一与第二个cup<br>若这是–cupset=”0-2” 则使用从第一到第三个cup<br>–device=[] 添加主机设备到容器，格式为&lt;主机设备&gt;:&lt;容器设备&gt;<br>若设置为 –device=”/dev/sda1:/dev/sda1”,则在容器中也可以使用主机的/dev/sda1块设备</p>\n<p>–dns=[] 设置容器中要用到的DNS服务器<br>–dns-search=[] 设置docker要使用的DNS搜索域。<br>-e、–env=[] 向容器设置环境变量。一般用于传递设置或者密码<br>如：-e MYSQL_ROOT_PASSWORD=root<br>–entrypoint=”” 忽略Dockerfile的ENTRYPOINT设置，强制设置为其他值。<br>如：–entrypoint=”/bin/bash”<br>–env-file=[] 向容器应用设置环境变量文件<br>–expose=[] 仅连接容器的端口与主机，并不暴露在外<br>–expose=”3306”<br>-h、–hostname=”” 设置容器主机名<br>-i、–interactive=false 激活标准输入，即使未与容器连接（attach），也维持标准输入。一般使用该选项向Bash输入命令<br>–link=[] 进行容器连接，格式为&lt;容器名称&gt;:&lt;别名&gt;<br>–link mysql-server:mysql</p>\n<p>–lxc-conf=[] 若使用LXC驱动，则可以设置LXC选项<br>–lxc-conf=”lxc.cgroup.cpuset.cpu = 0,1”    </p>\n<p>-m、–memory=”” 设置内存限制，格式为&lt;数字&gt;&lt;单位&gt;，单位可以使用b,k,m,g<br>–memory=”512m”<br>–name 设置容器名称<br>–net=”bridge” 设置容器的网络模式（选项可以是：bridge,none,container,host）<br>-P、–publish-all=false 将连接到主机的容器的所有端口暴露在外<br>-p、–publish=[] 将连接到主机的容器的特定端口暴露在外。一般主要用于暴露web服务器的端口<br>–privileged=false 在容器内部使用主机的所有Linux内核功能<br>–restart=”” 设置容器内部进程终止时重启策略<br>–restart=no 即使进程终止也不重启<br>–restart=”on-failure” 仅当进程的Exit Code 不为0时执行重启。也可以设置重置次数。若不设置重试次数，这不断重启。如 –restart=”no-failure:10”<br>–restart=”always” 不受Exit Code的影响，总是重启<br>–security-opt=[] 设置SELinux、AppArmor 选项<br>-t、–tty=false 使用TTY模式（pseudo-TTY）。若要使用Bash，则必须设置该选项。若不设置该选项，则可以输入命令，但不显示shell<br>-u、–user=”” 设置容器运行时要使用的Linux用户账户与UID<br>-v、–volume=[] 设置数据卷。设置要与主机共享目录，不将文件保存到容器，而直接保存到主机。在主机目录后添加 :ro、:rw进行读写设置，默认为:rw。<br>–volumes-from=[] 连接数据卷容器，设置格式为&lt;容器名，id&gt;:&lt;:ro, :rw&gt; 默认情形下，读写设置遵从-v选项的设置。<br>-w、–workdir=”” 设置容器内部要运行进程的目录<br>运行如下命令，创建容器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker create -it --name hello ubuntu /bin/bash</div><div class=\"line\">若想使用刚刚创建的容器，则必须使用docker start 命令启动容器</div><div class=\"line\">$ docker start hello</div><div class=\"line\">进入容器内部</div><div class=\"line\">$ docker attach hello</div><div class=\"line\">···</div><div class=\"line\"><span class=\"comment\"># diff 命令</span></div><div class=\"line\">&gt; diff命令用于检查容器文件系统的修改</div><div class=\"line\">&gt; docker diff &lt;容器名称，id&gt;</div><div class=\"line\"></div><div class=\"line\">比较文件是否修改的标准是容器创建时的镜像内容</div><div class=\"line\">A：添加的文件</div><div class=\"line\">C：修改的文件</div><div class=\"line\">D：删除的文件</div><div class=\"line\"><span class=\"comment\"># events 命令</span></div><div class=\"line\">&gt; events命令用于实时输出Docker服务器中发生的事件</div><div class=\"line\">```sh</div><div class=\"line\">docker events</div></pre></td></tr></table></figure></p>\n<p>–since=”” 输出特定的timestamp之后的事件<br>–until=”” 输出特定的timestamp之前的事件<br>运行docker events命令，进入待机状态<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker events</div></pre></td></tr></table></figure></p>\n<p>在另一终端，运行容器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker start hello <span class=\"comment\">#假设容器已存在</span></div></pre></td></tr></table></figure></p>\n<p>就会在刚刚的docker events 命令窗口看到 运行hello 容器的事件</p>\n<h1 id=\"exec-命令\"><a href=\"#exec-命令\" class=\"headerlink\" title=\"exec 命令\"></a>exec 命令</h1><blockquote>\n<p>exec命令用于从外部运行容器内部的命令<br>docker exec &lt;选项&gt;&lt;容器名称，id&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p>-d、–detach=false 以后台模式运行命令<br>-i、–interactive=false 开启标准输入，即使未与容器连接，也维持标准输入<br>-t、–tty=false 使用TTY模式（pseudo-TTY）若要使用bash，则必须设置该选项。若不设置该选项，则虽然输入命令，但不显示shell<br>运行如下命令，创建容器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run <span class=\"_\">-d</span> --name hello ubuntu /bin/bash -c <span class=\"string\">\"while true; do echo Hello World; sleep 1; done\"</span></div><div class=\"line\">设置每隔一秒输出一次hello world。在此状态下，运行容器内部的/bin/bash,连接至bash shell ，如下所示。连接bash shell 时，只有使用 -i -t 选项才能输入命令并查看结果</div><div class=\"line\">$ docker <span class=\"built_in\">exec</span> -it hello /bin/bash  <span class=\"comment\">#连接容器</span></div><div class=\"line\">$ ps ax  <span class=\"comment\"># 查看进程</span></div></pre></td></tr></table></figure></p>\n<p>若在容器内部运行ps ax 命令，则可以看到由docker exec 命令运行的其他/bin/bash，与输出hello world 的/bin/bash 不是同一个。输入exit命令退出Bash shell后，容器不会停止，而会继续运行。像这样，灵活使用 docker exec 命令将Bash shell 连接到正在运行守护进程的容器上，并行多种操作<br>如下：不连接Bash shell，而使用apt-get等命令，在容器内安装redis-server包，<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker <span class=\"built_in\">exec</span> hello apt-get update</div><div class=\"line\">$ docker <span class=\"built_in\">exec</span> hello apt-get install -y redis-server</div><div class=\"line\">$ docker <span class=\"built_in\">exec</span> <span class=\"_\">-d</span> hello redis-server <span class=\"comment\"># 后台运行rides-server</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"export-命令\"><a href=\"#export-命令\" class=\"headerlink\" title=\"export 命令\"></a>export 命令</h1><blockquote>\n<p>export命令将用于将容器的文件系统导出为tar文件包</p>\n</blockquote>\n<p>docker export &lt;容器名称，id&gt;<br>只运行docker export 命令后，由于容器的内容会输出到标准输出，所以必须设置重定向<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run -it <span class=\"_\">-d</span> --name hello ubuntu /bin/bash</div><div class=\"line\">$ docker <span class=\"built_in\">export</span> hello &gt; hello.tar</div></pre></td></tr></table></figure></p>\n<h1 id=\"history-命令\"><a href=\"#history-命令\" class=\"headerlink\" title=\"history 命令\"></a>history 命令</h1><blockquote>\n<p>history 命令用于显示镜像的历史。此处的历史依据Dockerfile文件中的设置创建。<br>docker history &lt;选项&gt;&lt;镜像名称，id&gt;</p>\n</blockquote>\n<p>–no-trunc=false 输出所有因内容过长而省略的部分<br>-q、–quiet=false 只显示镜像id</p>\n<h1 id=\"images-命令\"><a href=\"#images-命令\" class=\"headerlink\" title=\"images 命令\"></a>images 命令</h1><blockquote>\n<p>images命令用于输出镜像列表<br>docker images &lt;选项&gt;&lt;镜像名称，id&gt;</p>\n</blockquote>\n<p>-a、–all=false 列出所有镜像，包括父镜像<br>-f、–filter=[] 设置输出结果过滤。若设置为”dangling=true”，则只输出无名镜像<br>–no-trunc=false 显示所有因内容过长而省略的部分</p>\n<h1 id=\"import-命令\"><a href=\"#import-命令\" class=\"headerlink\" title=\"import 命令\"></a>import 命令</h1><blockquote>\n<p>import命令用于从压缩为tar文件（.tar .tar.gz .tgz .bzip .tar.xz .txz）的文件系统创建镜像<br>docker import <tar文件的url或者 -=\"\">&lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</tar文件的url或者></p>\n</blockquote>\n<p>使用import命令时，可以设置tar文件的URL，若设置为 - ，则从标准输入接收tar文件的内容。既可以使用由docker export 命令创建的tar文件，也可以直接组织文件系统。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker import http://example.com/hello.tar.zg hello</div></pre></td></tr></table></figure></p>\n<p>下列命令中使用本地的 hello.tar 文件的内容通过管道传递给 docker import 命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cat hello.tar | docker import - hello</div></pre></td></tr></table></figure></p>\n<p>若想将当前目录的内容直接创建为镜像：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tar -c . | docker import - hello</div></pre></td></tr></table></figure></p>\n<h1 id=\"info-命令\"><a href=\"#info-命令\" class=\"headerlink\" title=\"info 命令\"></a>info 命令</h1><blockquote>\n<p>info命令用于显示当前系统信息、docker容器、镜像个数、设置等信息。</p>\n</blockquote>\n<p>docker info<br>inspect 命令<br>inspect 命令用于以JSON格式显示容器与镜像的详细信息<br>docker inspect &lt;选项&gt;&lt;容器或镜像名称，id&gt;<br>-f、–format=”” 只显示指定信息。如：”{{.NetworkSettings.IPAddress}}“ 使用 . 来设置JSON文档的下层项目<br>下面命令显示容器的IP地址<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run -it <span class=\"_\">-d</span> --name hello ubuntu /bin/bash</div><div class=\"line\">$ docker inspect <span class=\"_\">-f</span> <span class=\"string\">\"&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;\"</span> hello</div></pre></td></tr></table></figure></p>\n<p>下面命令只从容器的详细信息中抽取特定部分，并按照所希望的格式显示<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run -it <span class=\"_\">-d</span> --name hello -p 8000:80 -p 8080:8080 ubuntu /bin/bash</div><div class=\"line\">$ docker inspect <span class=\"_\">-f</span> <span class=\"string\">'&#123;&#123;range $p, $conf := .NetworkSettings.Ports&#125;&#125; &#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;(index $conf 0).HostPort&#125;&#125; &#123;&#123;end&#125;&#125;'</span> hello</div></pre></td></tr></table></figure></p>\n<p>此处使用 {{range $p, $conf := .NetworkSettings.Ports}} 循环访问 .NetworkSettings.Ports 的值，并代入 $p $conf。然后输出$p,并将$conf数组的第一项 (index $conf 0) 的 .HostPort 输出。<br>另：.NetworkSettings.Ports 是一个map类型数据结构：<br> map[80/tcp:[{0.0.0.0 8000}] 8080/tcp:[{0.0.0.0 8080}]]</p>\n<h1 id=\"kill-命令\"><a href=\"#kill-命令\" class=\"headerlink\" title=\"kill 命令\"></a>kill 命令</h1><blockquote>\n<p>kill命令用于向容器发送KILL信号，从而关闭容器（推荐使用更优雅温和的 docker stop 命令)<br>docker &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-s、–signal=”KILL” 发送特定信号</p>\n<h1 id=\"load-命令\"><a href=\"#load-命令\" class=\"headerlink\" title=\"load 命令\"></a>load 命令</h1><blockquote>\n<p>load命令用于从tar文件创建镜像<br>docker load &lt;选项&gt;</p>\n</blockquote>\n<p>将tar文件发送到 docker load 命令的标准输入，然后创建镜像。tar文件由 docker save 命令创建，包含镜像名称与标签。<br>-i、–input=”” 不使用标准输入，设置文件路径并创建镜像。<br><code>sh\n$ docker save myimages &gt; myimages.tar  #将已存在的镜像保存为tar文件\n$ docker load &lt; myimages.tar  #在另一台电脑从tar文件创建镜像</code>sh</p>\n<p>#login 命令</p>\n<blockquote>\n<p>login命令用于登录Docker 的注册服务器<br>docker login &lt;选项&gt;<docker 注册服务器的url=\"\"></docker></p>\n</blockquote>\n<p>若不设置注册服务器的地址，则默认登录dockerhub（api <a href=\"https://index.docker.io/v1/）\" target=\"_blank\" rel=\"external\">https://index.docker.io/v1/）</a><br>-e、–email=”” 设置登录时使用的电子邮件<br>-p、–password=”” 设置登录密码<br>-u、–username=”” 设置登录时使用的账号</p>\n<h1 id=\"logout-命令\"><a href=\"#logout-命令\" class=\"headerlink\" title=\"logout 命令\"></a>logout 命令</h1><blockquote>\n<p>logout命令用于从Docker注册服务器中登出<br>docker logout &lt;选项&gt;<docker 注册服务器的url=\"\"></docker></p>\n</blockquote>\n<p>若不设置注册服务器的地址，则默认为dockerhub（api <a href=\"https://index.docker.io/v1/）\" target=\"_blank\" rel=\"external\">https://index.docker.io/v1/）</a></p>\n<h1 id=\"logs-命令\"><a href=\"#logs-命令\" class=\"headerlink\" title=\"logs 命令\"></a>logs 命令</h1><blockquote>\n<p>logs命令用于输出容器日志<br>docker logs &lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-f、–follow=false 一直输出实时日志<br>-t、–timestamp=false 在登录时显示时间值<br>–tail=”all” 指定数字，只从日志中输出一定个数</p>\n<h1 id=\"port-命令\"><a href=\"#port-命令\" class=\"headerlink\" title=\"port 命令\"></a>port 命令</h1><blockquote>\n<p>port命令用于查看容器的某个端口是否处于开放状态<br>docker port &lt;容器名称，id&gt;&lt;端口&gt;</p>\n</blockquote>\n<h1 id=\"pause-命令\"><a href=\"#pause-命令\" class=\"headerlink\" title=\"pause 命令\"></a>pause 命令</h1><blockquote>\n<p>pause命令用于暂停容器中正在运行的所有进程<br>docker pause &lt;容器名称，id&gt;</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>从技术老大那里听说了docker，闲下来之后就简单了解了一下，发现真的是一个好用的不得了的工具。遂周末去图书馆找了下相关资料，学习下姿势。说不定哪天用上了呢😝。在看资料的过程中，发现有不少命令都不知道什么意思，所以干脆做了一个整理，以备以后查阅。ps：在docker命令后输入 -h 参数，可查看详细命令。我也是参照某本书上的命令整理的，也不是很全，待以后遇到了继续补充。</p>\n<blockquote>\n<p>文中 =[] 表示设置选项时可以设置不同的值，并且可以多次使用 如： -p 8000:80 -p 8080:8080<br>命令后面的 =false 表示默认值为 false =”” 表示默认值为空<br>若用户不属于docker组，可能需要sudo执行</p>\n</blockquote>\n<h1 id=\"docker基础命令\"><a href=\"#docker基础命令\" class=\"headerlink\" title=\"docker基础命令\"></a>docker基础命令</h1><blockquote>\n<p>docker &lt;选项&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p><code>--api-enable-cors=false</code> 使用API时，启用CORS（cross-origin resource sharing）<br><code>-b 、--bridge=&quot;&quot;</code> 使用事先创建的网桥接口。若设置为none，则不在容器内使用网络<br><code>--bip=&quot;&quot;</code> 使用CIDR标记法设置docker 的IP带宽。该选项不能与-b选项同时使用<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">如：`-bip=<span class=\"string\">\"192.168.0.0/24\"</span>`</div></pre></td></tr></table></figure></p>\n<p><code>-D 、--debug</code> 启用调试模式<br><code>-d 、--deamon=false</code> 以守护进程模式运行<br><code>--dns</code> 设置docker要使用的DNS服务器<br><code>--dns-search=[]</code> 设置docker要使用的DNS搜索域。若设置为：example.com，则向服务器查询hello时，将首先查找hello.example.com<br><code>-e、--exec-drive=&quot;native&quot;</code> 设置docker运行驱动，可设置为Native与lxc<br><code>--fixed-cidr=&quot;&quot;</code> 固定分配IPv4地址的带宽。该IP地址必须在-b选项设置的网桥网络或–bip设置的IP网段内<br><code>-G、--group=&quot;docker&quot;</code> 以守护进程模式运行时，使用-H选项创建Unix套接字后，设置该Unix套接字所在的组。使用””空字符串表示不设置分组<br><code>-g、 --graph=&quot;/var/lib/docker&quot;</code> 设置docker使用目录的顶层路径<br>-H、–host[] 以守护进程模式运行时，设置套接字路径。ls</p>\n<p>–icc=true 开启容器间通信<br>–insecure-registry=[] 使用私有证书搭建docker注册服务器时，设置docker注册服务器域名<br>–ip=0.0.0.0 使用docker run 命令时-p选项将端口暴露在外时，设置要绑定的默认IP地址<br>–ip-forward=true 开启net.ipv4.ip_forward<br>–ip-masq=true 为网桥上的IP地址开启IP伪装（masquerading）<br>–iptables=true 开启iptables规则<br>–mtu=0 设置容器的网络最大传输单元（MTU, Maxmum transmission unit）若不设置，则使用路由器的默认MTU或者设置为1500<br>-p、–pidfile=”/var/run/docker.pid” 设置PID文件路径<br>-registry-mirror=[] 设置docker registry 的镜像地址<br>-s、–storage-driver=[] 设置储存驱动，默认为auto，也可以设置为drivcemapper<br>–selinux-enabled=false开启SELinux SELinux尚不支持BTRFS储存驱动<br>–storage-opt 设置存储驱动选项<br>–tls=false 使用TLS<br>–tlscacert=”/home/exapmleuser/.docker/ca.pem” 设置要在远程证书中使用的CA证书文件的路径<br>–tlscert=”/home/exapmleuser/.docker/cert.pem” 设置证书文件路径<br>–tlskey=”/home/exapmleuser/.docker/key.pem” 设置密匙文件路径<br>tlsverify=”false” 使用TLS远程证书，守护进程与客户端全部使用证书验证<br>-v、–version=false 打印版本信息</p>\n<h1 id=\"attach命令\"><a href=\"#attach命令\" class=\"headerlink\" title=\"attach命令\"></a>attach命令</h1><blockquote>\n<p>attach命令用于将标准输入（stdin）与标准输出（stdout）连接到正在运行的容器<br>docker attach &lt;选项&gt;&lt;容器名称, id&gt;</p>\n</blockquote>\n<p>–no-stdin=false 不连接标准输入<br>–sig-proxy=true 将所有信号传递给进程（非TTY模式时也一样）但不传送SIGCHLD、SIGKILL、SIGSTOP信号。经常使用的信号如下：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SIGINT：interrupt信号，输入Ctrl + c 时发生</div><div class=\"line\">SIGQUIT：Quit信号，输入Ctrl + \\ 时发生</div><div class=\"line\">EOF：终止attach状态，输入Ctrl + d 时发生</div></pre></td></tr></table></figure></p>\n<p>一般会先运行Bash等shell，然后使用docker attach 命令连接到容器，在运行各种命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker run -it --name hello ubuntu /bin/bash</div><div class=\"line\">docker attach hello</div></pre></td></tr></table></figure></p>\n<h1 id=\"build-命令\"><a href=\"#build-命令\" class=\"headerlink\" title=\"build 命令\"></a>build 命令</h1><blockquote>\n<p>build命令使用Dockerfile文件创建镜像<br>docker build &lt;选项&gt;<dockerfile路径></dockerfile路径></p>\n</blockquote>\n<p>Dockerfile 路径可以使是本地路径，也可以是URL路径。若设置为 - ，则从标准输入获取Dockerfile的内容<br>–force-rm=false 创建镜像失败时，删除临时容器<br>–no-cache=false 不使用之前构建中创建的缓存。<br>-q、–quiet=false 不显示Dockerfile的RUN运行的输出结果<br>–rm=true 创建镜像成功时，删除临时容器<br>-t、–tag=”” 设置注册名称、镜像名称、标签。格式为 &lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt;（标签默认为latest）</p>\n<h1 id=\"commit-命令\"><a href=\"#commit-命令\" class=\"headerlink\" title=\"commit 命令\"></a>commit 命令</h1><blockquote>\n<p>commit命令用于从容器的修改项创建显得镜像<br>docker commit &lt;选项&gt;&lt;容器名称，id&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</p>\n</blockquote>\n<p>-a、–author=”” 设置奖项创建者的有关信息<br>-m、–message=”” 设置有关变更事项的日志信息<br>-p、–pause=true 创建镜像是暂停容器</p>\n<h1 id=\"cp-命令\"><a href=\"#cp-命令\" class=\"headerlink\" title=\"cp 命令\"></a>cp 命令</h1><blockquote>\n<p>cp命令用于将容器的目录或文件复制的到主机。若将cp命令中的路径设置为目录，则将该目录下的所有内容复制到主机</p>\n</blockquote>\n<p>docker cp &lt;容器名称&gt;:&lt;路径&gt;&lt;主机路径&gt;<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker cp hello:/etc . 将容器内的整个/etc 目录复制到主机当前文件夹下</div></pre></td></tr></table></figure></p>\n<h1 id=\"create-命令\"><a href=\"#create-命令\" class=\"headerlink\" title=\"create 命令\"></a>create 命令</h1><blockquote>\n<p>create 命令使用指定的镜像创建容器。与run命令不同，使用create命令只能创建容器而并不启动<br>docker create &lt;选项&gt;&lt;镜像名称,id&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p>-a 、–attach=[] 将标准输入、标准输出、标准错误链接到容器<br>–attach=”stdin”</p>\n<p>–add-host=[] 向容器的/etc/hosts添加主机名与IP地址<br>–add-host=hello:192.168.0.233</p>\n<p>-C、–cpu-shares=0 设置cup资源分配。默认是这值为1024，各值为相对值<br>若设置为–cpu-shares=2048, 则分配默认值为2倍的CPU资源<br>在Linux内核的cgroups中使用该设置的值<br>–cap-add[] 设置容器中使用的cgroups的特定Capablity。若设置为ALL，则使用所有的Capablity<br>–cap-drop=[] 从容器删除cgroup的特定Capablity<br>–cidfile=”” 设置cid文件路径。cid中存储着所创建容器的id<br>–cpuset=”” 在多核CPU中设置要运行容器的核心数<br>若设置–cpuset=”0,1” 则使用第一与第二个cup<br>若这是–cupset=”0-2” 则使用从第一到第三个cup<br>–device=[] 添加主机设备到容器，格式为&lt;主机设备&gt;:&lt;容器设备&gt;<br>若设置为 –device=”/dev/sda1:/dev/sda1”,则在容器中也可以使用主机的/dev/sda1块设备</p>\n<p>–dns=[] 设置容器中要用到的DNS服务器<br>–dns-search=[] 设置docker要使用的DNS搜索域。<br>-e、–env=[] 向容器设置环境变量。一般用于传递设置或者密码<br>如：-e MYSQL_ROOT_PASSWORD=root<br>–entrypoint=”” 忽略Dockerfile的ENTRYPOINT设置，强制设置为其他值。<br>如：–entrypoint=”/bin/bash”<br>–env-file=[] 向容器应用设置环境变量文件<br>–expose=[] 仅连接容器的端口与主机，并不暴露在外<br>–expose=”3306”<br>-h、–hostname=”” 设置容器主机名<br>-i、–interactive=false 激活标准输入，即使未与容器连接（attach），也维持标准输入。一般使用该选项向Bash输入命令<br>–link=[] 进行容器连接，格式为&lt;容器名称&gt;:&lt;别名&gt;<br>–link mysql-server:mysql</p>\n<p>–lxc-conf=[] 若使用LXC驱动，则可以设置LXC选项<br>–lxc-conf=”lxc.cgroup.cpuset.cpu = 0,1”    </p>\n<p>-m、–memory=”” 设置内存限制，格式为&lt;数字&gt;&lt;单位&gt;，单位可以使用b,k,m,g<br>–memory=”512m”<br>–name 设置容器名称<br>–net=”bridge” 设置容器的网络模式（选项可以是：bridge,none,container,host）<br>-P、–publish-all=false 将连接到主机的容器的所有端口暴露在外<br>-p、–publish=[] 将连接到主机的容器的特定端口暴露在外。一般主要用于暴露web服务器的端口<br>–privileged=false 在容器内部使用主机的所有Linux内核功能<br>–restart=”” 设置容器内部进程终止时重启策略<br>–restart=no 即使进程终止也不重启<br>–restart=”on-failure” 仅当进程的Exit Code 不为0时执行重启。也可以设置重置次数。若不设置重试次数，这不断重启。如 –restart=”no-failure:10”<br>–restart=”always” 不受Exit Code的影响，总是重启<br>–security-opt=[] 设置SELinux、AppArmor 选项<br>-t、–tty=false 使用TTY模式（pseudo-TTY）。若要使用Bash，则必须设置该选项。若不设置该选项，则可以输入命令，但不显示shell<br>-u、–user=”” 设置容器运行时要使用的Linux用户账户与UID<br>-v、–volume=[] 设置数据卷。设置要与主机共享目录，不将文件保存到容器，而直接保存到主机。在主机目录后添加 :ro、:rw进行读写设置，默认为:rw。<br>–volumes-from=[] 连接数据卷容器，设置格式为&lt;容器名，id&gt;:&lt;:ro, :rw&gt; 默认情形下，读写设置遵从-v选项的设置。<br>-w、–workdir=”” 设置容器内部要运行进程的目录<br>运行如下命令，创建容器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker create -it --name hello ubuntu /bin/bash</div><div class=\"line\">若想使用刚刚创建的容器，则必须使用docker start 命令启动容器</div><div class=\"line\">$ docker start hello</div><div class=\"line\">进入容器内部</div><div class=\"line\">$ docker attach hello</div><div class=\"line\">···</div><div class=\"line\"><span class=\"comment\"># diff 命令</span></div><div class=\"line\">&gt; diff命令用于检查容器文件系统的修改</div><div class=\"line\">&gt; docker diff &lt;容器名称，id&gt;</div><div class=\"line\"></div><div class=\"line\">比较文件是否修改的标准是容器创建时的镜像内容</div><div class=\"line\">A：添加的文件</div><div class=\"line\">C：修改的文件</div><div class=\"line\">D：删除的文件</div><div class=\"line\"><span class=\"comment\"># events 命令</span></div><div class=\"line\">&gt; events命令用于实时输出Docker服务器中发生的事件</div><div class=\"line\">```sh</div><div class=\"line\">docker events</div></pre></td></tr></table></figure></p>\n<p>–since=”” 输出特定的timestamp之后的事件<br>–until=”” 输出特定的timestamp之前的事件<br>运行docker events命令，进入待机状态<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker events</div></pre></td></tr></table></figure></p>\n<p>在另一终端，运行容器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker start hello <span class=\"comment\">#假设容器已存在</span></div></pre></td></tr></table></figure></p>\n<p>就会在刚刚的docker events 命令窗口看到 运行hello 容器的事件</p>\n<h1 id=\"exec-命令\"><a href=\"#exec-命令\" class=\"headerlink\" title=\"exec 命令\"></a>exec 命令</h1><blockquote>\n<p>exec命令用于从外部运行容器内部的命令<br>docker exec &lt;选项&gt;&lt;容器名称，id&gt;&lt;命令&gt;&lt;参数&gt;</p>\n</blockquote>\n<p>-d、–detach=false 以后台模式运行命令<br>-i、–interactive=false 开启标准输入，即使未与容器连接，也维持标准输入<br>-t、–tty=false 使用TTY模式（pseudo-TTY）若要使用bash，则必须设置该选项。若不设置该选项，则虽然输入命令，但不显示shell<br>运行如下命令，创建容器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run <span class=\"_\">-d</span> --name hello ubuntu /bin/bash -c <span class=\"string\">\"while true; do echo Hello World; sleep 1; done\"</span></div><div class=\"line\">设置每隔一秒输出一次hello world。在此状态下，运行容器内部的/bin/bash,连接至bash shell ，如下所示。连接bash shell 时，只有使用 -i -t 选项才能输入命令并查看结果</div><div class=\"line\">$ docker <span class=\"built_in\">exec</span> -it hello /bin/bash  <span class=\"comment\">#连接容器</span></div><div class=\"line\">$ ps ax  <span class=\"comment\"># 查看进程</span></div></pre></td></tr></table></figure></p>\n<p>若在容器内部运行ps ax 命令，则可以看到由docker exec 命令运行的其他/bin/bash，与输出hello world 的/bin/bash 不是同一个。输入exit命令退出Bash shell后，容器不会停止，而会继续运行。像这样，灵活使用 docker exec 命令将Bash shell 连接到正在运行守护进程的容器上，并行多种操作<br>如下：不连接Bash shell，而使用apt-get等命令，在容器内安装redis-server包，<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker <span class=\"built_in\">exec</span> hello apt-get update</div><div class=\"line\">$ docker <span class=\"built_in\">exec</span> hello apt-get install -y redis-server</div><div class=\"line\">$ docker <span class=\"built_in\">exec</span> <span class=\"_\">-d</span> hello redis-server <span class=\"comment\"># 后台运行rides-server</span></div></pre></td></tr></table></figure></p>\n<h1 id=\"export-命令\"><a href=\"#export-命令\" class=\"headerlink\" title=\"export 命令\"></a>export 命令</h1><blockquote>\n<p>export命令将用于将容器的文件系统导出为tar文件包</p>\n</blockquote>\n<p>docker export &lt;容器名称，id&gt;<br>只运行docker export 命令后，由于容器的内容会输出到标准输出，所以必须设置重定向<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run -it <span class=\"_\">-d</span> --name hello ubuntu /bin/bash</div><div class=\"line\">$ docker <span class=\"built_in\">export</span> hello &gt; hello.tar</div></pre></td></tr></table></figure></p>\n<h1 id=\"history-命令\"><a href=\"#history-命令\" class=\"headerlink\" title=\"history 命令\"></a>history 命令</h1><blockquote>\n<p>history 命令用于显示镜像的历史。此处的历史依据Dockerfile文件中的设置创建。<br>docker history &lt;选项&gt;&lt;镜像名称，id&gt;</p>\n</blockquote>\n<p>–no-trunc=false 输出所有因内容过长而省略的部分<br>-q、–quiet=false 只显示镜像id</p>\n<h1 id=\"images-命令\"><a href=\"#images-命令\" class=\"headerlink\" title=\"images 命令\"></a>images 命令</h1><blockquote>\n<p>images命令用于输出镜像列表<br>docker images &lt;选项&gt;&lt;镜像名称，id&gt;</p>\n</blockquote>\n<p>-a、–all=false 列出所有镜像，包括父镜像<br>-f、–filter=[] 设置输出结果过滤。若设置为”dangling=true”，则只输出无名镜像<br>–no-trunc=false 显示所有因内容过长而省略的部分</p>\n<h1 id=\"import-命令\"><a href=\"#import-命令\" class=\"headerlink\" title=\"import 命令\"></a>import 命令</h1><blockquote>\n<p>import命令用于从压缩为tar文件（.tar .tar.gz .tgz .bzip .tar.xz .txz）的文件系统创建镜像<br>docker import <tar文件的url或者 -=\"\">&lt;注册名称&gt;/&lt;镜像名称&gt;:&lt;标签&gt;</tar文件的url或者></p>\n</blockquote>\n<p>使用import命令时，可以设置tar文件的URL，若设置为 - ，则从标准输入接收tar文件的内容。既可以使用由docker export 命令创建的tar文件，也可以直接组织文件系统。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker import http://example.com/hello.tar.zg hello</div></pre></td></tr></table></figure></p>\n<p>下列命令中使用本地的 hello.tar 文件的内容通过管道传递给 docker import 命令<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cat hello.tar | docker import - hello</div></pre></td></tr></table></figure></p>\n<p>若想将当前目录的内容直接创建为镜像：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ tar -c . | docker import - hello</div></pre></td></tr></table></figure></p>\n<h1 id=\"info-命令\"><a href=\"#info-命令\" class=\"headerlink\" title=\"info 命令\"></a>info 命令</h1><blockquote>\n<p>info命令用于显示当前系统信息、docker容器、镜像个数、设置等信息。</p>\n</blockquote>\n<p>docker info<br>inspect 命令<br>inspect 命令用于以JSON格式显示容器与镜像的详细信息<br>docker inspect &lt;选项&gt;&lt;容器或镜像名称，id&gt;<br>-f、–format=”” 只显示指定信息。如：”{{.NetworkSettings.IPAddress}}“ 使用 . 来设置JSON文档的下层项目<br>下面命令显示容器的IP地址<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run -it <span class=\"_\">-d</span> --name hello ubuntu /bin/bash</div><div class=\"line\">$ docker inspect <span class=\"_\">-f</span> <span class=\"string\">\"&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;\"</span> hello</div></pre></td></tr></table></figure></p>\n<p>下面命令只从容器的详细信息中抽取特定部分，并按照所希望的格式显示<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ docker run -it <span class=\"_\">-d</span> --name hello -p 8000:80 -p 8080:8080 ubuntu /bin/bash</div><div class=\"line\">$ docker inspect <span class=\"_\">-f</span> <span class=\"string\">'&#123;&#123;range $p, $conf := .NetworkSettings.Ports&#125;&#125; &#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;(index $conf 0).HostPort&#125;&#125; &#123;&#123;end&#125;&#125;'</span> hello</div></pre></td></tr></table></figure></p>\n<p>此处使用 {{range $p, $conf := .NetworkSettings.Ports}} 循环访问 .NetworkSettings.Ports 的值，并代入 $p $conf。然后输出$p,并将$conf数组的第一项 (index $conf 0) 的 .HostPort 输出。<br>另：.NetworkSettings.Ports 是一个map类型数据结构：<br> map[80/tcp:[{0.0.0.0 8000}] 8080/tcp:[{0.0.0.0 8080}]]</p>\n<h1 id=\"kill-命令\"><a href=\"#kill-命令\" class=\"headerlink\" title=\"kill 命令\"></a>kill 命令</h1><blockquote>\n<p>kill命令用于向容器发送KILL信号，从而关闭容器（推荐使用更优雅温和的 docker stop 命令)<br>docker &lt;选项&gt;&lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-s、–signal=”KILL” 发送特定信号</p>\n<h1 id=\"load-命令\"><a href=\"#load-命令\" class=\"headerlink\" title=\"load 命令\"></a>load 命令</h1><blockquote>\n<p>load命令用于从tar文件创建镜像<br>docker load &lt;选项&gt;</p>\n</blockquote>\n<p>将tar文件发送到 docker load 命令的标准输入，然后创建镜像。tar文件由 docker save 命令创建，包含镜像名称与标签。<br>-i、–input=”” 不使用标准输入，设置文件路径并创建镜像。<br><code>sh\n$ docker save myimages &gt; myimages.tar  #将已存在的镜像保存为tar文件\n$ docker load &lt; myimages.tar  #在另一台电脑从tar文件创建镜像</code>sh</p>\n<p>#login 命令</p>\n<blockquote>\n<p>login命令用于登录Docker 的注册服务器<br>docker login &lt;选项&gt;<docker 注册服务器的url=\"\"></docker></p>\n</blockquote>\n<p>若不设置注册服务器的地址，则默认登录dockerhub（api <a href=\"https://index.docker.io/v1/）\" target=\"_blank\" rel=\"external\">https://index.docker.io/v1/）</a><br>-e、–email=”” 设置登录时使用的电子邮件<br>-p、–password=”” 设置登录密码<br>-u、–username=”” 设置登录时使用的账号</p>\n<h1 id=\"logout-命令\"><a href=\"#logout-命令\" class=\"headerlink\" title=\"logout 命令\"></a>logout 命令</h1><blockquote>\n<p>logout命令用于从Docker注册服务器中登出<br>docker logout &lt;选项&gt;<docker 注册服务器的url=\"\"></docker></p>\n</blockquote>\n<p>若不设置注册服务器的地址，则默认为dockerhub（api <a href=\"https://index.docker.io/v1/）\" target=\"_blank\" rel=\"external\">https://index.docker.io/v1/）</a></p>\n<h1 id=\"logs-命令\"><a href=\"#logs-命令\" class=\"headerlink\" title=\"logs 命令\"></a>logs 命令</h1><blockquote>\n<p>logs命令用于输出容器日志<br>docker logs &lt;容器名称，id&gt;</p>\n</blockquote>\n<p>-f、–follow=false 一直输出实时日志<br>-t、–timestamp=false 在登录时显示时间值<br>–tail=”all” 指定数字，只从日志中输出一定个数</p>\n<h1 id=\"port-命令\"><a href=\"#port-命令\" class=\"headerlink\" title=\"port 命令\"></a>port 命令</h1><blockquote>\n<p>port命令用于查看容器的某个端口是否处于开放状态<br>docker port &lt;容器名称，id&gt;&lt;端口&gt;</p>\n</blockquote>\n<h1 id=\"pause-命令\"><a href=\"#pause-命令\" class=\"headerlink\" title=\"pause 命令\"></a>pause 命令</h1><blockquote>\n<p>pause命令用于暂停容器中正在运行的所有进程<br>docker pause &lt;容器名称，id&gt;</p>\n</blockquote>\n"},{"title":"VPS搭建自己的的Hexo博客","date":"2016-06-20T07:05:37.000Z","_content":"首先声明：本文转载于作者：WensonSmith的文章，版权归原作者所有。这篇博客只作为自己维护Hexo博客系统做个记录。原文地址https://segmentfault.com/a/1190000005723321\n\n# 博客的架构\n先搞明白Hexo博客从搭建到自动发布的架构，才能更好的理解我们每一步进行的操作。不然只跟着步骤过了一遍，却不知道为什么这么做。首先看这张架构图：\n![架构图](https://sfault-image.b0.upaiyun.com/194/667/194667281-5760cfced0e4f_articlex)\n整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。\n\n# 整个搭建流程\n第一部分: 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户 。\n第二部分: 本地Hexo初始化， 包括安装 NodeJS 、hexo-cli, 生成本地静态网站\n第三部分: 使用Git自动化部署发布博客\n\n# 服务器环境搭建\n## 安装Git和NodeJS (CentOS 环境)\n```sh\nyum install git\n#安装NodeJS\ncurl --silent --location https://rpm.nodesource.com/setup_5.x | bash -\n```\nNodeJS 安装可以参考： Linux安装NodeJS\n\n## 创建git用户\n```sh\nadduser git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n找到以下内容\n```sh\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)     ALL\n```\n在下面添加一行\n```sh\ngit ALL=(ALL) ALL\n```\n保存退出后改回权限\n```sh\nchmod 400 /etc/sudoers\n```\n随后设置Git用户的密码，\n```sh\n#需要root权限\nsudo passwd git\n```\n切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限\n```sh\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n#然后将电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到authorized_keys\nchmod 600 ~/.ssh/authorzied_keys\nchmod 700 ~/.ssh\n```\n然后就可以执行ssh 命令测试是否可以免密登录\n```sh\nssh -v git@SERVER\n```\n至此，Git用户添加完成\n\n## Nginx安装和配置\n我是用的是lnmp 一键安装包，nginx安装教程一大堆，就不再叙述。主要看nginx配置。找到nginx的配置文件，修改配置如下：\n```\nserver\n{\n    listen 80;\n    #listen [::]:80;\n    server_name www.seekbetter.me seekbetter.me;\n    index index.html index.htm index.php default.html default.htm default.php;\n    #这里要改成网站的根目录\n    root  /path/to/www;  \n\n    include other.conf;\n    #error_page   404   /404.html;\n    location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$\n    {\n        access_log   off;\n        expires      1d;\n    }\n\n    location ~ .*\\.(js|css|txt|xml)?$\n    {\n        access_log   off;\n        expires      12h;\n    }\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n\n    access_log  /home/wwwlogs/blog.log  access;\n}\n```\n\n# 本地Hexo程序\n## 初始化Hexo博客\n首先要安装 hexo-cli，安装hexo-cli 需要 root 权限，使用 sudo 运行\n```sh\nsudo npm install -g hexo-cli\n```\n然后初始化Hexo程序\n```sh\ncd ~/Documents/code\nhexo init blog\n```\n等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。\n\n[hexo-deployer-git帮助文档](https://github.com/hexojs/hexo-deployer-git)\n[hexo-server帮助文档](https://hexo.io/zh-cn/docs/server.html)\n```sh\ncd blog\nnpm install hexo-deployer-git --save\nnpm install hero-server\n```\n## 生成自己的第一篇文章 hello world !\n使用 hexo new <文章名称> 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。\n```sh\nhexo new \"hello Hexo\"\nvim sources/_posts/hello-hexo.md\n```\n编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo-server：\n```sh\nhexo g\nhexo server\n```\n现在便可以打开浏览器访问 http://localhost:4000 来查看我们的博客了！\n\n# 自动化部署\n## 服务器上建立git裸库\n创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权\n一定要加 --bare，这样才是一个裸库。\n```sh\nsu git\ncd ~\ngit init --bare blog.git\n```\n\n## 使用 git-hooks 同步网站根目录\n在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，\n新建post-receive文件。\n```sh\nvim ~/blog.git/hooks/post-receive\n\n#!/bin/sh\ngit --work-tree=/path/to/www --git-dir=~/blog.git checkout -f\n```\n保存后，要赋予这个文件可执行权限\n```sh\nchmod +x post-receive\n```\n## 配置_config.yml,完成自动化部署\n然后打开 _config.yml, 找到 deploy\n```\ndeploy:\n    type: git\n    repo: git@SERVER:/home/git/blog.git    //<repository url>\n    branch: master            //这里填写分支   [branch]\n    message: 提交的信息         //自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})\n```\n保存后，尝试将我们刚才写的\"hello hexo\"部署到服务器\n```sh\nhexo clean\nhexo generate --deploy\n```\n访问服务器地址，就可以看到我们写的文章\"Hello hexo\",以后写文章只需要：\n```sh\nhexo new \"Blog article name\"\n···写文章\nhexo clean && hexo generate --deploy\n```","source":"_posts/VPS搭建自己的的Hexo博客.md","raw":"---\ntitle: VPS搭建自己的的Hexo博客\ndate: 2016-06-20 15:05:37\ncategories:\n  杂记\ntags:\n  - Hexo\n---\n首先声明：本文转载于作者：WensonSmith的文章，版权归原作者所有。这篇博客只作为自己维护Hexo博客系统做个记录。原文地址https://segmentfault.com/a/1190000005723321\n\n# 博客的架构\n先搞明白Hexo博客从搭建到自动发布的架构，才能更好的理解我们每一步进行的操作。不然只跟着步骤过了一遍，却不知道为什么这么做。首先看这张架构图：\n![架构图](https://sfault-image.b0.upaiyun.com/194/667/194667281-5760cfced0e4f_articlex)\n整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。\n\n# 整个搭建流程\n第一部分: 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户 。\n第二部分: 本地Hexo初始化， 包括安装 NodeJS 、hexo-cli, 生成本地静态网站\n第三部分: 使用Git自动化部署发布博客\n\n# 服务器环境搭建\n## 安装Git和NodeJS (CentOS 环境)\n```sh\nyum install git\n#安装NodeJS\ncurl --silent --location https://rpm.nodesource.com/setup_5.x | bash -\n```\nNodeJS 安装可以参考： Linux安装NodeJS\n\n## 创建git用户\n```sh\nadduser git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n找到以下内容\n```sh\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)     ALL\n```\n在下面添加一行\n```sh\ngit ALL=(ALL) ALL\n```\n保存退出后改回权限\n```sh\nchmod 400 /etc/sudoers\n```\n随后设置Git用户的密码，\n```sh\n#需要root权限\nsudo passwd git\n```\n切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限\n```sh\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n#然后将电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到authorized_keys\nchmod 600 ~/.ssh/authorzied_keys\nchmod 700 ~/.ssh\n```\n然后就可以执行ssh 命令测试是否可以免密登录\n```sh\nssh -v git@SERVER\n```\n至此，Git用户添加完成\n\n## Nginx安装和配置\n我是用的是lnmp 一键安装包，nginx安装教程一大堆，就不再叙述。主要看nginx配置。找到nginx的配置文件，修改配置如下：\n```\nserver\n{\n    listen 80;\n    #listen [::]:80;\n    server_name www.seekbetter.me seekbetter.me;\n    index index.html index.htm index.php default.html default.htm default.php;\n    #这里要改成网站的根目录\n    root  /path/to/www;  \n\n    include other.conf;\n    #error_page   404   /404.html;\n    location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$\n    {\n        access_log   off;\n        expires      1d;\n    }\n\n    location ~ .*\\.(js|css|txt|xml)?$\n    {\n        access_log   off;\n        expires      12h;\n    }\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n\n    access_log  /home/wwwlogs/blog.log  access;\n}\n```\n\n# 本地Hexo程序\n## 初始化Hexo博客\n首先要安装 hexo-cli，安装hexo-cli 需要 root 权限，使用 sudo 运行\n```sh\nsudo npm install -g hexo-cli\n```\n然后初始化Hexo程序\n```sh\ncd ~/Documents/code\nhexo init blog\n```\n等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。\n\n[hexo-deployer-git帮助文档](https://github.com/hexojs/hexo-deployer-git)\n[hexo-server帮助文档](https://hexo.io/zh-cn/docs/server.html)\n```sh\ncd blog\nnpm install hexo-deployer-git --save\nnpm install hero-server\n```\n## 生成自己的第一篇文章 hello world !\n使用 hexo new <文章名称> 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。\n```sh\nhexo new \"hello Hexo\"\nvim sources/_posts/hello-hexo.md\n```\n编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo-server：\n```sh\nhexo g\nhexo server\n```\n现在便可以打开浏览器访问 http://localhost:4000 来查看我们的博客了！\n\n# 自动化部署\n## 服务器上建立git裸库\n创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权\n一定要加 --bare，这样才是一个裸库。\n```sh\nsu git\ncd ~\ngit init --bare blog.git\n```\n\n## 使用 git-hooks 同步网站根目录\n在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，\n新建post-receive文件。\n```sh\nvim ~/blog.git/hooks/post-receive\n\n#!/bin/sh\ngit --work-tree=/path/to/www --git-dir=~/blog.git checkout -f\n```\n保存后，要赋予这个文件可执行权限\n```sh\nchmod +x post-receive\n```\n## 配置_config.yml,完成自动化部署\n然后打开 _config.yml, 找到 deploy\n```\ndeploy:\n    type: git\n    repo: git@SERVER:/home/git/blog.git    //<repository url>\n    branch: master            //这里填写分支   [branch]\n    message: 提交的信息         //自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }})\n```\n保存后，尝试将我们刚才写的\"hello hexo\"部署到服务器\n```sh\nhexo clean\nhexo generate --deploy\n```\n访问服务器地址，就可以看到我们写的文章\"Hello hexo\",以后写文章只需要：\n```sh\nhexo new \"Blog article name\"\n···写文章\nhexo clean && hexo generate --deploy\n```","slug":"VPS搭建自己的的Hexo博客","published":1,"updated":"2017-09-08T10:16:53.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja39o001044eii2yxndiz","content":"<p>首先声明：本文转载于作者：WensonSmith的文章，版权归原作者所有。这篇博客只作为自己维护Hexo博客系统做个记录。原文地址<a href=\"https://segmentfault.com/a/1190000005723321\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000005723321</a></p>\n<h1 id=\"博客的架构\"><a href=\"#博客的架构\" class=\"headerlink\" title=\"博客的架构\"></a>博客的架构</h1><p>先搞明白Hexo博客从搭建到自动发布的架构，才能更好的理解我们每一步进行的操作。不然只跟着步骤过了一遍，却不知道为什么这么做。首先看这张架构图：<br><img src=\"https://sfault-image.b0.upaiyun.com/194/667/194667281-5760cfced0e4f_articlex\" alt=\"架构图\"><br>整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。</p>\n<h1 id=\"整个搭建流程\"><a href=\"#整个搭建流程\" class=\"headerlink\" title=\"整个搭建流程\"></a>整个搭建流程</h1><p>第一部分: 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户 。<br>第二部分: 本地Hexo初始化， 包括安装 NodeJS 、hexo-cli, 生成本地静态网站<br>第三部分: 使用Git自动化部署发布博客</p>\n<h1 id=\"服务器环境搭建\"><a href=\"#服务器环境搭建\" class=\"headerlink\" title=\"服务器环境搭建\"></a>服务器环境搭建</h1><h2 id=\"安装Git和NodeJS-CentOS-环境\"><a href=\"#安装Git和NodeJS-CentOS-环境\" class=\"headerlink\" title=\"安装Git和NodeJS (CentOS 环境)\"></a>安装Git和NodeJS (CentOS 环境)</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install git</div><div class=\"line\"><span class=\"comment\">#安装NodeJS</span></div><div class=\"line\">curl --silent --location https://rpm.nodesource.com/setup_5.x | bash -</div></pre></td></tr></table></figure>\n<p>NodeJS 安装可以参考： Linux安装NodeJS</p>\n<h2 id=\"创建git用户\"><a href=\"#创建git用户\" class=\"headerlink\" title=\"创建git用户\"></a>创建git用户</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">adduser git</div><div class=\"line\">chmod 740 /etc/sudoers</div><div class=\"line\">vim /etc/sudoers</div></pre></td></tr></table></figure>\n<p>找到以下内容<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">## Allow root to run any commands anywhere</span></div><div class=\"line\">root    ALL=(ALL)     ALL</div></pre></td></tr></table></figure></p>\n<p>在下面添加一行<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git ALL=(ALL) ALL</div></pre></td></tr></table></figure></p>\n<p>保存退出后改回权限<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod 400 /etc/sudoers</div></pre></td></tr></table></figure></p>\n<p>随后设置Git用户的密码，<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#需要root权限</span></div><div class=\"line\">sudo passwd git</div></pre></td></tr></table></figure></p>\n<p>切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">su git</div><div class=\"line\">mkdir ~/.ssh</div><div class=\"line\">vim ~/.ssh/authorized_keys</div><div class=\"line\"><span class=\"comment\">#然后将电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到authorized_keys</span></div><div class=\"line\">chmod 600 ~/.ssh/authorzied_keys</div><div class=\"line\">chmod 700 ~/.ssh</div></pre></td></tr></table></figure></p>\n<p>然后就可以执行ssh 命令测试是否可以免密登录<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -v git@SERVER</div></pre></td></tr></table></figure></p>\n<p>至此，Git用户添加完成</p>\n<h2 id=\"Nginx安装和配置\"><a href=\"#Nginx安装和配置\" class=\"headerlink\" title=\"Nginx安装和配置\"></a>Nginx安装和配置</h2><p>我是用的是lnmp 一键安装包，nginx安装教程一大堆，就不再叙述。主要看nginx配置。找到nginx的配置文件，修改配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">    listen 80;</div><div class=\"line\">    #listen [::]:80;</div><div class=\"line\">    server_name www.seekbetter.me seekbetter.me;</div><div class=\"line\">    index index.html index.htm index.php default.html default.htm default.php;</div><div class=\"line\">    #这里要改成网站的根目录</div><div class=\"line\">    root  /path/to/www;  </div><div class=\"line\"></div><div class=\"line\">    include other.conf;</div><div class=\"line\">    #error_page   404   /404.html;</div><div class=\"line\">    location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$</div><div class=\"line\">    &#123;</div><div class=\"line\">        access_log   off;</div><div class=\"line\">        expires      1d;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ .*\\.(js|css|txt|xml)?$</div><div class=\"line\">    &#123;</div><div class=\"line\">        access_log   off;</div><div class=\"line\">        expires      12h;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location / &#123;</div><div class=\"line\">        try_files $uri $uri/ =404;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    access_log  /home/wwwlogs/blog.log  access;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"本地Hexo程序\"><a href=\"#本地Hexo程序\" class=\"headerlink\" title=\"本地Hexo程序\"></a>本地Hexo程序</h1><h2 id=\"初始化Hexo博客\"><a href=\"#初始化Hexo博客\" class=\"headerlink\" title=\"初始化Hexo博客\"></a>初始化Hexo博客</h2><p>首先要安装 hexo-cli，安装hexo-cli 需要 root 权限，使用 sudo 运行<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<p>然后初始化Hexo程序<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ~/Documents/code</div><div class=\"line\">hexo init blog</div></pre></td></tr></table></figure></p>\n<p>等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。</p>\n<p><a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"external\">hexo-deployer-git帮助文档</a><br><a href=\"https://hexo.io/zh-cn/docs/server.html\" target=\"_blank\" rel=\"external\">hexo-server帮助文档</a><br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> blog</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">npm install hero-server</div></pre></td></tr></table></figure></p>\n<h2 id=\"生成自己的第一篇文章-hello-world\"><a href=\"#生成自己的第一篇文章-hello-world\" class=\"headerlink\" title=\"生成自己的第一篇文章 hello world !\"></a>生成自己的第一篇文章 hello world !</h2><p>使用 hexo new &lt;文章名称&gt; 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new <span class=\"string\">\"hello Hexo\"</span></div><div class=\"line\">vim sources/_posts/hello-hexo.md</div></pre></td></tr></table></figure></p>\n<p>编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo-server：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>现在便可以打开浏览器访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 来查看我们的博客了！</p>\n<h1 id=\"自动化部署\"><a href=\"#自动化部署\" class=\"headerlink\" title=\"自动化部署\"></a>自动化部署</h1><h2 id=\"服务器上建立git裸库\"><a href=\"#服务器上建立git裸库\" class=\"headerlink\" title=\"服务器上建立git裸库\"></a>服务器上建立git裸库</h2><p>创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权<br>一定要加 –bare，这样才是一个裸库。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">su git</div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\">git init --bare blog.git</div></pre></td></tr></table></figure></p>\n<h2 id=\"使用-git-hooks-同步网站根目录\"><a href=\"#使用-git-hooks-同步网站根目录\" class=\"headerlink\" title=\"使用 git-hooks 同步网站根目录\"></a>使用 git-hooks 同步网站根目录</h2><p>在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，<br>新建post-receive文件。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim ~/blog.git/hooks/post-receive</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#!/bin/sh</span></div><div class=\"line\">git --work-tree=/path/to/www --git-dir=~/blog.git checkout <span class=\"_\">-f</span></div></pre></td></tr></table></figure></p>\n<p>保存后，要赋予这个文件可执行权限<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x post-receive</div></pre></td></tr></table></figure></p>\n<h2 id=\"配置-config-yml-完成自动化部署\"><a href=\"#配置-config-yml-完成自动化部署\" class=\"headerlink\" title=\"配置_config.yml,完成自动化部署\"></a>配置_config.yml,完成自动化部署</h2><p>然后打开 _config.yml, 找到 deploy<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">    type: git</div><div class=\"line\">    repo: git@SERVER:/home/git/blog.git    //&lt;repository url&gt;</div><div class=\"line\">    branch: master            //这里填写分支   [branch]</div><div class=\"line\">    message: 提交的信息         //自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;)</div></pre></td></tr></table></figure></p>\n<p>保存后，尝试将我们刚才写的”hello hexo”部署到服务器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate --deploy</div></pre></td></tr></table></figure></p>\n<p>访问服务器地址，就可以看到我们写的文章”Hello hexo”,以后写文章只需要：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new <span class=\"string\">\"Blog article name\"</span></div><div class=\"line\">···写文章</div><div class=\"line\">hexo clean &amp;&amp; hexo generate --deploy</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先声明：本文转载于作者：WensonSmith的文章，版权归原作者所有。这篇博客只作为自己维护Hexo博客系统做个记录。原文地址<a href=\"https://segmentfault.com/a/1190000005723321\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000005723321</a></p>\n<h1 id=\"博客的架构\"><a href=\"#博客的架构\" class=\"headerlink\" title=\"博客的架构\"></a>博客的架构</h1><p>先搞明白Hexo博客从搭建到自动发布的架构，才能更好的理解我们每一步进行的操作。不然只跟着步骤过了一遍，却不知道为什么这么做。首先看这张架构图：<br><img src=\"https://sfault-image.b0.upaiyun.com/194/667/194667281-5760cfced0e4f_articlex\" alt=\"架构图\"><br>整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。</p>\n<h1 id=\"整个搭建流程\"><a href=\"#整个搭建流程\" class=\"headerlink\" title=\"整个搭建流程\"></a>整个搭建流程</h1><p>第一部分: 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户 。<br>第二部分: 本地Hexo初始化， 包括安装 NodeJS 、hexo-cli, 生成本地静态网站<br>第三部分: 使用Git自动化部署发布博客</p>\n<h1 id=\"服务器环境搭建\"><a href=\"#服务器环境搭建\" class=\"headerlink\" title=\"服务器环境搭建\"></a>服务器环境搭建</h1><h2 id=\"安装Git和NodeJS-CentOS-环境\"><a href=\"#安装Git和NodeJS-CentOS-环境\" class=\"headerlink\" title=\"安装Git和NodeJS (CentOS 环境)\"></a>安装Git和NodeJS (CentOS 环境)</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">yum install git</div><div class=\"line\"><span class=\"comment\">#安装NodeJS</span></div><div class=\"line\">curl --silent --location https://rpm.nodesource.com/setup_5.x | bash -</div></pre></td></tr></table></figure>\n<p>NodeJS 安装可以参考： Linux安装NodeJS</p>\n<h2 id=\"创建git用户\"><a href=\"#创建git用户\" class=\"headerlink\" title=\"创建git用户\"></a>创建git用户</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">adduser git</div><div class=\"line\">chmod 740 /etc/sudoers</div><div class=\"line\">vim /etc/sudoers</div></pre></td></tr></table></figure>\n<p>找到以下内容<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">## Allow root to run any commands anywhere</span></div><div class=\"line\">root    ALL=(ALL)     ALL</div></pre></td></tr></table></figure></p>\n<p>在下面添加一行<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git ALL=(ALL) ALL</div></pre></td></tr></table></figure></p>\n<p>保存退出后改回权限<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod 400 /etc/sudoers</div></pre></td></tr></table></figure></p>\n<p>随后设置Git用户的密码，<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#需要root权限</span></div><div class=\"line\">sudo passwd git</div></pre></td></tr></table></figure></p>\n<p>切换至git用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件，并赋予相应的权限<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">su git</div><div class=\"line\">mkdir ~/.ssh</div><div class=\"line\">vim ~/.ssh/authorized_keys</div><div class=\"line\"><span class=\"comment\">#然后将电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy ,将公钥复制粘贴到authorized_keys</span></div><div class=\"line\">chmod 600 ~/.ssh/authorzied_keys</div><div class=\"line\">chmod 700 ~/.ssh</div></pre></td></tr></table></figure></p>\n<p>然后就可以执行ssh 命令测试是否可以免密登录<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">ssh -v git@SERVER</div></pre></td></tr></table></figure></p>\n<p>至此，Git用户添加完成</p>\n<h2 id=\"Nginx安装和配置\"><a href=\"#Nginx安装和配置\" class=\"headerlink\" title=\"Nginx安装和配置\"></a>Nginx安装和配置</h2><p>我是用的是lnmp 一键安装包，nginx安装教程一大堆，就不再叙述。主要看nginx配置。找到nginx的配置文件，修改配置如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">    listen 80;</div><div class=\"line\">    #listen [::]:80;</div><div class=\"line\">    server_name www.seekbetter.me seekbetter.me;</div><div class=\"line\">    index index.html index.htm index.php default.html default.htm default.php;</div><div class=\"line\">    #这里要改成网站的根目录</div><div class=\"line\">    root  /path/to/www;  </div><div class=\"line\"></div><div class=\"line\">    include other.conf;</div><div class=\"line\">    #error_page   404   /404.html;</div><div class=\"line\">    location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$</div><div class=\"line\">    &#123;</div><div class=\"line\">        access_log   off;</div><div class=\"line\">        expires      1d;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ .*\\.(js|css|txt|xml)?$</div><div class=\"line\">    &#123;</div><div class=\"line\">        access_log   off;</div><div class=\"line\">        expires      12h;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location / &#123;</div><div class=\"line\">        try_files $uri $uri/ =404;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    access_log  /home/wwwlogs/blog.log  access;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"本地Hexo程序\"><a href=\"#本地Hexo程序\" class=\"headerlink\" title=\"本地Hexo程序\"></a>本地Hexo程序</h1><h2 id=\"初始化Hexo博客\"><a href=\"#初始化Hexo博客\" class=\"headerlink\" title=\"初始化Hexo博客\"></a>初始化Hexo博客</h2><p>首先要安装 hexo-cli，安装hexo-cli 需要 root 权限，使用 sudo 运行<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<p>然后初始化Hexo程序<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ~/Documents/code</div><div class=\"line\">hexo init blog</div></pre></td></tr></table></figure></p>\n<p>等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。</p>\n<p><a href=\"https://github.com/hexojs/hexo-deployer-git\" target=\"_blank\" rel=\"external\">hexo-deployer-git帮助文档</a><br><a href=\"https://hexo.io/zh-cn/docs/server.html\" target=\"_blank\" rel=\"external\">hexo-server帮助文档</a><br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> blog</div><div class=\"line\">npm install hexo-deployer-git --save</div><div class=\"line\">npm install hero-server</div></pre></td></tr></table></figure></p>\n<h2 id=\"生成自己的第一篇文章-hello-world\"><a href=\"#生成自己的第一篇文章-hello-world\" class=\"headerlink\" title=\"生成自己的第一篇文章 hello world !\"></a>生成自己的第一篇文章 hello world !</h2><p>使用 hexo new &lt;文章名称&gt; 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new <span class=\"string\">\"hello Hexo\"</span></div><div class=\"line\">vim sources/_posts/hello-hexo.md</div></pre></td></tr></table></figure></p>\n<p>编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo-server：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo g</div><div class=\"line\">hexo server</div></pre></td></tr></table></figure></p>\n<p>现在便可以打开浏览器访问 <a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 来查看我们的博客了！</p>\n<h1 id=\"自动化部署\"><a href=\"#自动化部署\" class=\"headerlink\" title=\"自动化部署\"></a>自动化部署</h1><h2 id=\"服务器上建立git裸库\"><a href=\"#服务器上建立git裸库\" class=\"headerlink\" title=\"服务器上建立git裸库\"></a>服务器上建立git裸库</h2><p>创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到git用户确保git用户拥有仓库所有权<br>一定要加 –bare，这样才是一个裸库。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">su git</div><div class=\"line\"><span class=\"built_in\">cd</span> ~</div><div class=\"line\">git init --bare blog.git</div></pre></td></tr></table></figure></p>\n<h2 id=\"使用-git-hooks-同步网站根目录\"><a href=\"#使用-git-hooks-同步网站根目录\" class=\"headerlink\" title=\"使用 git-hooks 同步网站根目录\"></a>使用 git-hooks 同步网站根目录</h2><p>在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，<br>新建post-receive文件。<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">vim ~/blog.git/hooks/post-receive</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#!/bin/sh</span></div><div class=\"line\">git --work-tree=/path/to/www --git-dir=~/blog.git checkout <span class=\"_\">-f</span></div></pre></td></tr></table></figure></p>\n<p>保存后，要赋予这个文件可执行权限<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chmod +x post-receive</div></pre></td></tr></table></figure></p>\n<h2 id=\"配置-config-yml-完成自动化部署\"><a href=\"#配置-config-yml-完成自动化部署\" class=\"headerlink\" title=\"配置_config.yml,完成自动化部署\"></a>配置_config.yml,完成自动化部署</h2><p>然后打开 _config.yml, 找到 deploy<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">    type: git</div><div class=\"line\">    repo: git@SERVER:/home/git/blog.git    //&lt;repository url&gt;</div><div class=\"line\">    branch: master            //这里填写分支   [branch]</div><div class=\"line\">    message: 提交的信息         //自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;)</div></pre></td></tr></table></figure></p>\n<p>保存后，尝试将我们刚才写的”hello hexo”部署到服务器<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo clean</div><div class=\"line\">hexo generate --deploy</div></pre></td></tr></table></figure></p>\n<p>访问服务器地址，就可以看到我们写的文章”Hello hexo”,以后写文章只需要：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo new <span class=\"string\">\"Blog article name\"</span></div><div class=\"line\">···写文章</div><div class=\"line\">hexo clean &amp;&amp; hexo generate --deploy</div></pre></td></tr></table></figure></p>\n"},{"title":"pom.xml详解","date":"2016-03-12T07:05:37.000Z","_content":"# 什么是POM？\nPOM是项目对项目模型（Project Object Model）的简称，它是Maven项目中的文件，使用xml表示，名称是pom.xml。作用类似ant的build.xml文件，功能更强大。该文件用于管理：源码、配置文件、开发者信息和角色、问题追踪系统、组织信息、项目授权、项目url、项目依赖关系等等。事实上，在Maven世界中。project可以什么都没有，甚至没有代码，但是必须包含一个pom.xml文件。\n\n# POM基本结构\n下面是一个POM项目中的pom.xml文件中包含的元素：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n            http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <!-- 基本设置 The Basics -->\n    <groupId>...</groupId>\n    <artifactId>...</artifactId>\n    <version>...</version>\n    <packaging>...</packaging>\n    <dependencies>...</dependencies>\n    <parent>...</parent>\n    <dependencyManagement>...</dependencyManagement>\n    <modules>...</modules>\n    <properties>...</properties>\n    \n    <!-- 构建过程的设置 Build Settings -->\n    <build>...</build>\n    <reporting>...</reporting>\n    \n    <!-- 项目信息设置 More Project Information -->\n    <name>...</name>\n    <description>...</description>\n    <url>...</url>\n    <inceptionYear>...</inceptionYear>\n    <licenses>...</licenses>\n    <organization>...</organization>\n    <developers>...</developers>\n    <contributors>...</contributors>\n    \n    <!-- 环境设置 Environment Settings -->\n    <issueManagement>...</issueManagement>\n    <ciManagement>...</ciManagement>\n    <mailingLists>...</mailingLists>\n    <scm>...</scm>\n    <prerequisites>...</prerequisites>\n    <repositories>...</repositories>\n    <pluginRepositories>...</pluginRepositories>\n    <distributionManagement>...</distributionManagement>\n    <profiles>...</profiles>\n</project>\n````\n# 基本配置\n一个简单的pom.xml文件需要包含modelVersion、groupId、artifactId和version四个元素，当然这其中的元素也可以从它的父项目中继承的，在Maven中，使用groupId、artfactId和version组成groupdId:artifactId:version的形式来唯一确定一个项目“\n````java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0  \n\t\t                     http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\t<!-- \n        含义：组织标识，定义了项目属于哪个组,或者说若把本项目打包\n        用途：此名称则是本地仓库中的路径，列如：com.zhkui，在XX目录下，将是: com/zhkui/目录\n        命名规范:项目名称，模块，子模块\n    -->\n\t<groupId>com.zhkui</groupId>\n\t<!-- \n        含义：项目名称也可以说你所模块名称，定义当面Maven项目在组中唯一的ID\n        用途：例如：utils，在XX目录下，将是：com/zhkui/utils目录\n        命名规范:唯一就好\n    -->\n\t<artifactId>utils</artifactId>\n\t <!-- \n        含义：项目当前的版本号\n        用途：例如：0.0.1-SNAPSHOT，在XX目录下，将是：com/zhkui/utils/0.0.1-SNAPSHOT目录\n    -->\n\t<version>0.0.1-SNAPSHOT</version>\n\t    <!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par -->\n    <packaging>war</packaging>\n    <!-- 元素声明了一个对用户更为友好的项目名称 -->\n    <name>maven</name>\n</project>\n````\n# POM之间的继承、聚合、依赖\n我们知道Maven在建立项目的时候是基于Maven项目下的pom.xml进行的，我们羡慕的依赖信息和一些基本信息都在这个文件里面定义的。那如果当面有多个项目要进行，这些项目有一些项目配置是一样的，这些相同的信息无数次的重复。特别难以维护。是个时候就用到了POM的继承和聚合功能。\n对应使用面向对象语言的程序员，继承这个词都不会陌生。其实在POM定义的时候就定义了一个超级pom.xml文件，在问没有声明自己的父pom.xml的时候，我们的pom.xml默认继承这个超级pom.xml。\n\n超级pom.xml：\n````java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed to the Apache Software Foundation (ASF) under one\nor more contributor license agreements.  See the NOTICE file\ndistributed with this work for additional information\nregarding copyright ownership.  The ASF licenses this file\nto you under the Apache License, Version 2.0 (the\n\"License\"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n-->\n\n<!-- START SNIPPET: superpom -->\n<project>\n  <modelVersion>4.0.0</modelVersion>\n\n  <repositories>\n    <repository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n    </repository>\n  </repositories>\n\n  <pluginRepositories>\n    <pluginRepository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <updatePolicy>never</updatePolicy>\n      </releases>\n    </pluginRepository>\n  </pluginRepositories>\n\n  <build>\n    <directory>${project.basedir}/target</directory>\n    <outputDirectory>${project.build.directory}/classes</outputDirectory>\n    <finalName>${project.artifactId}-${project.version}</finalName>\n    <testOutputDirectory>${project.build.directory}/test-classes</testOutputDirectory>\n    <sourceDirectory>${project.basedir}/src/main/java</sourceDirectory>\n    <scriptSourceDirectory>${project.basedir}/src/main/scripts</scriptSourceDirectory>\n    <testSourceDirectory>${project.basedir}/src/test/java</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>${project.basedir}/src/main/resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>${project.basedir}/src/test/resources</directory>\n      </testResource>\n    </testResources>\n    <pluginManagement>\n      <!-- NOTE: These plugins will be removed from future versions of the super POM -->\n      <!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-antrun-plugin</artifactId>\n          <version>1.3</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-assembly-plugin</artifactId>\n          <version>2.2-beta-5</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-dependency-plugin</artifactId>\n          <version>2.8</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-release-plugin</artifactId>\n          <version>2.3.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n\n  <reporting>\n    <outputDirectory>${project.build.directory}/site</outputDirectory>\n  </reporting>\n\n  <profiles>\n    <!-- NOTE: The release profile will be removed from future versions of the super POM -->\n    <profile>\n      <id>release-profile</id>\n\n      <activation>\n        <property>\n          <name>performRelease</name>\n          <value>true</value>\n        </property>\n      </activation>\n\n      <build>\n        <plugins>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-source-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-sources</id>\n                <goals>\n                  <goal>jar</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-javadoc-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-javadocs</id>\n                <goals>\n                  <goal>jar</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-deploy-plugin</artifactId>\n            <configuration>\n              <updateReleaseInfo>true</updateReleaseInfo>\n            </configuration>\n          </plugin>\n        </plugins>\n      </build>\n    </profile>\n  </profiles>\n\n</project>\n<!-- END SNIPPET: superpom -->\n````\n对于一个pom.xml来说有几个元素是必须定义的，一个是project根元素，然后就是它里面的modelVersion、groupId、artifactId和version。由上面的超级pom.xml的内容我们可以看到pom.xml中没有groupId、artifactId和version的定义，所以我们在建立自己的pom.xml的时候就需要定义这三个元素。和java里面的继承类似，子pom.xml会完全继承父pom.xml中所有的元素，而且对于相同的元素，一般子pom.xml中的会覆盖父pom.xml中的元素，但是有几个特殊的元素它们会进行合并而不是覆盖。这些特殊的元素是：\ndependencies\ndevelopers\ncontributors\nplugin列表，包括plugin下面的reports\nresources\n# 继承\n## 被继承项目与继承项目是父子目录关系\n假设我们有一个项目porjectA，它的pom.xml定义如下：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>    \n  <version>1.0-SNAPSHOT</version>  \n</project>\n````\n现在有一个项目projectB，而且projectB是projectA的子目录中，如果projectB要继承项目projectA的pom.xml文件。项目projectB的pom.xml文件定义如下：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">  \n  <parent>  \n    <groupId>com.zhkui.util</groupId>  \n    <artifactId>projectA</artifactId>  \n    <version>1.0-SNAPSHOT</version>  \n  </parent>  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <packaging>jar</packaging>  \n  <version>1.0-SNAPSHOT</version>  \n</project>\n````\n通过projectB的pom.xml文件定义可以知道，当需要继承一个指定Maven项目时，需要在自己的pom.xml中定义一个parent元素。在这个元素中指明需要继承项目的groupId、artifactId、version。\n\n## 被继承项目与继承项目的目录结构不是父子关系\n当被继承项目与继承项目的目录结构不是父子关系的时候，我们再利用上面的配置是不能实现Maven项目的继承关系的，这个时候我们就需要在子项目的pom.xml文件定义中的parent元素下再加上一个relativePath元素的定义，用以描述父项目的pom.xml文件相对于子项目的pom.xml文件的位置。\n假设我们现在还是有上面两个项目，projectA和projectB，projectB还是继承自projectA，但是现在projectB不在projectA的子目录中，而是与projectA处于同一目录中。这个时候projectA和projectB的目录结构如下：\n------projectA\n　------pom.xml\n------projectB\n　------pom.xml\n这个时候我们可以看出projectA的pom.xml相对于projectB的pom.xml的位置是“../projectA/pom.xml”，所以这个时候projectB的pom.xml的定义应该如下所示：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">  \n  <parent>  \n    <groupId>com.zhkui.util</groupId>  \n    <artifactId>projectA</artifactId>  \n    <version>1.0-SNAPSHOT</version>  \n       <relativePath>../projectA/pom.xml</relativePath>  \n  </parent>  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n</project>\n````\n# 聚合\n对于聚合这个概念搞java的人应该都不会陌生。先来说说我对聚合和被聚合的理解，比如说如果projectA聚合到projectB，那么我们就可以说projectA是projectB的子模块， projectB是被聚合项目，也可以类似于继承那样称为父项目。对于聚合而言，这个主体应该是被聚合的项目。所以，我们需要在被聚合的项目中定义它的子模块，而不是像继承那样在子项目中定义父项目。具体做法是：\n修改被聚合项目的pom.xml中的packaging元素的值为pom\n在被聚合项目的pom.xml中的modules元素下指定它的子模块项目\n对于聚合而言，当我们在被聚合的项目上使用Maven命令时，实际上这些命令都会在它的子模块项目上使用。这就是Maven中聚合的一个非常重要的作用。假设这样一种情况，你同时需要打包或者编译projectA、projectB、projectC和projectD，按照正常的逻辑我们一个一个项目去使用mvn compile或mvn package进行编译和打包，对于使用Maven而言，你还是这样使用的话是非常麻烦的。因为Maven给我们提供了聚合的功能。我们只需要再定义一个超级项目，然后在超级项目的pom.xml中定义这个几个项目都是聚合到这个超级项目的。之后我们只需要对这个超级项目进行mvn compile，它就会把那些子模块项目都进行编译。\n## 6.1 被聚合项目和子模块项目在目录结构上是父子关系\n还拿上面定义的projectA和projectB来举例，现在假设我们需要把projectB聚合到projectA中。projectA和projectB的目录结构如下所示：\n------projectA\n　　------projectB\n　　　　-----pom.xml\n　　------pom.xml\n这个时候projectA的pom.xml应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <modules>  \n       <module>projectB</module>  \n  </modules>  \n</project>\n````\n从上面的定义我们可知道被聚合的项目的packaging类型应该为pom，而且一个项目可以有多个子模块项目。对于聚合这种情况，我们使用子模块项目的artifactId来作为module的值，表示子模块项目相对于被聚合项目的地址，在上面的示例中就表示子模块projectB是处在被聚合项目的子目录下，即与被聚合项目的pom.xml处于同一目录。这里使用的module值是子模块projectB对应的目录名projectB，而不是子模块对应的artifactId。这个时候当我们对projectA进行mvn package命令时，实际上Maven也会对projectB进行打包。\n## 被聚合项目与子模块项目在目录结构上不是父子关系\n那么当被聚合项目与子模块项目在目录结构上不是父子关系的时候，我们应该怎么来进行聚合呢？还是像继承那样使用relativePath元素吗？答案是非也，具体做法是在module元素中指定以相对路径的方式指定子模块。我们来看下面一个例子。\n继续使用上面的projectA和projectB，还是需要把projectB聚合到projectA，但是projectA和projectB的目录结构不再是父子关系，而是如下所示的这种关系：\n------projectA\n    -----pom.xml\n------projectB\n　　------pom.xml\n这个时候projectA的pom.xml文件就应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <modules>  \n       <module>../projectB</module>  \n  </modules>  \n</project>\n````\n注意看module的值是“../projectB”，我们知道“..”是代表当前目录的上层目录，所以它表示子模块projectB是被聚合项目projectA的pom.xml文件所在目录（即projectA）的上层目录下面的子目录，即与projectA处于同一目录层次。注意，这里的projectB对应的是projectB这个项目的目录名称，而不是它的artifactId。\n\n## 聚合与继承同时进行\n假设有这样一种情况，有两个项目，projectA和projectB，现在我们需要projectB继承projectA，同时需要把projectB聚合到projectA。然后projectA和projectB的目录结构如下：\n------projectA\n    ------pom.xml\n------projectB\n    ------pom.xml\n那么这个时候按照上面说的那样，projectA的pom.xml中需要定义它的packaging为pom，需要定义它的modules，所以projectA的pom.xml应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>  \n  <version>1.0-SNAPSHOT</version>   \n  <modules>  \n       <module>../projectB</module>  \n  </modules>  \n</project>\n````\n而projectB是继承自projectA的，所以我们需要在projectB的pom.xml文件中新增一个parent元素，用以定义它继承的项目信息。所以projectB的pom.xml文件的内容应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <parent>  \n       <groupId>com.zhkui.util</groupId>  \n       <artifactId>projectA</artifactId>  \n       <version>1.0-SNAPSHOT</version>  \n       <relativePath>../projectA/pom.xml</relativePath>  \n  </parent>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <packaging>jar</packaging>  \n</project>\n````\n# 依赖关系：依赖关系列表（dependency list）是POM的重要部分\n项目之间的依赖是通过pom.xml文件里面的dependencies元素下面的dependency元素进行的。一个dependency元素定义一个依赖关系。在dependency元素中我们主要通过依赖项目的groupId、artifactId和version来定义所依赖的项目。 \n假设我现在有一个项目projectA，然后它里面有对junit的依赖，那么它的pom.xml就类似以下这个样子：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <packaging>jar</packaging>  \n  <dependencies>  \n    <dependency>  \n      <groupId>junit</groupId>  \n      <artifactId>junit</artifactId>  \n      <version>3.8.1</version>  \n      <scope>test</scope>  \n      <optional>true</optional>  \n    </dependency>  \n  </dependencies>  \n</project>\n````\n`groupId, artifactId, version`:描述了依赖的项目唯一标志。\n`type`：对应于依赖项目的packaging类型，默认是jar。\n\n`scope`:用于限制相应的依赖范围、传播范围。scope的主要取值范围如下（还有一个是在Maven2.0.9以后版本才支持的import，关于import作用域将在后文《Dependency介绍》中做介绍）：\n\n`test`:在测试范围有效，它在执行命令test的时候才执行，并且它不会传播给其他模块进行引入，比如 junit,dbunit 等测试框架。\n`compile(default 默认)`:这是它的默认值，这种类型很容易让人产生误解，以为只有在编译的时候才是需要的，其实这种类型表示所有的情况都是有用的，包括编译和运行时。而且这种类型的依赖性是可以传递的。\n`runtime`:在程序运行的时候依赖，在编译的时候不依赖。\n`provided`:这个跟compile很类似，但是它表示你期望这个依赖项目在运行时由JDK或者容器来提供。这种类型表示该依赖只有在测试和编译的情况下才有效，在运行时将由JDK或者容器提供。这种类型的依赖性是不可传递的。比如 javaee：\neclipse开发web环境中是没有javaee必须要手动添加。\nmyeclipse新建web项目会有JavaEE(servlet-api.jar,jsp-api.jar...)web容器依赖的jar包，一般都是做开发的时候才使用。但是myeclipse不会把这些 jar包发布的，lib下你是找不到javaee引入的jar包,因为myeclipse发布项目的时候会忽略它。为什么？因为tomcat容器bin/lib已经存在了这个jar包了。\n`system`：这种类型跟provided类似，唯一不同的就是这种类型的依赖我们要自己提供jar包，这需要与另一个元素systemPath来结合使用。systemPath将指向我们系统上的jar包的路径，而且必须是给定的绝对路径。\n`systemPath`：上面已经说过了这个元素是在scope的值为system的时候用于指定依赖的jar包在系统上的位置的，而且是绝对路径。该元素必须在依赖的 jar包的scope为system时才能使用，否则Maven将报错。\n`optional`：当该项目本身作为其他项目的一个依赖时标记该依赖为可选项。假设现在projectA有一个依赖性projectB，我们把projectB这个依赖项设为optional，这表示projectB在projectA的运行时不一定会用到。这个时候如果我们有另一个项目projectC，它依赖于projectA，那么这个时候因为projectB对于projectA是可选的，所以Maven在建立projectC的时候就不会安装projectB，这个时候如果projectC确实需要使用到projectB，那么它就可以定义自己对projectB的依赖。当一个依赖是可选的时候，我们把optional元素的值设为true，否则就不设置optional元素。\n`exclusions`：考虑这样一种情况，我们的projectA依赖于projectB，然后projectB又依赖于projectC，但是在projectA里面我们不需要projectB依赖的projectC，那么这个时候我们就可以在依赖projectB的时候使用exclusions元素下面的exclusion排除projectC。这个时候我们可以这样定义projectA对projectB的依赖：","source":"_posts/pom.xml详解.md","raw":"---\ntitle: pom.xml详解\ndate: 2016-03-12 15:05:37\ncategories:\n  Maven POM\ntags:\n  - Maven\n---\n# 什么是POM？\nPOM是项目对项目模型（Project Object Model）的简称，它是Maven项目中的文件，使用xml表示，名称是pom.xml。作用类似ant的build.xml文件，功能更强大。该文件用于管理：源码、配置文件、开发者信息和角色、问题追踪系统、组织信息、项目授权、项目url、项目依赖关系等等。事实上，在Maven世界中。project可以什么都没有，甚至没有代码，但是必须包含一个pom.xml文件。\n\n# POM基本结构\n下面是一个POM项目中的pom.xml文件中包含的元素：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n            http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    \n    <!-- 基本设置 The Basics -->\n    <groupId>...</groupId>\n    <artifactId>...</artifactId>\n    <version>...</version>\n    <packaging>...</packaging>\n    <dependencies>...</dependencies>\n    <parent>...</parent>\n    <dependencyManagement>...</dependencyManagement>\n    <modules>...</modules>\n    <properties>...</properties>\n    \n    <!-- 构建过程的设置 Build Settings -->\n    <build>...</build>\n    <reporting>...</reporting>\n    \n    <!-- 项目信息设置 More Project Information -->\n    <name>...</name>\n    <description>...</description>\n    <url>...</url>\n    <inceptionYear>...</inceptionYear>\n    <licenses>...</licenses>\n    <organization>...</organization>\n    <developers>...</developers>\n    <contributors>...</contributors>\n    \n    <!-- 环境设置 Environment Settings -->\n    <issueManagement>...</issueManagement>\n    <ciManagement>...</ciManagement>\n    <mailingLists>...</mailingLists>\n    <scm>...</scm>\n    <prerequisites>...</prerequisites>\n    <repositories>...</repositories>\n    <pluginRepositories>...</pluginRepositories>\n    <distributionManagement>...</distributionManagement>\n    <profiles>...</profiles>\n</project>\n````\n# 基本配置\n一个简单的pom.xml文件需要包含modelVersion、groupId、artifactId和version四个元素，当然这其中的元素也可以从它的父项目中继承的，在Maven中，使用groupId、artfactId和version组成groupdId:artifactId:version的形式来唯一确定一个项目“\n````java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0  \n\t\t                     http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\t<!-- \n        含义：组织标识，定义了项目属于哪个组,或者说若把本项目打包\n        用途：此名称则是本地仓库中的路径，列如：com.zhkui，在XX目录下，将是: com/zhkui/目录\n        命名规范:项目名称，模块，子模块\n    -->\n\t<groupId>com.zhkui</groupId>\n\t<!-- \n        含义：项目名称也可以说你所模块名称，定义当面Maven项目在组中唯一的ID\n        用途：例如：utils，在XX目录下，将是：com/zhkui/utils目录\n        命名规范:唯一就好\n    -->\n\t<artifactId>utils</artifactId>\n\t <!-- \n        含义：项目当前的版本号\n        用途：例如：0.0.1-SNAPSHOT，在XX目录下，将是：com/zhkui/utils/0.0.1-SNAPSHOT目录\n    -->\n\t<version>0.0.1-SNAPSHOT</version>\n\t    <!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par -->\n    <packaging>war</packaging>\n    <!-- 元素声明了一个对用户更为友好的项目名称 -->\n    <name>maven</name>\n</project>\n````\n# POM之间的继承、聚合、依赖\n我们知道Maven在建立项目的时候是基于Maven项目下的pom.xml进行的，我们羡慕的依赖信息和一些基本信息都在这个文件里面定义的。那如果当面有多个项目要进行，这些项目有一些项目配置是一样的，这些相同的信息无数次的重复。特别难以维护。是个时候就用到了POM的继承和聚合功能。\n对应使用面向对象语言的程序员，继承这个词都不会陌生。其实在POM定义的时候就定义了一个超级pom.xml文件，在问没有声明自己的父pom.xml的时候，我们的pom.xml默认继承这个超级pom.xml。\n\n超级pom.xml：\n````java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<!--\nLicensed to the Apache Software Foundation (ASF) under one\nor more contributor license agreements.  See the NOTICE file\ndistributed with this work for additional information\nregarding copyright ownership.  The ASF licenses this file\nto you under the Apache License, Version 2.0 (the\n\"License\"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n-->\n\n<!-- START SNIPPET: superpom -->\n<project>\n  <modelVersion>4.0.0</modelVersion>\n\n  <repositories>\n    <repository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n    </repository>\n  </repositories>\n\n  <pluginRepositories>\n    <pluginRepository>\n      <id>central</id>\n      <name>Central Repository</name>\n      <url>https://repo.maven.apache.org/maven2</url>\n      <layout>default</layout>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <updatePolicy>never</updatePolicy>\n      </releases>\n    </pluginRepository>\n  </pluginRepositories>\n\n  <build>\n    <directory>${project.basedir}/target</directory>\n    <outputDirectory>${project.build.directory}/classes</outputDirectory>\n    <finalName>${project.artifactId}-${project.version}</finalName>\n    <testOutputDirectory>${project.build.directory}/test-classes</testOutputDirectory>\n    <sourceDirectory>${project.basedir}/src/main/java</sourceDirectory>\n    <scriptSourceDirectory>${project.basedir}/src/main/scripts</scriptSourceDirectory>\n    <testSourceDirectory>${project.basedir}/src/test/java</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>${project.basedir}/src/main/resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>${project.basedir}/src/test/resources</directory>\n      </testResource>\n    </testResources>\n    <pluginManagement>\n      <!-- NOTE: These plugins will be removed from future versions of the super POM -->\n      <!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) -->\n      <plugins>\n        <plugin>\n          <artifactId>maven-antrun-plugin</artifactId>\n          <version>1.3</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-assembly-plugin</artifactId>\n          <version>2.2-beta-5</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-dependency-plugin</artifactId>\n          <version>2.8</version>\n        </plugin>\n        <plugin>\n          <artifactId>maven-release-plugin</artifactId>\n          <version>2.3.2</version>\n        </plugin>\n      </plugins>\n    </pluginManagement>\n  </build>\n\n  <reporting>\n    <outputDirectory>${project.build.directory}/site</outputDirectory>\n  </reporting>\n\n  <profiles>\n    <!-- NOTE: The release profile will be removed from future versions of the super POM -->\n    <profile>\n      <id>release-profile</id>\n\n      <activation>\n        <property>\n          <name>performRelease</name>\n          <value>true</value>\n        </property>\n      </activation>\n\n      <build>\n        <plugins>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-source-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-sources</id>\n                <goals>\n                  <goal>jar</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-javadoc-plugin</artifactId>\n            <executions>\n              <execution>\n                <id>attach-javadocs</id>\n                <goals>\n                  <goal>jar</goal>\n                </goals>\n              </execution>\n            </executions>\n          </plugin>\n          <plugin>\n            <inherited>true</inherited>\n            <artifactId>maven-deploy-plugin</artifactId>\n            <configuration>\n              <updateReleaseInfo>true</updateReleaseInfo>\n            </configuration>\n          </plugin>\n        </plugins>\n      </build>\n    </profile>\n  </profiles>\n\n</project>\n<!-- END SNIPPET: superpom -->\n````\n对于一个pom.xml来说有几个元素是必须定义的，一个是project根元素，然后就是它里面的modelVersion、groupId、artifactId和version。由上面的超级pom.xml的内容我们可以看到pom.xml中没有groupId、artifactId和version的定义，所以我们在建立自己的pom.xml的时候就需要定义这三个元素。和java里面的继承类似，子pom.xml会完全继承父pom.xml中所有的元素，而且对于相同的元素，一般子pom.xml中的会覆盖父pom.xml中的元素，但是有几个特殊的元素它们会进行合并而不是覆盖。这些特殊的元素是：\ndependencies\ndevelopers\ncontributors\nplugin列表，包括plugin下面的reports\nresources\n# 继承\n## 被继承项目与继承项目是父子目录关系\n假设我们有一个项目porjectA，它的pom.xml定义如下：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>    \n  <version>1.0-SNAPSHOT</version>  \n</project>\n````\n现在有一个项目projectB，而且projectB是projectA的子目录中，如果projectB要继承项目projectA的pom.xml文件。项目projectB的pom.xml文件定义如下：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">  \n  <parent>  \n    <groupId>com.zhkui.util</groupId>  \n    <artifactId>projectA</artifactId>  \n    <version>1.0-SNAPSHOT</version>  \n  </parent>  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <packaging>jar</packaging>  \n  <version>1.0-SNAPSHOT</version>  \n</project>\n````\n通过projectB的pom.xml文件定义可以知道，当需要继承一个指定Maven项目时，需要在自己的pom.xml中定义一个parent元素。在这个元素中指明需要继承项目的groupId、artifactId、version。\n\n## 被继承项目与继承项目的目录结构不是父子关系\n当被继承项目与继承项目的目录结构不是父子关系的时候，我们再利用上面的配置是不能实现Maven项目的继承关系的，这个时候我们就需要在子项目的pom.xml文件定义中的parent元素下再加上一个relativePath元素的定义，用以描述父项目的pom.xml文件相对于子项目的pom.xml文件的位置。\n假设我们现在还是有上面两个项目，projectA和projectB，projectB还是继承自projectA，但是现在projectB不在projectA的子目录中，而是与projectA处于同一目录中。这个时候projectA和projectB的目录结构如下：\n------projectA\n　------pom.xml\n------projectB\n　------pom.xml\n这个时候我们可以看出projectA的pom.xml相对于projectB的pom.xml的位置是“../projectA/pom.xml”，所以这个时候projectB的pom.xml的定义应该如下所示：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">  \n  <parent>  \n    <groupId>com.zhkui.util</groupId>  \n    <artifactId>projectA</artifactId>  \n    <version>1.0-SNAPSHOT</version>  \n       <relativePath>../projectA/pom.xml</relativePath>  \n  </parent>  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n</project>\n````\n# 聚合\n对于聚合这个概念搞java的人应该都不会陌生。先来说说我对聚合和被聚合的理解，比如说如果projectA聚合到projectB，那么我们就可以说projectA是projectB的子模块， projectB是被聚合项目，也可以类似于继承那样称为父项目。对于聚合而言，这个主体应该是被聚合的项目。所以，我们需要在被聚合的项目中定义它的子模块，而不是像继承那样在子项目中定义父项目。具体做法是：\n修改被聚合项目的pom.xml中的packaging元素的值为pom\n在被聚合项目的pom.xml中的modules元素下指定它的子模块项目\n对于聚合而言，当我们在被聚合的项目上使用Maven命令时，实际上这些命令都会在它的子模块项目上使用。这就是Maven中聚合的一个非常重要的作用。假设这样一种情况，你同时需要打包或者编译projectA、projectB、projectC和projectD，按照正常的逻辑我们一个一个项目去使用mvn compile或mvn package进行编译和打包，对于使用Maven而言，你还是这样使用的话是非常麻烦的。因为Maven给我们提供了聚合的功能。我们只需要再定义一个超级项目，然后在超级项目的pom.xml中定义这个几个项目都是聚合到这个超级项目的。之后我们只需要对这个超级项目进行mvn compile，它就会把那些子模块项目都进行编译。\n## 6.1 被聚合项目和子模块项目在目录结构上是父子关系\n还拿上面定义的projectA和projectB来举例，现在假设我们需要把projectB聚合到projectA中。projectA和projectB的目录结构如下所示：\n------projectA\n　　------projectB\n　　　　-----pom.xml\n　　------pom.xml\n这个时候projectA的pom.xml应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <modules>  \n       <module>projectB</module>  \n  </modules>  \n</project>\n````\n从上面的定义我们可知道被聚合的项目的packaging类型应该为pom，而且一个项目可以有多个子模块项目。对于聚合这种情况，我们使用子模块项目的artifactId来作为module的值，表示子模块项目相对于被聚合项目的地址，在上面的示例中就表示子模块projectB是处在被聚合项目的子目录下，即与被聚合项目的pom.xml处于同一目录。这里使用的module值是子模块projectB对应的目录名projectB，而不是子模块对应的artifactId。这个时候当我们对projectA进行mvn package命令时，实际上Maven也会对projectB进行打包。\n## 被聚合项目与子模块项目在目录结构上不是父子关系\n那么当被聚合项目与子模块项目在目录结构上不是父子关系的时候，我们应该怎么来进行聚合呢？还是像继承那样使用relativePath元素吗？答案是非也，具体做法是在module元素中指定以相对路径的方式指定子模块。我们来看下面一个例子。\n继续使用上面的projectA和projectB，还是需要把projectB聚合到projectA，但是projectA和projectB的目录结构不再是父子关系，而是如下所示的这种关系：\n------projectA\n    -----pom.xml\n------projectB\n　　------pom.xml\n这个时候projectA的pom.xml文件就应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <modules>  \n       <module>../projectB</module>  \n  </modules>  \n</project>\n````\n注意看module的值是“../projectB”，我们知道“..”是代表当前目录的上层目录，所以它表示子模块projectB是被聚合项目projectA的pom.xml文件所在目录（即projectA）的上层目录下面的子目录，即与projectA处于同一目录层次。注意，这里的projectB对应的是projectB这个项目的目录名称，而不是它的artifactId。\n\n## 聚合与继承同时进行\n假设有这样一种情况，有两个项目，projectA和projectB，现在我们需要projectB继承projectA，同时需要把projectB聚合到projectA。然后projectA和projectB的目录结构如下：\n------projectA\n    ------pom.xml\n------projectB\n    ------pom.xml\n那么这个时候按照上面说的那样，projectA的pom.xml中需要定义它的packaging为pom，需要定义它的modules，所以projectA的pom.xml应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectA</artifactId>  \n  <version>1.0-SNAPSHOT</version>   \n  <modules>  \n       <module>../projectB</module>  \n  </modules>  \n</project>\n````\n而projectB是继承自projectA的，所以我们需要在projectB的pom.xml文件中新增一个parent元素，用以定义它继承的项目信息。所以projectB的pom.xml文件的内容应该这样定义：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <parent>  \n       <groupId>com.zhkui.util</groupId>  \n       <artifactId>projectA</artifactId>  \n       <version>1.0-SNAPSHOT</version>  \n       <relativePath>../projectA/pom.xml</relativePath>  \n  </parent>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <packaging>jar</packaging>  \n</project>\n````\n# 依赖关系：依赖关系列表（dependency list）是POM的重要部分\n项目之间的依赖是通过pom.xml文件里面的dependencies元素下面的dependency元素进行的。一个dependency元素定义一个依赖关系。在dependency元素中我们主要通过依赖项目的groupId、artifactId和version来定义所依赖的项目。 \n假设我现在有一个项目projectA，然后它里面有对junit的依赖，那么它的pom.xml就类似以下这个样子：\n````java\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">  \n  <modelVersion>4.0.0</modelVersion>  \n  <groupId>com.zhkui.util</groupId>  \n  <artifactId>projectB</artifactId>  \n  <version>1.0-SNAPSHOT</version>  \n  <packaging>jar</packaging>  \n  <dependencies>  \n    <dependency>  \n      <groupId>junit</groupId>  \n      <artifactId>junit</artifactId>  \n      <version>3.8.1</version>  \n      <scope>test</scope>  \n      <optional>true</optional>  \n    </dependency>  \n  </dependencies>  \n</project>\n````\n`groupId, artifactId, version`:描述了依赖的项目唯一标志。\n`type`：对应于依赖项目的packaging类型，默认是jar。\n\n`scope`:用于限制相应的依赖范围、传播范围。scope的主要取值范围如下（还有一个是在Maven2.0.9以后版本才支持的import，关于import作用域将在后文《Dependency介绍》中做介绍）：\n\n`test`:在测试范围有效，它在执行命令test的时候才执行，并且它不会传播给其他模块进行引入，比如 junit,dbunit 等测试框架。\n`compile(default 默认)`:这是它的默认值，这种类型很容易让人产生误解，以为只有在编译的时候才是需要的，其实这种类型表示所有的情况都是有用的，包括编译和运行时。而且这种类型的依赖性是可以传递的。\n`runtime`:在程序运行的时候依赖，在编译的时候不依赖。\n`provided`:这个跟compile很类似，但是它表示你期望这个依赖项目在运行时由JDK或者容器来提供。这种类型表示该依赖只有在测试和编译的情况下才有效，在运行时将由JDK或者容器提供。这种类型的依赖性是不可传递的。比如 javaee：\neclipse开发web环境中是没有javaee必须要手动添加。\nmyeclipse新建web项目会有JavaEE(servlet-api.jar,jsp-api.jar...)web容器依赖的jar包，一般都是做开发的时候才使用。但是myeclipse不会把这些 jar包发布的，lib下你是找不到javaee引入的jar包,因为myeclipse发布项目的时候会忽略它。为什么？因为tomcat容器bin/lib已经存在了这个jar包了。\n`system`：这种类型跟provided类似，唯一不同的就是这种类型的依赖我们要自己提供jar包，这需要与另一个元素systemPath来结合使用。systemPath将指向我们系统上的jar包的路径，而且必须是给定的绝对路径。\n`systemPath`：上面已经说过了这个元素是在scope的值为system的时候用于指定依赖的jar包在系统上的位置的，而且是绝对路径。该元素必须在依赖的 jar包的scope为system时才能使用，否则Maven将报错。\n`optional`：当该项目本身作为其他项目的一个依赖时标记该依赖为可选项。假设现在projectA有一个依赖性projectB，我们把projectB这个依赖项设为optional，这表示projectB在projectA的运行时不一定会用到。这个时候如果我们有另一个项目projectC，它依赖于projectA，那么这个时候因为projectB对于projectA是可选的，所以Maven在建立projectC的时候就不会安装projectB，这个时候如果projectC确实需要使用到projectB，那么它就可以定义自己对projectB的依赖。当一个依赖是可选的时候，我们把optional元素的值设为true，否则就不设置optional元素。\n`exclusions`：考虑这样一种情况，我们的projectA依赖于projectB，然后projectB又依赖于projectC，但是在projectA里面我们不需要projectB依赖的projectC，那么这个时候我们就可以在依赖projectB的时候使用exclusions元素下面的exclusion排除projectC。这个时候我们可以这样定义projectA对projectB的依赖：","slug":"pom.xml详解","published":1,"updated":"2018-10-11T08:21:53.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja39p001344eizzswgyqo","content":"<h1 id=\"什么是POM？\"><a href=\"#什么是POM？\" class=\"headerlink\" title=\"什么是POM？\"></a>什么是POM？</h1><p>POM是项目对项目模型（Project Object Model）的简称，它是Maven项目中的文件，使用xml表示，名称是pom.xml。作用类似ant的build.xml文件，功能更强大。该文件用于管理：源码、配置文件、开发者信息和角色、问题追踪系统、组织信息、项目授权、项目url、项目依赖关系等等。事实上，在Maven世界中。project可以什么都没有，甚至没有代码，但是必须包含一个pom.xml文件。</p>\n<h1 id=\"POM基本结构\"><a href=\"#POM基本结构\" class=\"headerlink\" title=\"POM基本结构\"></a>POM基本结构</h1><p>下面是一个POM项目中的pom.xml文件中包含的元素：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"</div><div class=\"line\">         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"</div><div class=\"line\">         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0</div><div class=\"line\">            http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;</div><div class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 基本设置 The Basics --&gt;</div><div class=\"line\">    &lt;groupId&gt;...&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;...&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;...&lt;/version&gt;</div><div class=\"line\">    &lt;packaging&gt;...&lt;/packaging&gt;</div><div class=\"line\">    &lt;dependencies&gt;...&lt;/dependencies&gt;</div><div class=\"line\">    &lt;parent&gt;...&lt;/parent&gt;</div><div class=\"line\">    &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;</div><div class=\"line\">    &lt;modules&gt;...&lt;/modules&gt;</div><div class=\"line\">    &lt;properties&gt;...&lt;/properties&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 构建过程的设置 Build Settings --&gt;</div><div class=\"line\">    &lt;build&gt;...&lt;/build&gt;</div><div class=\"line\">    &lt;reporting&gt;...&lt;/reporting&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 项目信息设置 More Project Information --&gt;</div><div class=\"line\">    &lt;name&gt;...&lt;/name&gt;</div><div class=\"line\">    &lt;description&gt;...&lt;/description&gt;</div><div class=\"line\">    &lt;url&gt;...&lt;/url&gt;</div><div class=\"line\">    &lt;inceptionYear&gt;...&lt;/inceptionYear&gt;</div><div class=\"line\">    &lt;licenses&gt;...&lt;/licenses&gt;</div><div class=\"line\">    &lt;organization&gt;...&lt;/organization&gt;</div><div class=\"line\">    &lt;developers&gt;...&lt;/developers&gt;</div><div class=\"line\">    &lt;contributors&gt;...&lt;/contributors&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 环境设置 Environment Settings --&gt;</div><div class=\"line\">    &lt;issueManagement&gt;...&lt;/issueManagement&gt;</div><div class=\"line\">    &lt;ciManagement&gt;...&lt;/ciManagement&gt;</div><div class=\"line\">    &lt;mailingLists&gt;...&lt;/mailingLists&gt;</div><div class=\"line\">    &lt;scm&gt;...&lt;/scm&gt;</div><div class=\"line\">    &lt;prerequisites&gt;...&lt;/prerequisites&gt;</div><div class=\"line\">    &lt;repositories&gt;...&lt;/repositories&gt;</div><div class=\"line\">    &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;</div><div class=\"line\">    &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;</div><div class=\"line\">    &lt;profiles&gt;...&lt;/profiles&gt;</div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h1><p>一个简单的pom.xml文件需要包含modelVersion、groupId、artifactId和version四个元素，当然这其中的元素也可以从它的父项目中继承的，在Maven中，使用groupId、artfactId和version组成groupdId:artifactId:version的形式来唯一确定一个项目“<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"</div><div class=\"line\">         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0  </div><div class=\"line\">\t\t                     http://maven.apache.org/maven-v4_0_0.xsd\"&gt;</div><div class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class=\"line\">\t&lt;!-- </div><div class=\"line\">        含义：组织标识，定义了项目属于哪个组,或者说若把本项目打包</div><div class=\"line\">        用途：此名称则是本地仓库中的路径，列如：com.zhkui，在XX目录下，将是: com/zhkui/目录</div><div class=\"line\">        命名规范:项目名称，模块，子模块</div><div class=\"line\">    --&gt;</div><div class=\"line\">\t&lt;groupId&gt;com.zhkui&lt;/groupId&gt;</div><div class=\"line\">\t&lt;!-- </div><div class=\"line\">        含义：项目名称也可以说你所模块名称，定义当面Maven项目在组中唯一的ID</div><div class=\"line\">        用途：例如：utils，在XX目录下，将是：com/zhkui/utils目录</div><div class=\"line\">        命名规范:唯一就好</div><div class=\"line\">    --&gt;</div><div class=\"line\">\t&lt;artifactId&gt;utils&lt;/artifactId&gt;</div><div class=\"line\">\t &lt;!-- </div><div class=\"line\">        含义：项目当前的版本号</div><div class=\"line\">        用途：例如：0.0.1-SNAPSHOT，在XX目录下，将是：com/zhkui/utils/0.0.1-SNAPSHOT目录</div><div class=\"line\">    --&gt;</div><div class=\"line\">\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class=\"line\">\t    &lt;!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par --&gt;</div><div class=\"line\">    &lt;packaging&gt;war&lt;/packaging&gt;</div><div class=\"line\">    &lt;!-- 元素声明了一个对用户更为友好的项目名称 --&gt;</div><div class=\"line\">    &lt;name&gt;maven&lt;/name&gt;</div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"POM之间的继承、聚合、依赖\"><a href=\"#POM之间的继承、聚合、依赖\" class=\"headerlink\" title=\"POM之间的继承、聚合、依赖\"></a>POM之间的继承、聚合、依赖</h1><p>我们知道Maven在建立项目的时候是基于Maven项目下的pom.xml进行的，我们羡慕的依赖信息和一些基本信息都在这个文件里面定义的。那如果当面有多个项目要进行，这些项目有一些项目配置是一样的，这些相同的信息无数次的重复。特别难以维护。是个时候就用到了POM的继承和聚合功能。<br>对应使用面向对象语言的程序员，继承这个词都不会陌生。其实在POM定义的时候就定义了一个超级pom.xml文件，在问没有声明自己的父pom.xml的时候，我们的pom.xml默认继承这个超级pom.xml。</p>\n<p>超级pom.xml：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!--</div><div class=\"line\">Licensed to the Apache Software Foundation (ASF) under one</div><div class=\"line\">or more contributor license agreements.  See the NOTICE file</div><div class=\"line\">distributed with this work for additional information</div><div class=\"line\">regarding copyright ownership.  The ASF licenses this file</div><div class=\"line\">to you under the Apache License, Version 2.0 (the</div><div class=\"line\">\"License\"); you may not use this file except in compliance</div><div class=\"line\">with the License.  You may obtain a copy of the License at</div><div class=\"line\"></div><div class=\"line\">    http://www.apache.org/licenses/LICENSE-2.0</div><div class=\"line\"></div><div class=\"line\">Unless required by applicable law or agreed to in writing,</div><div class=\"line\">software distributed under the License is distributed on an</div><div class=\"line\">\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</div><div class=\"line\">KIND, either express or implied.  See the License for the</div><div class=\"line\">specific language governing permissions and limitations</div><div class=\"line\">under the License.</div><div class=\"line\">--&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- START SNIPPET: superpom --&gt;</div><div class=\"line\">&lt;project&gt;</div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;repositories&gt;</div><div class=\"line\">    &lt;repository&gt;</div><div class=\"line\">      &lt;id&gt;central&lt;/id&gt;</div><div class=\"line\">      &lt;name&gt;Central Repository&lt;/name&gt;</div><div class=\"line\">      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;</div><div class=\"line\">      &lt;layout&gt;default&lt;/layout&gt;</div><div class=\"line\">      &lt;snapshots&gt;</div><div class=\"line\">        &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">      &lt;/snapshots&gt;</div><div class=\"line\">    &lt;/repository&gt;</div><div class=\"line\">  &lt;/repositories&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;pluginRepositories&gt;</div><div class=\"line\">    &lt;pluginRepository&gt;</div><div class=\"line\">      &lt;id&gt;central&lt;/id&gt;</div><div class=\"line\">      &lt;name&gt;Central Repository&lt;/name&gt;</div><div class=\"line\">      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;</div><div class=\"line\">      &lt;layout&gt;default&lt;/layout&gt;</div><div class=\"line\">      &lt;snapshots&gt;</div><div class=\"line\">        &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">      &lt;/snapshots&gt;</div><div class=\"line\">      &lt;releases&gt;</div><div class=\"line\">        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;</div><div class=\"line\">      &lt;/releases&gt;</div><div class=\"line\">    &lt;/pluginRepository&gt;</div><div class=\"line\">  &lt;/pluginRepositories&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;build&gt;</div><div class=\"line\">    &lt;directory&gt;$&#123;project.basedir&#125;/target&lt;/directory&gt;</div><div class=\"line\">    &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/classes&lt;/outputDirectory&gt;</div><div class=\"line\">    &lt;finalName&gt;$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/finalName&gt;</div><div class=\"line\">    &lt;testOutputDirectory&gt;$&#123;project.build.directory&#125;/test-classes&lt;/testOutputDirectory&gt;</div><div class=\"line\">    &lt;sourceDirectory&gt;$&#123;project.basedir&#125;/src/main/java&lt;/sourceDirectory&gt;</div><div class=\"line\">    &lt;scriptSourceDirectory&gt;$&#123;project.basedir&#125;/src/main/scripts&lt;/scriptSourceDirectory&gt;</div><div class=\"line\">    &lt;testSourceDirectory&gt;$&#123;project.basedir&#125;/src/test/java&lt;/testSourceDirectory&gt;</div><div class=\"line\">    &lt;resources&gt;</div><div class=\"line\">      &lt;resource&gt;</div><div class=\"line\">        &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</div><div class=\"line\">      &lt;/resource&gt;</div><div class=\"line\">    &lt;/resources&gt;</div><div class=\"line\">    &lt;testResources&gt;</div><div class=\"line\">      &lt;testResource&gt;</div><div class=\"line\">        &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt;</div><div class=\"line\">      &lt;/testResource&gt;</div><div class=\"line\">    &lt;/testResources&gt;</div><div class=\"line\">    &lt;pluginManagement&gt;</div><div class=\"line\">      &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt;</div><div class=\"line\">      &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;</div><div class=\"line\">      &lt;plugins&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;1.3&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;2.2-beta-5&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;2.8&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;2.3.2&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">      &lt;/plugins&gt;</div><div class=\"line\">    &lt;/pluginManagement&gt;</div><div class=\"line\">  &lt;/build&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;reporting&gt;</div><div class=\"line\">    &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/site&lt;/outputDirectory&gt;</div><div class=\"line\">  &lt;/reporting&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;profiles&gt;</div><div class=\"line\">    &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt;</div><div class=\"line\">    &lt;profile&gt;</div><div class=\"line\">      &lt;id&gt;release-profile&lt;/id&gt;</div><div class=\"line\"></div><div class=\"line\">      &lt;activation&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">          &lt;name&gt;performRelease&lt;/name&gt;</div><div class=\"line\">          &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">      &lt;/activation&gt;</div><div class=\"line\"></div><div class=\"line\">      &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">          &lt;plugin&gt;</div><div class=\"line\">            &lt;inherited&gt;true&lt;/inherited&gt;</div><div class=\"line\">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;executions&gt;</div><div class=\"line\">              &lt;execution&gt;</div><div class=\"line\">                &lt;id&gt;attach-sources&lt;/id&gt;</div><div class=\"line\">                &lt;goals&gt;</div><div class=\"line\">                  &lt;goal&gt;jar&lt;/goal&gt;</div><div class=\"line\">                &lt;/goals&gt;</div><div class=\"line\">              &lt;/execution&gt;</div><div class=\"line\">            &lt;/executions&gt;</div><div class=\"line\">          &lt;/plugin&gt;</div><div class=\"line\">          &lt;plugin&gt;</div><div class=\"line\">            &lt;inherited&gt;true&lt;/inherited&gt;</div><div class=\"line\">            &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;executions&gt;</div><div class=\"line\">              &lt;execution&gt;</div><div class=\"line\">                &lt;id&gt;attach-javadocs&lt;/id&gt;</div><div class=\"line\">                &lt;goals&gt;</div><div class=\"line\">                  &lt;goal&gt;jar&lt;/goal&gt;</div><div class=\"line\">                &lt;/goals&gt;</div><div class=\"line\">              &lt;/execution&gt;</div><div class=\"line\">            &lt;/executions&gt;</div><div class=\"line\">          &lt;/plugin&gt;</div><div class=\"line\">          &lt;plugin&gt;</div><div class=\"line\">            &lt;inherited&gt;true&lt;/inherited&gt;</div><div class=\"line\">            &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;configuration&gt;</div><div class=\"line\">              &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt;</div><div class=\"line\">            &lt;/configuration&gt;</div><div class=\"line\">          &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">      &lt;/build&gt;</div><div class=\"line\">    &lt;/profile&gt;</div><div class=\"line\">  &lt;/profiles&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/project&gt;</div><div class=\"line\">&lt;!-- END SNIPPET: superpom --&gt;</div></pre></td></tr></table></figure></p>\n<p>对于一个pom.xml来说有几个元素是必须定义的，一个是project根元素，然后就是它里面的modelVersion、groupId、artifactId和version。由上面的超级pom.xml的内容我们可以看到pom.xml中没有groupId、artifactId和version的定义，所以我们在建立自己的pom.xml的时候就需要定义这三个元素。和java里面的继承类似，子pom.xml会完全继承父pom.xml中所有的元素，而且对于相同的元素，一般子pom.xml中的会覆盖父pom.xml中的元素，但是有几个特殊的元素它们会进行合并而不是覆盖。这些特殊的元素是：<br>dependencies<br>developers<br>contributors<br>plugin列表，包括plugin下面的reports<br>resources</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h2 id=\"被继承项目与继承项目是父子目录关系\"><a href=\"#被继承项目与继承项目是父子目录关系\" class=\"headerlink\" title=\"被继承项目与继承项目是父子目录关系\"></a>被继承项目与继承项目是父子目录关系</h2><p>假设我们有一个项目porjectA，它的pom.xml定义如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;    </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>现在有一个项目projectB，而且projectB是projectA的子目录中，如果projectB要继承项目projectA的pom.xml文件。项目projectB的pom.xml文件定义如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;  </div><div class=\"line\">  &lt;parent&gt;  </div><div class=\"line\">    &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">    &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;/parent&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;packaging&gt;jar&lt;/packaging&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>通过projectB的pom.xml文件定义可以知道，当需要继承一个指定Maven项目时，需要在自己的pom.xml中定义一个parent元素。在这个元素中指明需要继承项目的groupId、artifactId、version。</p>\n<h2 id=\"被继承项目与继承项目的目录结构不是父子关系\"><a href=\"#被继承项目与继承项目的目录结构不是父子关系\" class=\"headerlink\" title=\"被继承项目与继承项目的目录结构不是父子关系\"></a>被继承项目与继承项目的目录结构不是父子关系</h2><p>当被继承项目与继承项目的目录结构不是父子关系的时候，我们再利用上面的配置是不能实现Maven项目的继承关系的，这个时候我们就需要在子项目的pom.xml文件定义中的parent元素下再加上一个relativePath元素的定义，用以描述父项目的pom.xml文件相对于子项目的pom.xml文件的位置。<br>假设我们现在还是有上面两个项目，projectA和projectB，projectB还是继承自projectA，但是现在projectB不在projectA的子目录中，而是与projectA处于同一目录中。这个时候projectA和projectB的目录结构如下：<br>——projectA<br>　——pom.xml<br>——projectB<br>　——pom.xml<br>这个时候我们可以看出projectA的pom.xml相对于projectB的pom.xml的位置是“../projectA/pom.xml”，所以这个时候projectB的pom.xml的定义应该如下所示：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;  </div><div class=\"line\">  &lt;parent&gt;  </div><div class=\"line\">    &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">    &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">       &lt;relativePath&gt;../projectA/pom.xml&lt;/relativePath&gt;  </div><div class=\"line\">  &lt;/parent&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h1><p>对于聚合这个概念搞java的人应该都不会陌生。先来说说我对聚合和被聚合的理解，比如说如果projectA聚合到projectB，那么我们就可以说projectA是projectB的子模块， projectB是被聚合项目，也可以类似于继承那样称为父项目。对于聚合而言，这个主体应该是被聚合的项目。所以，我们需要在被聚合的项目中定义它的子模块，而不是像继承那样在子项目中定义父项目。具体做法是：<br>修改被聚合项目的pom.xml中的packaging元素的值为pom<br>在被聚合项目的pom.xml中的modules元素下指定它的子模块项目<br>对于聚合而言，当我们在被聚合的项目上使用Maven命令时，实际上这些命令都会在它的子模块项目上使用。这就是Maven中聚合的一个非常重要的作用。假设这样一种情况，你同时需要打包或者编译projectA、projectB、projectC和projectD，按照正常的逻辑我们一个一个项目去使用mvn compile或mvn package进行编译和打包，对于使用Maven而言，你还是这样使用的话是非常麻烦的。因为Maven给我们提供了聚合的功能。我们只需要再定义一个超级项目，然后在超级项目的pom.xml中定义这个几个项目都是聚合到这个超级项目的。之后我们只需要对这个超级项目进行mvn compile，它就会把那些子模块项目都进行编译。</p>\n<h2 id=\"6-1-被聚合项目和子模块项目在目录结构上是父子关系\"><a href=\"#6-1-被聚合项目和子模块项目在目录结构上是父子关系\" class=\"headerlink\" title=\"6.1 被聚合项目和子模块项目在目录结构上是父子关系\"></a>6.1 被聚合项目和子模块项目在目录结构上是父子关系</h2><p>还拿上面定义的projectA和projectB来举例，现在假设我们需要把projectB聚合到projectA中。projectA和projectB的目录结构如下所示：<br>——projectA<br>　　——projectB<br>　　　　—–pom.xml<br>　　——pom.xml<br>这个时候projectA的pom.xml应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;modules&gt;  </div><div class=\"line\">       &lt;module&gt;projectB&lt;/module&gt;  </div><div class=\"line\">  &lt;/modules&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>从上面的定义我们可知道被聚合的项目的packaging类型应该为pom，而且一个项目可以有多个子模块项目。对于聚合这种情况，我们使用子模块项目的artifactId来作为module的值，表示子模块项目相对于被聚合项目的地址，在上面的示例中就表示子模块projectB是处在被聚合项目的子目录下，即与被聚合项目的pom.xml处于同一目录。这里使用的module值是子模块projectB对应的目录名projectB，而不是子模块对应的artifactId。这个时候当我们对projectA进行mvn package命令时，实际上Maven也会对projectB进行打包。</p>\n<h2 id=\"被聚合项目与子模块项目在目录结构上不是父子关系\"><a href=\"#被聚合项目与子模块项目在目录结构上不是父子关系\" class=\"headerlink\" title=\"被聚合项目与子模块项目在目录结构上不是父子关系\"></a>被聚合项目与子模块项目在目录结构上不是父子关系</h2><p>那么当被聚合项目与子模块项目在目录结构上不是父子关系的时候，我们应该怎么来进行聚合呢？还是像继承那样使用relativePath元素吗？答案是非也，具体做法是在module元素中指定以相对路径的方式指定子模块。我们来看下面一个例子。<br>继续使用上面的projectA和projectB，还是需要把projectB聚合到projectA，但是projectA和projectB的目录结构不再是父子关系，而是如下所示的这种关系：<br>——projectA<br>    —–pom.xml<br>——projectB<br>　　——pom.xml<br>这个时候projectA的pom.xml文件就应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;modules&gt;  </div><div class=\"line\">       &lt;module&gt;../projectB&lt;/module&gt;  </div><div class=\"line\">  &lt;/modules&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>注意看module的值是“../projectB”，我们知道“..”是代表当前目录的上层目录，所以它表示子模块projectB是被聚合项目projectA的pom.xml文件所在目录（即projectA）的上层目录下面的子目录，即与projectA处于同一目录层次。注意，这里的projectB对应的是projectB这个项目的目录名称，而不是它的artifactId。</p>\n<h2 id=\"聚合与继承同时进行\"><a href=\"#聚合与继承同时进行\" class=\"headerlink\" title=\"聚合与继承同时进行\"></a>聚合与继承同时进行</h2><p>假设有这样一种情况，有两个项目，projectA和projectB，现在我们需要projectB继承projectA，同时需要把projectB聚合到projectA。然后projectA和projectB的目录结构如下：<br>——projectA<br>    ——pom.xml<br>——projectB<br>    ——pom.xml<br>那么这个时候按照上面说的那样，projectA的pom.xml中需要定义它的packaging为pom，需要定义它的modules，所以projectA的pom.xml应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   </div><div class=\"line\">  &lt;modules&gt;  </div><div class=\"line\">       &lt;module&gt;../projectB&lt;/module&gt;  </div><div class=\"line\">  &lt;/modules&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>而projectB是继承自projectA的，所以我们需要在projectB的pom.xml文件中新增一个parent元素，用以定义它继承的项目信息。所以projectB的pom.xml文件的内容应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;parent&gt;  </div><div class=\"line\">       &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">       &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">       &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">       &lt;relativePath&gt;../projectA/pom.xml&lt;/relativePath&gt;  </div><div class=\"line\">  &lt;/parent&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;packaging&gt;jar&lt;/packaging&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"依赖关系：依赖关系列表（dependency-list）是POM的重要部分\"><a href=\"#依赖关系：依赖关系列表（dependency-list）是POM的重要部分\" class=\"headerlink\" title=\"依赖关系：依赖关系列表（dependency list）是POM的重要部分\"></a>依赖关系：依赖关系列表（dependency list）是POM的重要部分</h1><p>项目之间的依赖是通过pom.xml文件里面的dependencies元素下面的dependency元素进行的。一个dependency元素定义一个依赖关系。在dependency元素中我们主要通过依赖项目的groupId、artifactId和version来定义所依赖的项目。<br>假设我现在有一个项目projectA，然后它里面有对junit的依赖，那么它的pom.xml就类似以下这个样子：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;packaging&gt;jar&lt;/packaging&gt;  </div><div class=\"line\">  &lt;dependencies&gt;  </div><div class=\"line\">    &lt;dependency&gt;  </div><div class=\"line\">      &lt;groupId&gt;junit&lt;/groupId&gt;  </div><div class=\"line\">      &lt;artifactId&gt;junit&lt;/artifactId&gt;  </div><div class=\"line\">      &lt;version&gt;3.8.1&lt;/version&gt;  </div><div class=\"line\">      &lt;scope&gt;test&lt;/scope&gt;  </div><div class=\"line\">      &lt;optional&gt;true&lt;/optional&gt;  </div><div class=\"line\">    &lt;/dependency&gt;  </div><div class=\"line\">  &lt;/dependencies&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p><code>groupId, artifactId, version</code>:描述了依赖的项目唯一标志。<br><code>type</code>：对应于依赖项目的packaging类型，默认是jar。</p>\n<p><code>scope</code>:用于限制相应的依赖范围、传播范围。scope的主要取值范围如下（还有一个是在Maven2.0.9以后版本才支持的import，关于import作用域将在后文《Dependency介绍》中做介绍）：</p>\n<p><code>test</code>:在测试范围有效，它在执行命令test的时候才执行，并且它不会传播给其他模块进行引入，比如 junit,dbunit 等测试框架。<br><code>compile(default 默认)</code>:这是它的默认值，这种类型很容易让人产生误解，以为只有在编译的时候才是需要的，其实这种类型表示所有的情况都是有用的，包括编译和运行时。而且这种类型的依赖性是可以传递的。<br><code>runtime</code>:在程序运行的时候依赖，在编译的时候不依赖。<br><code>provided</code>:这个跟compile很类似，但是它表示你期望这个依赖项目在运行时由JDK或者容器来提供。这种类型表示该依赖只有在测试和编译的情况下才有效，在运行时将由JDK或者容器提供。这种类型的依赖性是不可传递的。比如 javaee：<br>eclipse开发web环境中是没有javaee必须要手动添加。<br>myeclipse新建web项目会有JavaEE(servlet-api.jar,jsp-api.jar…)web容器依赖的jar包，一般都是做开发的时候才使用。但是myeclipse不会把这些 jar包发布的，lib下你是找不到javaee引入的jar包,因为myeclipse发布项目的时候会忽略它。为什么？因为tomcat容器bin/lib已经存在了这个jar包了。<br><code>system</code>：这种类型跟provided类似，唯一不同的就是这种类型的依赖我们要自己提供jar包，这需要与另一个元素systemPath来结合使用。systemPath将指向我们系统上的jar包的路径，而且必须是给定的绝对路径。<br><code>systemPath</code>：上面已经说过了这个元素是在scope的值为system的时候用于指定依赖的jar包在系统上的位置的，而且是绝对路径。该元素必须在依赖的 jar包的scope为system时才能使用，否则Maven将报错。<br><code>optional</code>：当该项目本身作为其他项目的一个依赖时标记该依赖为可选项。假设现在projectA有一个依赖性projectB，我们把projectB这个依赖项设为optional，这表示projectB在projectA的运行时不一定会用到。这个时候如果我们有另一个项目projectC，它依赖于projectA，那么这个时候因为projectB对于projectA是可选的，所以Maven在建立projectC的时候就不会安装projectB，这个时候如果projectC确实需要使用到projectB，那么它就可以定义自己对projectB的依赖。当一个依赖是可选的时候，我们把optional元素的值设为true，否则就不设置optional元素。<br><code>exclusions</code>：考虑这样一种情况，我们的projectA依赖于projectB，然后projectB又依赖于projectC，但是在projectA里面我们不需要projectB依赖的projectC，那么这个时候我们就可以在依赖projectB的时候使用exclusions元素下面的exclusion排除projectC。这个时候我们可以这样定义projectA对projectB的依赖：</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是POM？\"><a href=\"#什么是POM？\" class=\"headerlink\" title=\"什么是POM？\"></a>什么是POM？</h1><p>POM是项目对项目模型（Project Object Model）的简称，它是Maven项目中的文件，使用xml表示，名称是pom.xml。作用类似ant的build.xml文件，功能更强大。该文件用于管理：源码、配置文件、开发者信息和角色、问题追踪系统、组织信息、项目授权、项目url、项目依赖关系等等。事实上，在Maven世界中。project可以什么都没有，甚至没有代码，但是必须包含一个pom.xml文件。</p>\n<h1 id=\"POM基本结构\"><a href=\"#POM基本结构\" class=\"headerlink\" title=\"POM基本结构\"></a>POM基本结构</h1><p>下面是一个POM项目中的pom.xml文件中包含的元素：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"</div><div class=\"line\">         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"</div><div class=\"line\">         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0</div><div class=\"line\">            http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;</div><div class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 基本设置 The Basics --&gt;</div><div class=\"line\">    &lt;groupId&gt;...&lt;/groupId&gt;</div><div class=\"line\">    &lt;artifactId&gt;...&lt;/artifactId&gt;</div><div class=\"line\">    &lt;version&gt;...&lt;/version&gt;</div><div class=\"line\">    &lt;packaging&gt;...&lt;/packaging&gt;</div><div class=\"line\">    &lt;dependencies&gt;...&lt;/dependencies&gt;</div><div class=\"line\">    &lt;parent&gt;...&lt;/parent&gt;</div><div class=\"line\">    &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;</div><div class=\"line\">    &lt;modules&gt;...&lt;/modules&gt;</div><div class=\"line\">    &lt;properties&gt;...&lt;/properties&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 构建过程的设置 Build Settings --&gt;</div><div class=\"line\">    &lt;build&gt;...&lt;/build&gt;</div><div class=\"line\">    &lt;reporting&gt;...&lt;/reporting&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 项目信息设置 More Project Information --&gt;</div><div class=\"line\">    &lt;name&gt;...&lt;/name&gt;</div><div class=\"line\">    &lt;description&gt;...&lt;/description&gt;</div><div class=\"line\">    &lt;url&gt;...&lt;/url&gt;</div><div class=\"line\">    &lt;inceptionYear&gt;...&lt;/inceptionYear&gt;</div><div class=\"line\">    &lt;licenses&gt;...&lt;/licenses&gt;</div><div class=\"line\">    &lt;organization&gt;...&lt;/organization&gt;</div><div class=\"line\">    &lt;developers&gt;...&lt;/developers&gt;</div><div class=\"line\">    &lt;contributors&gt;...&lt;/contributors&gt;</div><div class=\"line\">    </div><div class=\"line\">    &lt;!-- 环境设置 Environment Settings --&gt;</div><div class=\"line\">    &lt;issueManagement&gt;...&lt;/issueManagement&gt;</div><div class=\"line\">    &lt;ciManagement&gt;...&lt;/ciManagement&gt;</div><div class=\"line\">    &lt;mailingLists&gt;...&lt;/mailingLists&gt;</div><div class=\"line\">    &lt;scm&gt;...&lt;/scm&gt;</div><div class=\"line\">    &lt;prerequisites&gt;...&lt;/prerequisites&gt;</div><div class=\"line\">    &lt;repositories&gt;...&lt;/repositories&gt;</div><div class=\"line\">    &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;</div><div class=\"line\">    &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;</div><div class=\"line\">    &lt;profiles&gt;...&lt;/profiles&gt;</div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h1><p>一个简单的pom.xml文件需要包含modelVersion、groupId、artifactId和version四个元素，当然这其中的元素也可以从它的父项目中继承的，在Maven中，使用groupId、artfactId和version组成groupdId:artifactId:version的形式来唯一确定一个项目“<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"</div><div class=\"line\">         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0  </div><div class=\"line\">\t\t                     http://maven.apache.org/maven-v4_0_0.xsd\"&gt;</div><div class=\"line\">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class=\"line\">\t&lt;!-- </div><div class=\"line\">        含义：组织标识，定义了项目属于哪个组,或者说若把本项目打包</div><div class=\"line\">        用途：此名称则是本地仓库中的路径，列如：com.zhkui，在XX目录下，将是: com/zhkui/目录</div><div class=\"line\">        命名规范:项目名称，模块，子模块</div><div class=\"line\">    --&gt;</div><div class=\"line\">\t&lt;groupId&gt;com.zhkui&lt;/groupId&gt;</div><div class=\"line\">\t&lt;!-- </div><div class=\"line\">        含义：项目名称也可以说你所模块名称，定义当面Maven项目在组中唯一的ID</div><div class=\"line\">        用途：例如：utils，在XX目录下，将是：com/zhkui/utils目录</div><div class=\"line\">        命名规范:唯一就好</div><div class=\"line\">    --&gt;</div><div class=\"line\">\t&lt;artifactId&gt;utils&lt;/artifactId&gt;</div><div class=\"line\">\t &lt;!-- </div><div class=\"line\">        含义：项目当前的版本号</div><div class=\"line\">        用途：例如：0.0.1-SNAPSHOT，在XX目录下，将是：com/zhkui/utils/0.0.1-SNAPSHOT目录</div><div class=\"line\">    --&gt;</div><div class=\"line\">\t&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</div><div class=\"line\">\t    &lt;!-- 打包的格式，可以为：pom , jar , maven-plugin , ejb , war , ear , rar , par --&gt;</div><div class=\"line\">    &lt;packaging&gt;war&lt;/packaging&gt;</div><div class=\"line\">    &lt;!-- 元素声明了一个对用户更为友好的项目名称 --&gt;</div><div class=\"line\">    &lt;name&gt;maven&lt;/name&gt;</div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"POM之间的继承、聚合、依赖\"><a href=\"#POM之间的继承、聚合、依赖\" class=\"headerlink\" title=\"POM之间的继承、聚合、依赖\"></a>POM之间的继承、聚合、依赖</h1><p>我们知道Maven在建立项目的时候是基于Maven项目下的pom.xml进行的，我们羡慕的依赖信息和一些基本信息都在这个文件里面定义的。那如果当面有多个项目要进行，这些项目有一些项目配置是一样的，这些相同的信息无数次的重复。特别难以维护。是个时候就用到了POM的继承和聚合功能。<br>对应使用面向对象语言的程序员，继承这个词都不会陌生。其实在POM定义的时候就定义了一个超级pom.xml文件，在问没有声明自己的父pom.xml的时候，我们的pom.xml默认继承这个超级pom.xml。</p>\n<p>超级pom.xml：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!--</div><div class=\"line\">Licensed to the Apache Software Foundation (ASF) under one</div><div class=\"line\">or more contributor license agreements.  See the NOTICE file</div><div class=\"line\">distributed with this work for additional information</div><div class=\"line\">regarding copyright ownership.  The ASF licenses this file</div><div class=\"line\">to you under the Apache License, Version 2.0 (the</div><div class=\"line\">\"License\"); you may not use this file except in compliance</div><div class=\"line\">with the License.  You may obtain a copy of the License at</div><div class=\"line\"></div><div class=\"line\">    http://www.apache.org/licenses/LICENSE-2.0</div><div class=\"line\"></div><div class=\"line\">Unless required by applicable law or agreed to in writing,</div><div class=\"line\">software distributed under the License is distributed on an</div><div class=\"line\">\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</div><div class=\"line\">KIND, either express or implied.  See the License for the</div><div class=\"line\">specific language governing permissions and limitations</div><div class=\"line\">under the License.</div><div class=\"line\">--&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;!-- START SNIPPET: superpom --&gt;</div><div class=\"line\">&lt;project&gt;</div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;repositories&gt;</div><div class=\"line\">    &lt;repository&gt;</div><div class=\"line\">      &lt;id&gt;central&lt;/id&gt;</div><div class=\"line\">      &lt;name&gt;Central Repository&lt;/name&gt;</div><div class=\"line\">      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;</div><div class=\"line\">      &lt;layout&gt;default&lt;/layout&gt;</div><div class=\"line\">      &lt;snapshots&gt;</div><div class=\"line\">        &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">      &lt;/snapshots&gt;</div><div class=\"line\">    &lt;/repository&gt;</div><div class=\"line\">  &lt;/repositories&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;pluginRepositories&gt;</div><div class=\"line\">    &lt;pluginRepository&gt;</div><div class=\"line\">      &lt;id&gt;central&lt;/id&gt;</div><div class=\"line\">      &lt;name&gt;Central Repository&lt;/name&gt;</div><div class=\"line\">      &lt;url&gt;https://repo.maven.apache.org/maven2&lt;/url&gt;</div><div class=\"line\">      &lt;layout&gt;default&lt;/layout&gt;</div><div class=\"line\">      &lt;snapshots&gt;</div><div class=\"line\">        &lt;enabled&gt;false&lt;/enabled&gt;</div><div class=\"line\">      &lt;/snapshots&gt;</div><div class=\"line\">      &lt;releases&gt;</div><div class=\"line\">        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;</div><div class=\"line\">      &lt;/releases&gt;</div><div class=\"line\">    &lt;/pluginRepository&gt;</div><div class=\"line\">  &lt;/pluginRepositories&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;build&gt;</div><div class=\"line\">    &lt;directory&gt;$&#123;project.basedir&#125;/target&lt;/directory&gt;</div><div class=\"line\">    &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/classes&lt;/outputDirectory&gt;</div><div class=\"line\">    &lt;finalName&gt;$&#123;project.artifactId&#125;-$&#123;project.version&#125;&lt;/finalName&gt;</div><div class=\"line\">    &lt;testOutputDirectory&gt;$&#123;project.build.directory&#125;/test-classes&lt;/testOutputDirectory&gt;</div><div class=\"line\">    &lt;sourceDirectory&gt;$&#123;project.basedir&#125;/src/main/java&lt;/sourceDirectory&gt;</div><div class=\"line\">    &lt;scriptSourceDirectory&gt;$&#123;project.basedir&#125;/src/main/scripts&lt;/scriptSourceDirectory&gt;</div><div class=\"line\">    &lt;testSourceDirectory&gt;$&#123;project.basedir&#125;/src/test/java&lt;/testSourceDirectory&gt;</div><div class=\"line\">    &lt;resources&gt;</div><div class=\"line\">      &lt;resource&gt;</div><div class=\"line\">        &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</div><div class=\"line\">      &lt;/resource&gt;</div><div class=\"line\">    &lt;/resources&gt;</div><div class=\"line\">    &lt;testResources&gt;</div><div class=\"line\">      &lt;testResource&gt;</div><div class=\"line\">        &lt;directory&gt;$&#123;project.basedir&#125;/src/test/resources&lt;/directory&gt;</div><div class=\"line\">      &lt;/testResource&gt;</div><div class=\"line\">    &lt;/testResources&gt;</div><div class=\"line\">    &lt;pluginManagement&gt;</div><div class=\"line\">      &lt;!-- NOTE: These plugins will be removed from future versions of the super POM --&gt;</div><div class=\"line\">      &lt;!-- They are kept for the moment as they are very unlikely to conflict with lifecycle mappings (MNG-4453) --&gt;</div><div class=\"line\">      &lt;plugins&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;1.3&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;2.2-beta-5&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;2.8&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">        &lt;plugin&gt;</div><div class=\"line\">          &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;</div><div class=\"line\">          &lt;version&gt;2.3.2&lt;/version&gt;</div><div class=\"line\">        &lt;/plugin&gt;</div><div class=\"line\">      &lt;/plugins&gt;</div><div class=\"line\">    &lt;/pluginManagement&gt;</div><div class=\"line\">  &lt;/build&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;reporting&gt;</div><div class=\"line\">    &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/site&lt;/outputDirectory&gt;</div><div class=\"line\">  &lt;/reporting&gt;</div><div class=\"line\"></div><div class=\"line\">  &lt;profiles&gt;</div><div class=\"line\">    &lt;!-- NOTE: The release profile will be removed from future versions of the super POM --&gt;</div><div class=\"line\">    &lt;profile&gt;</div><div class=\"line\">      &lt;id&gt;release-profile&lt;/id&gt;</div><div class=\"line\"></div><div class=\"line\">      &lt;activation&gt;</div><div class=\"line\">        &lt;property&gt;</div><div class=\"line\">          &lt;name&gt;performRelease&lt;/name&gt;</div><div class=\"line\">          &lt;value&gt;true&lt;/value&gt;</div><div class=\"line\">        &lt;/property&gt;</div><div class=\"line\">      &lt;/activation&gt;</div><div class=\"line\"></div><div class=\"line\">      &lt;build&gt;</div><div class=\"line\">        &lt;plugins&gt;</div><div class=\"line\">          &lt;plugin&gt;</div><div class=\"line\">            &lt;inherited&gt;true&lt;/inherited&gt;</div><div class=\"line\">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;executions&gt;</div><div class=\"line\">              &lt;execution&gt;</div><div class=\"line\">                &lt;id&gt;attach-sources&lt;/id&gt;</div><div class=\"line\">                &lt;goals&gt;</div><div class=\"line\">                  &lt;goal&gt;jar&lt;/goal&gt;</div><div class=\"line\">                &lt;/goals&gt;</div><div class=\"line\">              &lt;/execution&gt;</div><div class=\"line\">            &lt;/executions&gt;</div><div class=\"line\">          &lt;/plugin&gt;</div><div class=\"line\">          &lt;plugin&gt;</div><div class=\"line\">            &lt;inherited&gt;true&lt;/inherited&gt;</div><div class=\"line\">            &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;executions&gt;</div><div class=\"line\">              &lt;execution&gt;</div><div class=\"line\">                &lt;id&gt;attach-javadocs&lt;/id&gt;</div><div class=\"line\">                &lt;goals&gt;</div><div class=\"line\">                  &lt;goal&gt;jar&lt;/goal&gt;</div><div class=\"line\">                &lt;/goals&gt;</div><div class=\"line\">              &lt;/execution&gt;</div><div class=\"line\">            &lt;/executions&gt;</div><div class=\"line\">          &lt;/plugin&gt;</div><div class=\"line\">          &lt;plugin&gt;</div><div class=\"line\">            &lt;inherited&gt;true&lt;/inherited&gt;</div><div class=\"line\">            &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;</div><div class=\"line\">            &lt;configuration&gt;</div><div class=\"line\">              &lt;updateReleaseInfo&gt;true&lt;/updateReleaseInfo&gt;</div><div class=\"line\">            &lt;/configuration&gt;</div><div class=\"line\">          &lt;/plugin&gt;</div><div class=\"line\">        &lt;/plugins&gt;</div><div class=\"line\">      &lt;/build&gt;</div><div class=\"line\">    &lt;/profile&gt;</div><div class=\"line\">  &lt;/profiles&gt;</div><div class=\"line\"></div><div class=\"line\">&lt;/project&gt;</div><div class=\"line\">&lt;!-- END SNIPPET: superpom --&gt;</div></pre></td></tr></table></figure></p>\n<p>对于一个pom.xml来说有几个元素是必须定义的，一个是project根元素，然后就是它里面的modelVersion、groupId、artifactId和version。由上面的超级pom.xml的内容我们可以看到pom.xml中没有groupId、artifactId和version的定义，所以我们在建立自己的pom.xml的时候就需要定义这三个元素。和java里面的继承类似，子pom.xml会完全继承父pom.xml中所有的元素，而且对于相同的元素，一般子pom.xml中的会覆盖父pom.xml中的元素，但是有几个特殊的元素它们会进行合并而不是覆盖。这些特殊的元素是：<br>dependencies<br>developers<br>contributors<br>plugin列表，包括plugin下面的reports<br>resources</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h2 id=\"被继承项目与继承项目是父子目录关系\"><a href=\"#被继承项目与继承项目是父子目录关系\" class=\"headerlink\" title=\"被继承项目与继承项目是父子目录关系\"></a>被继承项目与继承项目是父子目录关系</h2><p>假设我们有一个项目porjectA，它的pom.xml定义如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;    </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>现在有一个项目projectB，而且projectB是projectA的子目录中，如果projectB要继承项目projectA的pom.xml文件。项目projectB的pom.xml文件定义如下：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;  </div><div class=\"line\">  &lt;parent&gt;  </div><div class=\"line\">    &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">    &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;/parent&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;packaging&gt;jar&lt;/packaging&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>通过projectB的pom.xml文件定义可以知道，当需要继承一个指定Maven项目时，需要在自己的pom.xml中定义一个parent元素。在这个元素中指明需要继承项目的groupId、artifactId、version。</p>\n<h2 id=\"被继承项目与继承项目的目录结构不是父子关系\"><a href=\"#被继承项目与继承项目的目录结构不是父子关系\" class=\"headerlink\" title=\"被继承项目与继承项目的目录结构不是父子关系\"></a>被继承项目与继承项目的目录结构不是父子关系</h2><p>当被继承项目与继承项目的目录结构不是父子关系的时候，我们再利用上面的配置是不能实现Maven项目的继承关系的，这个时候我们就需要在子项目的pom.xml文件定义中的parent元素下再加上一个relativePath元素的定义，用以描述父项目的pom.xml文件相对于子项目的pom.xml文件的位置。<br>假设我们现在还是有上面两个项目，projectA和projectB，projectB还是继承自projectA，但是现在projectB不在projectA的子目录中，而是与projectA处于同一目录中。这个时候projectA和projectB的目录结构如下：<br>——projectA<br>　——pom.xml<br>——projectB<br>　——pom.xml<br>这个时候我们可以看出projectA的pom.xml相对于projectB的pom.xml的位置是“../projectA/pom.xml”，所以这个时候projectB的pom.xml的定义应该如下所示：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt;  </div><div class=\"line\">  &lt;parent&gt;  </div><div class=\"line\">    &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">    &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">       &lt;relativePath&gt;../projectA/pom.xml&lt;/relativePath&gt;  </div><div class=\"line\">  &lt;/parent&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h1><p>对于聚合这个概念搞java的人应该都不会陌生。先来说说我对聚合和被聚合的理解，比如说如果projectA聚合到projectB，那么我们就可以说projectA是projectB的子模块， projectB是被聚合项目，也可以类似于继承那样称为父项目。对于聚合而言，这个主体应该是被聚合的项目。所以，我们需要在被聚合的项目中定义它的子模块，而不是像继承那样在子项目中定义父项目。具体做法是：<br>修改被聚合项目的pom.xml中的packaging元素的值为pom<br>在被聚合项目的pom.xml中的modules元素下指定它的子模块项目<br>对于聚合而言，当我们在被聚合的项目上使用Maven命令时，实际上这些命令都会在它的子模块项目上使用。这就是Maven中聚合的一个非常重要的作用。假设这样一种情况，你同时需要打包或者编译projectA、projectB、projectC和projectD，按照正常的逻辑我们一个一个项目去使用mvn compile或mvn package进行编译和打包，对于使用Maven而言，你还是这样使用的话是非常麻烦的。因为Maven给我们提供了聚合的功能。我们只需要再定义一个超级项目，然后在超级项目的pom.xml中定义这个几个项目都是聚合到这个超级项目的。之后我们只需要对这个超级项目进行mvn compile，它就会把那些子模块项目都进行编译。</p>\n<h2 id=\"6-1-被聚合项目和子模块项目在目录结构上是父子关系\"><a href=\"#6-1-被聚合项目和子模块项目在目录结构上是父子关系\" class=\"headerlink\" title=\"6.1 被聚合项目和子模块项目在目录结构上是父子关系\"></a>6.1 被聚合项目和子模块项目在目录结构上是父子关系</h2><p>还拿上面定义的projectA和projectB来举例，现在假设我们需要把projectB聚合到projectA中。projectA和projectB的目录结构如下所示：<br>——projectA<br>　　——projectB<br>　　　　—–pom.xml<br>　　——pom.xml<br>这个时候projectA的pom.xml应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;modules&gt;  </div><div class=\"line\">       &lt;module&gt;projectB&lt;/module&gt;  </div><div class=\"line\">  &lt;/modules&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>从上面的定义我们可知道被聚合的项目的packaging类型应该为pom，而且一个项目可以有多个子模块项目。对于聚合这种情况，我们使用子模块项目的artifactId来作为module的值，表示子模块项目相对于被聚合项目的地址，在上面的示例中就表示子模块projectB是处在被聚合项目的子目录下，即与被聚合项目的pom.xml处于同一目录。这里使用的module值是子模块projectB对应的目录名projectB，而不是子模块对应的artifactId。这个时候当我们对projectA进行mvn package命令时，实际上Maven也会对projectB进行打包。</p>\n<h2 id=\"被聚合项目与子模块项目在目录结构上不是父子关系\"><a href=\"#被聚合项目与子模块项目在目录结构上不是父子关系\" class=\"headerlink\" title=\"被聚合项目与子模块项目在目录结构上不是父子关系\"></a>被聚合项目与子模块项目在目录结构上不是父子关系</h2><p>那么当被聚合项目与子模块项目在目录结构上不是父子关系的时候，我们应该怎么来进行聚合呢？还是像继承那样使用relativePath元素吗？答案是非也，具体做法是在module元素中指定以相对路径的方式指定子模块。我们来看下面一个例子。<br>继续使用上面的projectA和projectB，还是需要把projectB聚合到projectA，但是projectA和projectB的目录结构不再是父子关系，而是如下所示的这种关系：<br>——projectA<br>    —–pom.xml<br>——projectB<br>　　——pom.xml<br>这个时候projectA的pom.xml文件就应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;modules&gt;  </div><div class=\"line\">       &lt;module&gt;../projectB&lt;/module&gt;  </div><div class=\"line\">  &lt;/modules&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>注意看module的值是“../projectB”，我们知道“..”是代表当前目录的上层目录，所以它表示子模块projectB是被聚合项目projectA的pom.xml文件所在目录（即projectA）的上层目录下面的子目录，即与projectA处于同一目录层次。注意，这里的projectB对应的是projectB这个项目的目录名称，而不是它的artifactId。</p>\n<h2 id=\"聚合与继承同时进行\"><a href=\"#聚合与继承同时进行\" class=\"headerlink\" title=\"聚合与继承同时进行\"></a>聚合与继承同时进行</h2><p>假设有这样一种情况，有两个项目，projectA和projectB，现在我们需要projectB继承projectA，同时需要把projectB聚合到projectA。然后projectA和projectB的目录结构如下：<br>——projectA<br>    ——pom.xml<br>——projectB<br>    ——pom.xml<br>那么这个时候按照上面说的那样，projectA的pom.xml中需要定义它的packaging为pom，需要定义它的modules，所以projectA的pom.xml应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;   </div><div class=\"line\">  &lt;modules&gt;  </div><div class=\"line\">       &lt;module&gt;../projectB&lt;/module&gt;  </div><div class=\"line\">  &lt;/modules&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p>而projectB是继承自projectA的，所以我们需要在projectB的pom.xml文件中新增一个parent元素，用以定义它继承的项目信息。所以projectB的pom.xml文件的内容应该这样定义：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;parent&gt;  </div><div class=\"line\">       &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">       &lt;artifactId&gt;projectA&lt;/artifactId&gt;  </div><div class=\"line\">       &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">       &lt;relativePath&gt;../projectA/pom.xml&lt;/relativePath&gt;  </div><div class=\"line\">  &lt;/parent&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;packaging&gt;jar&lt;/packaging&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<h1 id=\"依赖关系：依赖关系列表（dependency-list）是POM的重要部分\"><a href=\"#依赖关系：依赖关系列表（dependency-list）是POM的重要部分\" class=\"headerlink\" title=\"依赖关系：依赖关系列表（dependency list）是POM的重要部分\"></a>依赖关系：依赖关系列表（dependency list）是POM的重要部分</h1><p>项目之间的依赖是通过pom.xml文件里面的dependencies元素下面的dependency元素进行的。一个dependency元素定义一个依赖关系。在dependency元素中我们主要通过依赖项目的groupId、artifactId和version来定义所依赖的项目。<br>假设我现在有一个项目projectA，然后它里面有对junit的依赖，那么它的pom.xml就类似以下这个样子：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  </div><div class=\"line\">  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;  </div><div class=\"line\">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  </div><div class=\"line\">  &lt;groupId&gt;com.zhkui.util&lt;/groupId&gt;  </div><div class=\"line\">  &lt;artifactId&gt;projectB&lt;/artifactId&gt;  </div><div class=\"line\">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  </div><div class=\"line\">  &lt;packaging&gt;jar&lt;/packaging&gt;  </div><div class=\"line\">  &lt;dependencies&gt;  </div><div class=\"line\">    &lt;dependency&gt;  </div><div class=\"line\">      &lt;groupId&gt;junit&lt;/groupId&gt;  </div><div class=\"line\">      &lt;artifactId&gt;junit&lt;/artifactId&gt;  </div><div class=\"line\">      &lt;version&gt;3.8.1&lt;/version&gt;  </div><div class=\"line\">      &lt;scope&gt;test&lt;/scope&gt;  </div><div class=\"line\">      &lt;optional&gt;true&lt;/optional&gt;  </div><div class=\"line\">    &lt;/dependency&gt;  </div><div class=\"line\">  &lt;/dependencies&gt;  </div><div class=\"line\">&lt;/project&gt;</div></pre></td></tr></table></figure></p>\n<p><code>groupId, artifactId, version</code>:描述了依赖的项目唯一标志。<br><code>type</code>：对应于依赖项目的packaging类型，默认是jar。</p>\n<p><code>scope</code>:用于限制相应的依赖范围、传播范围。scope的主要取值范围如下（还有一个是在Maven2.0.9以后版本才支持的import，关于import作用域将在后文《Dependency介绍》中做介绍）：</p>\n<p><code>test</code>:在测试范围有效，它在执行命令test的时候才执行，并且它不会传播给其他模块进行引入，比如 junit,dbunit 等测试框架。<br><code>compile(default 默认)</code>:这是它的默认值，这种类型很容易让人产生误解，以为只有在编译的时候才是需要的，其实这种类型表示所有的情况都是有用的，包括编译和运行时。而且这种类型的依赖性是可以传递的。<br><code>runtime</code>:在程序运行的时候依赖，在编译的时候不依赖。<br><code>provided</code>:这个跟compile很类似，但是它表示你期望这个依赖项目在运行时由JDK或者容器来提供。这种类型表示该依赖只有在测试和编译的情况下才有效，在运行时将由JDK或者容器提供。这种类型的依赖性是不可传递的。比如 javaee：<br>eclipse开发web环境中是没有javaee必须要手动添加。<br>myeclipse新建web项目会有JavaEE(servlet-api.jar,jsp-api.jar…)web容器依赖的jar包，一般都是做开发的时候才使用。但是myeclipse不会把这些 jar包发布的，lib下你是找不到javaee引入的jar包,因为myeclipse发布项目的时候会忽略它。为什么？因为tomcat容器bin/lib已经存在了这个jar包了。<br><code>system</code>：这种类型跟provided类似，唯一不同的就是这种类型的依赖我们要自己提供jar包，这需要与另一个元素systemPath来结合使用。systemPath将指向我们系统上的jar包的路径，而且必须是给定的绝对路径。<br><code>systemPath</code>：上面已经说过了这个元素是在scope的值为system的时候用于指定依赖的jar包在系统上的位置的，而且是绝对路径。该元素必须在依赖的 jar包的scope为system时才能使用，否则Maven将报错。<br><code>optional</code>：当该项目本身作为其他项目的一个依赖时标记该依赖为可选项。假设现在projectA有一个依赖性projectB，我们把projectB这个依赖项设为optional，这表示projectB在projectA的运行时不一定会用到。这个时候如果我们有另一个项目projectC，它依赖于projectA，那么这个时候因为projectB对于projectA是可选的，所以Maven在建立projectC的时候就不会安装projectB，这个时候如果projectC确实需要使用到projectB，那么它就可以定义自己对projectB的依赖。当一个依赖是可选的时候，我们把optional元素的值设为true，否则就不设置optional元素。<br><code>exclusions</code>：考虑这样一种情况，我们的projectA依赖于projectB，然后projectB又依赖于projectC，但是在projectA里面我们不需要projectB依赖的projectC，那么这个时候我们就可以在依赖projectB的时候使用exclusions元素下面的exclusion排除projectC。这个时候我们可以这样定义projectA对projectB的依赖：</p>\n"},{"title":"大数据排重算法：布隆过滤器","date":"2017-01-11T07:05:37.000Z","_content":"# 什么是布隆过滤器(Bloom Filter)\n布隆过滤器是布隆在1970年提出的。它实际是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。他的优点是空间效率和查询时间都有远远超过一般算法，确定是一定的误识别率和删除困难。\n\n# 基本概念\n一般判断一个元素是否在一个集合里，使用一个集合把所有的元素保存起来，再通过比较的方式判断。我们可能会想到使用下面的方式判断一个元素是否在集合中存在：\n 1. 在数据库中创建字段的UNIQUE属性\n 2. 在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在\n 3. 使用Set或HashSet保存数据，确保唯一\n 4. 使用Map或是一个定长数组记录某一个URL是否被访问过\n但是，随着数据量不断增加，当数据达到几百G的时候。上面的方法就变的不在方便。上面的方法会占用巨大的存储空间以及随着数据增多效率降低。\n布隆过滤器利用哈希函数将一个元素映射成一个阵列（Big array）中的一个点。这样我们只需要判断这个点是不是存在（值为1）就可以知道该元素是否存在于这个集合中。这就是布隆过滤器的思想。\n通常布隆过滤器会使用多个hash函数计算出多个点，如果某个元素计算出的点其中有一个不再集合中我们就认为该元素肯定不再集合中。\n\n# 布隆过滤器原理图解\n\n布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k\n![布隆过滤器原理图](https://t1.daumcdn.net/cfile/tistory/1423AF384F50A0442F)\n以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。\n\n# 优点\n与其他的判断方法相比，布隆过滤器在空间和时间上都有巨大的优势，布隆过滤器存储空间和插入、查询时间都是常数。布隆过滤器不存储元素本身，对信息安全要求较高的场合非常有利。\n\n# 缺点\n但是，布隆过滤器的确定也很明显。布隆过滤器室友误算率的。随着存入的数据增加，误算率也随之增加。如果数据量少。hash表就可以表示了。另外就是，布隆过滤器一般情况下都是不能删除元素的。\n\n[参考：布隆过滤器的空间、插入/询时间及误判率的数学证明](http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html)\n\n# 布隆过滤器的java实现\n布隆过滤器的空间复杂度是S(n)=O(n)。下面是一个简单的布隆过滤器Java代码展示。而在查重过程也很有效率，时间复杂度是T(n)=O(1)。\n```java\nimport java.util.BitSet;  \n  \npublic class BloomFilter {  \n      \n    /* BitSet初始分配2^24个bit */  \n    private static final int DEFAULT_SIZE = 1 << 25;  \n      \n    /* 不同哈希函数的种子，一般应取质数 */  \n    private static final int[] seeds = new int[] { 5, 7, 11, 13, 31, 37, 61 };  \n      \n    private BitSet bits = new BitSet(DEFAULT_SIZE);  \n      \n    /* 哈希函数对象 */  \n    private SimpleHash[] func = new SimpleHash[seeds.length];  \n  \n    public BloomFilter() {  \n        for (int i = 0; i < seeds.length; i++) {  \n            func[i] = new SimpleHash(DEFAULT_SIZE, seeds[i]);  \n        }  \n    }  \n  \n    // 将字符串标记到bits中  \n    public void add(String value) {  \n        for (SimpleHash f : func) {  \n            bits.set(f.hash(value), true);  \n        }  \n    }  \n  \n    // 判断字符串是否已经被bits标记  \n    public boolean contains(String value) {  \n        if (value == null) {  \n            return false;  \n        }  \n          \n        boolean ret = true;  \n        for (SimpleHash f : func) {  \n            ret = ret && bits.get(f.hash(value));  \n        }  \n          \n        return ret;  \n    }  \n  \n    /* 哈希函数类，可以采用成熟的hash函数 */  \n    public static class SimpleHash {  \n        private int cap;  \n        private int seed;  \n  \n        public SimpleHash(int cap, int seed) {  \n            this.cap = cap;  \n            this.seed = seed;  \n        }  \n  \n        // hash函数，采用简单的加权和hash  \n        public int hash(String value) {  \n            int result = 0;  \n            int len = value.length();  \n            for (int i = 0; i < len; i++) {  \n                result = seed * result + value.charAt(i);  \n            }  \n            return (cap - 1) & result;  \n        }  \n    }  \n} \n```\n\n# 应用场景\n1. 假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特），即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这些 email 地址的布隆过滤器就建成了。\n2. 网络爬虫：URL去重\n ","source":"_posts/大数据排重算法：布隆过滤器.md","raw":"---\ntitle: 大数据排重算法：布隆过滤器\ndate: 2017-01-11 15:05:37\ncategories:\n  大数据 \ntags:\n  - 算法\n---\n# 什么是布隆过滤器(Bloom Filter)\n布隆过滤器是布隆在1970年提出的。它实际是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。他的优点是空间效率和查询时间都有远远超过一般算法，确定是一定的误识别率和删除困难。\n\n# 基本概念\n一般判断一个元素是否在一个集合里，使用一个集合把所有的元素保存起来，再通过比较的方式判断。我们可能会想到使用下面的方式判断一个元素是否在集合中存在：\n 1. 在数据库中创建字段的UNIQUE属性\n 2. 在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在\n 3. 使用Set或HashSet保存数据，确保唯一\n 4. 使用Map或是一个定长数组记录某一个URL是否被访问过\n但是，随着数据量不断增加，当数据达到几百G的时候。上面的方法就变的不在方便。上面的方法会占用巨大的存储空间以及随着数据增多效率降低。\n布隆过滤器利用哈希函数将一个元素映射成一个阵列（Big array）中的一个点。这样我们只需要判断这个点是不是存在（值为1）就可以知道该元素是否存在于这个集合中。这就是布隆过滤器的思想。\n通常布隆过滤器会使用多个hash函数计算出多个点，如果某个元素计算出的点其中有一个不再集合中我们就认为该元素肯定不再集合中。\n\n# 布隆过滤器原理图解\n\n布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k\n![布隆过滤器原理图](https://t1.daumcdn.net/cfile/tistory/1423AF384F50A0442F)\n以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。\n\n# 优点\n与其他的判断方法相比，布隆过滤器在空间和时间上都有巨大的优势，布隆过滤器存储空间和插入、查询时间都是常数。布隆过滤器不存储元素本身，对信息安全要求较高的场合非常有利。\n\n# 缺点\n但是，布隆过滤器的确定也很明显。布隆过滤器室友误算率的。随着存入的数据增加，误算率也随之增加。如果数据量少。hash表就可以表示了。另外就是，布隆过滤器一般情况下都是不能删除元素的。\n\n[参考：布隆过滤器的空间、插入/询时间及误判率的数学证明](http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html)\n\n# 布隆过滤器的java实现\n布隆过滤器的空间复杂度是S(n)=O(n)。下面是一个简单的布隆过滤器Java代码展示。而在查重过程也很有效率，时间复杂度是T(n)=O(1)。\n```java\nimport java.util.BitSet;  \n  \npublic class BloomFilter {  \n      \n    /* BitSet初始分配2^24个bit */  \n    private static final int DEFAULT_SIZE = 1 << 25;  \n      \n    /* 不同哈希函数的种子，一般应取质数 */  \n    private static final int[] seeds = new int[] { 5, 7, 11, 13, 31, 37, 61 };  \n      \n    private BitSet bits = new BitSet(DEFAULT_SIZE);  \n      \n    /* 哈希函数对象 */  \n    private SimpleHash[] func = new SimpleHash[seeds.length];  \n  \n    public BloomFilter() {  \n        for (int i = 0; i < seeds.length; i++) {  \n            func[i] = new SimpleHash(DEFAULT_SIZE, seeds[i]);  \n        }  \n    }  \n  \n    // 将字符串标记到bits中  \n    public void add(String value) {  \n        for (SimpleHash f : func) {  \n            bits.set(f.hash(value), true);  \n        }  \n    }  \n  \n    // 判断字符串是否已经被bits标记  \n    public boolean contains(String value) {  \n        if (value == null) {  \n            return false;  \n        }  \n          \n        boolean ret = true;  \n        for (SimpleHash f : func) {  \n            ret = ret && bits.get(f.hash(value));  \n        }  \n          \n        return ret;  \n    }  \n  \n    /* 哈希函数类，可以采用成熟的hash函数 */  \n    public static class SimpleHash {  \n        private int cap;  \n        private int seed;  \n  \n        public SimpleHash(int cap, int seed) {  \n            this.cap = cap;  \n            this.seed = seed;  \n        }  \n  \n        // hash函数，采用简单的加权和hash  \n        public int hash(String value) {  \n            int result = 0;  \n            int len = value.length();  \n            for (int i = 0; i < len; i++) {  \n                result = seed * result + value.charAt(i);  \n            }  \n            return (cap - 1) & result;  \n        }  \n    }  \n} \n```\n\n# 应用场景\n1. 假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特），即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这些 email 地址的布隆过滤器就建成了。\n2. 网络爬虫：URL去重\n ","slug":"大数据排重算法：布隆过滤器","published":1,"updated":"2018-06-08T04:31:50.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja39s001a44eipjbunf2z","content":"<h1 id=\"什么是布隆过滤器-Bloom-Filter\"><a href=\"#什么是布隆过滤器-Bloom-Filter\" class=\"headerlink\" title=\"什么是布隆过滤器(Bloom Filter)\"></a>什么是布隆过滤器(Bloom Filter)</h1><p>布隆过滤器是布隆在1970年提出的。它实际是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。他的优点是空间效率和查询时间都有远远超过一般算法，确定是一定的误识别率和删除困难。</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>一般判断一个元素是否在一个集合里，使用一个集合把所有的元素保存起来，再通过比较的方式判断。我们可能会想到使用下面的方式判断一个元素是否在集合中存在：</p>\n<ol>\n<li>在数据库中创建字段的UNIQUE属性</li>\n<li>在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在</li>\n<li>使用Set或HashSet保存数据，确保唯一</li>\n<li>使用Map或是一个定长数组记录某一个URL是否被访问过<br>但是，随着数据量不断增加，当数据达到几百G的时候。上面的方法就变的不在方便。上面的方法会占用巨大的存储空间以及随着数据增多效率降低。<br>布隆过滤器利用哈希函数将一个元素映射成一个阵列（Big array）中的一个点。这样我们只需要判断这个点是不是存在（值为1）就可以知道该元素是否存在于这个集合中。这就是布隆过滤器的思想。<br>通常布隆过滤器会使用多个hash函数计算出多个点，如果某个元素计算出的点其中有一个不再集合中我们就认为该元素肯定不再集合中。</li>\n</ol>\n<h1 id=\"布隆过滤器原理图解\"><a href=\"#布隆过滤器原理图解\" class=\"headerlink\" title=\"布隆过滤器原理图解\"></a>布隆过滤器原理图解</h1><p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k<br><img src=\"https://t1.daumcdn.net/cfile/tistory/1423AF384F50A0442F\" alt=\"布隆过滤器原理图\"><br>以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><p>与其他的判断方法相比，布隆过滤器在空间和时间上都有巨大的优势，布隆过滤器存储空间和插入、查询时间都是常数。布隆过滤器不存储元素本身，对信息安全要求较高的场合非常有利。</p>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>但是，布隆过滤器的确定也很明显。布隆过滤器室友误算率的。随着存入的数据增加，误算率也随之增加。如果数据量少。hash表就可以表示了。另外就是，布隆过滤器一般情况下都是不能删除元素的。</p>\n<p><a href=\"http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html\" target=\"_blank\" rel=\"external\">参考：布隆过滤器的空间、插入/询时间及误判率的数学证明</a></p>\n<h1 id=\"布隆过滤器的java实现\"><a href=\"#布隆过滤器的java实现\" class=\"headerlink\" title=\"布隆过滤器的java实现\"></a>布隆过滤器的java实现</h1><p>布隆过滤器的空间复杂度是S(n)=O(n)。下面是一个简单的布隆过滤器Java代码展示。而在查重过程也很有效率，时间复杂度是T(n)=O(1)。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.BitSet;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BloomFilter</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* BitSet初始分配2^24个bit */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_SIZE = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">25</span>;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* 不同哈希函数的种子，一般应取质数 */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] seeds = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">31</span>, <span class=\"number\">37</span>, <span class=\"number\">61</span> &#125;;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">private</span> BitSet bits = <span class=\"keyword\">new</span> BitSet(DEFAULT_SIZE);  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* 哈希函数对象 */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> SimpleHash[] func = <span class=\"keyword\">new</span> SimpleHash[seeds.length];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BloomFilter</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; seeds.length; i++) &#123;  </div><div class=\"line\">            func[i] = <span class=\"keyword\">new</span> SimpleHash(DEFAULT_SIZE, seeds[i]);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">// 将字符串标记到bits中  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(String value)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">for</span> (SimpleHash f : func) &#123;  </div><div class=\"line\">            bits.set(f.hash(value), <span class=\"keyword\">true</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">// 判断字符串是否已经被bits标记  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(String value)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">boolean</span> ret = <span class=\"keyword\">true</span>;  </div><div class=\"line\">        <span class=\"keyword\">for</span> (SimpleHash f : func) &#123;  </div><div class=\"line\">            ret = ret &amp;&amp; bits.get(f.hash(value));  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">return</span> ret;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">/* 哈希函数类，可以采用成熟的hash函数 */</span>  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleHash</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cap;  </div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> seed;  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleHash</span><span class=\"params\">(<span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> seed)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">this</span>.cap = cap;  </div><div class=\"line\">            <span class=\"keyword\">this</span>.seed = seed;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"comment\">// hash函数，采用简单的加权和hash  </span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(String value)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;  </div><div class=\"line\">            <span class=\"keyword\">int</span> len = value.length();  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;  </div><div class=\"line\">                result = seed * result + value.charAt(i);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">return</span> (cap - <span class=\"number\">1</span>) &amp; result;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><ol>\n<li>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特），即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮件地址 X，我们用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指纹（f1, f2, …, f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, …,g8。现在我们把这八个位置的二进制全部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这些 email 地址的布隆过滤器就建成了。</li>\n<li>网络爬虫：URL去重</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是布隆过滤器-Bloom-Filter\"><a href=\"#什么是布隆过滤器-Bloom-Filter\" class=\"headerlink\" title=\"什么是布隆过滤器(Bloom Filter)\"></a>什么是布隆过滤器(Bloom Filter)</h1><p>布隆过滤器是布隆在1970年提出的。它实际是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。他的优点是空间效率和查询时间都有远远超过一般算法，确定是一定的误识别率和删除困难。</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>一般判断一个元素是否在一个集合里，使用一个集合把所有的元素保存起来，再通过比较的方式判断。我们可能会想到使用下面的方式判断一个元素是否在集合中存在：</p>\n<ol>\n<li>在数据库中创建字段的UNIQUE属性</li>\n<li>在数据库中创建一个唯一的索引，在插入数据之前检查待插入的数据是否存在</li>\n<li>使用Set或HashSet保存数据，确保唯一</li>\n<li>使用Map或是一个定长数组记录某一个URL是否被访问过<br>但是，随着数据量不断增加，当数据达到几百G的时候。上面的方法就变的不在方便。上面的方法会占用巨大的存储空间以及随着数据增多效率降低。<br>布隆过滤器利用哈希函数将一个元素映射成一个阵列（Big array）中的一个点。这样我们只需要判断这个点是不是存在（值为1）就可以知道该元素是否存在于这个集合中。这就是布隆过滤器的思想。<br>通常布隆过滤器会使用多个hash函数计算出多个点，如果某个元素计算出的点其中有一个不再集合中我们就认为该元素肯定不再集合中。</li>\n</ol>\n<h1 id=\"布隆过滤器原理图解\"><a href=\"#布隆过滤器原理图解\" class=\"headerlink\" title=\"布隆过滤器原理图解\"></a>布隆过滤器原理图解</h1><p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k<br><img src=\"https://t1.daumcdn.net/cfile/tistory/1423AF384F50A0442F\" alt=\"布隆过滤器原理图\"><br>以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因。</p>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><p>与其他的判断方法相比，布隆过滤器在空间和时间上都有巨大的优势，布隆过滤器存储空间和插入、查询时间都是常数。布隆过滤器不存储元素本身，对信息安全要求较高的场合非常有利。</p>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>但是，布隆过滤器的确定也很明显。布隆过滤器室友误算率的。随着存入的数据增加，误算率也随之增加。如果数据量少。hash表就可以表示了。另外就是，布隆过滤器一般情况下都是不能删除元素的。</p>\n<p><a href=\"http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html\" target=\"_blank\" rel=\"external\">参考：布隆过滤器的空间、插入/询时间及误判率的数学证明</a></p>\n<h1 id=\"布隆过滤器的java实现\"><a href=\"#布隆过滤器的java实现\" class=\"headerlink\" title=\"布隆过滤器的java实现\"></a>布隆过滤器的java实现</h1><p>布隆过滤器的空间复杂度是S(n)=O(n)。下面是一个简单的布隆过滤器Java代码展示。而在查重过程也很有效率，时间复杂度是T(n)=O(1)。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> java.util.BitSet;  </div><div class=\"line\">  </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BloomFilter</span> </span>&#123;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* BitSet初始分配2^24个bit */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_SIZE = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">25</span>;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* 不同哈希函数的种子，一般应取质数 */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span>[] seeds = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">31</span>, <span class=\"number\">37</span>, <span class=\"number\">61</span> &#125;;  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"keyword\">private</span> BitSet bits = <span class=\"keyword\">new</span> BitSet(DEFAULT_SIZE);  </div><div class=\"line\">      </div><div class=\"line\">    <span class=\"comment\">/* 哈希函数对象 */</span>  </div><div class=\"line\">    <span class=\"keyword\">private</span> SimpleHash[] func = <span class=\"keyword\">new</span> SimpleHash[seeds.length];  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BloomFilter</span><span class=\"params\">()</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; seeds.length; i++) &#123;  </div><div class=\"line\">            func[i] = <span class=\"keyword\">new</span> SimpleHash(DEFAULT_SIZE, seeds[i]);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">// 将字符串标记到bits中  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(String value)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">for</span> (SimpleHash f : func) &#123;  </div><div class=\"line\">            bits.set(f.hash(value), <span class=\"keyword\">true</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">// 判断字符串是否已经被bits标记  </span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(String value)</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;  </div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">boolean</span> ret = <span class=\"keyword\">true</span>;  </div><div class=\"line\">        <span class=\"keyword\">for</span> (SimpleHash f : func) &#123;  </div><div class=\"line\">            ret = ret &amp;&amp; bits.get(f.hash(value));  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">        <span class=\"keyword\">return</span> ret;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">  </div><div class=\"line\">    <span class=\"comment\">/* 哈希函数类，可以采用成熟的hash函数 */</span>  </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleHash</span> </span>&#123;  </div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cap;  </div><div class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> seed;  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleHash</span><span class=\"params\">(<span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> seed)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">this</span>.cap = cap;  </div><div class=\"line\">            <span class=\"keyword\">this</span>.seed = seed;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">  </div><div class=\"line\">        <span class=\"comment\">// hash函数，采用简单的加权和hash  </span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(String value)</span> </span>&#123;  </div><div class=\"line\">            <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;  </div><div class=\"line\">            <span class=\"keyword\">int</span> len = value.length();  </div><div class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;  </div><div class=\"line\">                result = seed * result + value.charAt(i);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">return</span> (cap - <span class=\"number\">1</span>) &amp; result;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h1><ol>\n<li>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特），即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮件地址 X，我们用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指纹（f1, f2, …, f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, …,g8。现在我们把这八个位置的二进制全部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这些 email 地址的布隆过滤器就建成了。</li>\n<li>网络爬虫：URL去重</li>\n</ol>\n"},{"title":"微服务操作模型","date":"2017-06-11T09:28:43.000Z","_content":"\n这里不仅仅是再次重复介绍一次微服务，有关微服务的介绍可以参考[Fowler - Microservices](http://martinfowler.com/articles/microservices.htmlFowler-Microservices).相反，这篇文章是基于我们已经开始使用微服务来分解我们的应用程序以期提高我们的应用的可部署下和可伸缩性。\n当在系统环境中部署的微服务数量增加，单体式应用程序部署减少时，将遇到新的挑战，本文将重点关注这些新的挑战，并为使用大量微服务部署的系统环境定义操作模型。\n\n本文将分为下面几个部分：\n1. 前提条件\n2. 扩大\n3. 问题\n4. 必须的组件\n5. 参考模型\n\n# 1 前提条件\n首先，在系统环境中使用大量微服务需要什么？\n更具Fowler的博客中介绍，这是我们想要实现的目标：\n![](./microservices-1.png)\nSource: （http://martinfowler.com/articles/microservices.html)\n但是，我们在我们的系统环境中大量使用微服务取代我们的单体式应用程序之前，需要满足一些先决条件（部分可能不是许）：\n- 目标架构\n- 一个持续的交付工具链\n- 一个适当的组织\n\n## 1.1 目标架构\n首先，我们需要思考，我们如何划分所有微服务。例如我们可以在某些层中垂直划分我们的微服务：\n- `核心服务`：处理业务数据的持久性并应用业务规则和其他逻辑\n- `组合服务`：组合服务可以协调许多核心服务以执行常见任务或聚合来自多个核心服务的信息。\n- `API服务`：暴露允许外部使用的功能，例如：在系统环境中使用的第三方提供的基础功能。\n\n...横向，我们可以通过定义不同的域，然后根据不同的域进行分区。可形成类似下面的目标架构。\n![](./microservices-architecture.png)\nNote：这只是一个示例目标架构，您的架构可以完全不同。 这里的关键是，在开始扩展部署微服务之前，需要建立目标体系结构。 否则，您可能最终会进入一个看起来像一大碗意大利面条的系统环境（混乱不堪），其特性甚至比现有的单片应用程序更差。\n\n## 1.2 持续的交付\n我们还假设我们拥有某种连续交付工具链，以便我们能够以有效的可重复和质量驱动的方式推出我们的微服务，例如：\n![](./microservices-1-2.png)\nSource:（http://www.infoq.com/minibooks/emag-devops-toolchain)\n\n## 1.3 组织\n最后，我们假设我们采用我们的组织来避免康威定律的问题。 康威的法律规定：\n> Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure. \n\n![](./microservices-1-1.png)\nSource: (http://martinfowler.com/articles/microservices.html)\n\n# 2 扩大\n现在,提出本文关注的内容：\n> 当我们开始拆分一些单片应用程序并用大量微服务替换它们时，系统环境会发生什么？\n1. `大量的部署单元`,许多小型微服务而不是几个大型的单片应用程序，这将导致需要管理和跟踪的部署单元数量显著增加。\n2. `微服务同时是服务提供者和服务消费者`，这将导致系统环境中大多数微服务相互连接，服务调用关系更加复杂。\n3. `一些微服务将暴露外部API`，这些微服务将负责屏蔽其他微服务免受外部访问\n4. `系统环境将更加动态`，新的微服务被部署，旧的微服务被替换或移除，已有的微服务的新实例被启动以满足不断增加的负载。 这意味着服务将以前所未有的频率更替（新增，移除、替换、追加实例）。\n5. `MTBF（平均故障间隔时间）将减少`,例如:故障将在系统环境中更频繁地发生,软件组件会不时出现故障。与仅具有少量大型单片应用程序的系统环境相比，大量小型部署单元的系统环境，系统环境中的某些部件（即使很小）发生故障的可能性将会增加。\n\n# 3 问题\n这将在某些情况下会出现导致一些重要的与运行时相关的新问题：\n1. `如何配置我的微服务并且它是否正确？`处理配置不是少数应用程序的主要问题，例如 每个应用程序将自己的配置存储在磁盘上的属性文件或其自己的数据库中的配置表中。由于在多个服务器上的多个实例中部署了大量微服务，因此管理这种方法变得更加棘手。 这会导致很多小的配置文件/表遍布整个系统环境，很难以高效的方式保持良好的质量。\n2. `需要部署那些微服务，部署到哪里？`保持对少量应用程序主机和端口服务所显示的内容跟踪很简单，因为数量少且变化率低。由于大量的微服务彼此独立地部署，因此系统环境中会有或多或少的连续变化，如果手动处理，这很容易导致维护噩梦。\n3. `如果更新路由信息？`在动态系统环境中成为服务的消费者也可能具有挑战性。 特别是如果需要手动更新路由表（例如反向代理或消费者配置文件）。\n4. `如何防止连锁异常？`由于微服务将彼此互连，因此需要特别注意以避免系统环境中出现连锁的故障链。例如。 如果一些微服务依赖到一个运行失败的微服务，依赖的微服务也可能会失败等等。 如果处理不当，系统环境的大部分服务可能会受到单点故障微服务的影响，从而导致系统环境变得脆弱。\n5. `如何验证所有服务是否已启动并正在运行？`跟踪少量的应用程序的状态相当容易，但我们如何验证所有微服务是否健康并准备好接收请求？\n6. `如何跟踪服务之间的消息流动？`如果支持组织开始收到有关某些处理失败的投诉怎么办？那个微服务是发生问题的根本原因呢？如何找出发生问题的处理呢？例如：订单号12345因为微服务A无法访问或需要在微服务B发送有关该订单的确认消息之前需要手动批准而被卡住了？\n7. `如何确保只有API服务被外部公开？`例如，如何避免未经授权的外部请求访问内部服务。\n8. `如何保护API服务？`不是新的也不是微服务特有的问题，但对于保护实际暴露在外部的微服务仍然非常重要。\n\n# 4 必须的组件\n为了解决上面的问题，我们需要一下新的操作和管理方法，但是，并不是每个系统都需要这些，比如在一下仅仅运行少量应用的系统环境中，可以选用需要的功能。针对上面提出的问题的解决方案包括下面组件：\n1. `中心配置服务`，我们需要集中管理配置的中心配置服务，以替代部署单个本地配置（每个服务一个配置）。我们也需要一个用于微服务取得配置信息的配置API接口。\n2. `服务发现服务`， 我们需要一个服务发现功能，使用服务发现服务替代手工跟踪部署了的微服务当前的主机、端口。通过一个API，微服务可以再启动时自己注册微服务。\n3. `动态路由和负载均衡`， 动态路由和负载均衡器提供服务发现功能。路由组件可以使用服务发现API查找需要请求的被发布的服务，负载均衡组件可决定那个实例会被用于请求，如果有多个实例被发布用于服务请求。\n4. `熔断器`,断路器为了避免故障链问题，我们需要应用断路器模式，有关详细信息，请参阅“[Release It](https://pragprog.com/book/mnee/release-it)”一书！ 或者阅读博文[Fowler  -  Circuit Breaker](http://martinfowler.com/bliki/CircuitBreaker.html)。\n5. `监控`，我们已经安装了熔断器，我们可以监控其状态，并收集运行时统计信息，以获取系统的健康状况及其使用状况的图片。这些信息可以收集并展示在仪表盘，可以设置可配置阈值的自动警报。\n6. `集中日志分析`，集中日志分析能够跟踪消息和检测他们核实被卡住，我们需要能够链接到每个服务器并收集每个微服务产品的日志的集中日志分析功能。日志分析功能把这些日志存储到集中的数据库中并提供搜索和仪表盘功能。注意：为了能够找到相关消息，所有微服务在日志消息中使用关联的id是非常重要的。\n7. `边缘服务`，边缘服务用于在外部暴露API服务并防止未授权访问到内部服务，我们需要所有的外部流量都要通过的边缘服务。边缘服务可以基于上述服务发现组件重用代理路由和负载均衡功能。边缘服务器将充当动态和活动的反向代理，无论何时更改内部系统，都无需手动更新。\n8. `OAuth 2.0保护受保护的API`，为了保护公开的API服务，建议使用OAuth 2.0标准。 OAuth 2.0应用建议的解决方案：\n- 可用作OAuth授权服务器的新组件\n- API服务将充当OAuth资源服务\n- 外部API消费者将充当OAuth的客户端\n- 边缘服务将充当OAuth Token中继,意思是：\n    - 它将充当OAuth资源服务器\n    - 它将通过外部请求中的OAuth访问令牌传递给API服务\n注意：随着时间的推移，OAuth 2.0标准很可能会与OpenID Connect标准相辅相成，以提供改进的授权功能.\n\n# 5 参考模型\n总之，这意味着微服务需要具有如上所述的许多支持服务的基础设施，微服务使用它们的API进行交互。 这可以通过以下图片看到：\n![](./microservices-operations-reference-model.png)\n注意：为了降低图片中的复杂性，微服务和支持服务之间的交互不可视化。","source":"_posts/微服务操作模型.md","raw":"---\ntitle: 微服务操作模型\ndate: 2017-06-11 17:28:43\ncategories:\n  Microservices\ntags: \n  - Microservices\n---\n\n这里不仅仅是再次重复介绍一次微服务，有关微服务的介绍可以参考[Fowler - Microservices](http://martinfowler.com/articles/microservices.htmlFowler-Microservices).相反，这篇文章是基于我们已经开始使用微服务来分解我们的应用程序以期提高我们的应用的可部署下和可伸缩性。\n当在系统环境中部署的微服务数量增加，单体式应用程序部署减少时，将遇到新的挑战，本文将重点关注这些新的挑战，并为使用大量微服务部署的系统环境定义操作模型。\n\n本文将分为下面几个部分：\n1. 前提条件\n2. 扩大\n3. 问题\n4. 必须的组件\n5. 参考模型\n\n# 1 前提条件\n首先，在系统环境中使用大量微服务需要什么？\n更具Fowler的博客中介绍，这是我们想要实现的目标：\n![](./microservices-1.png)\nSource: （http://martinfowler.com/articles/microservices.html)\n但是，我们在我们的系统环境中大量使用微服务取代我们的单体式应用程序之前，需要满足一些先决条件（部分可能不是许）：\n- 目标架构\n- 一个持续的交付工具链\n- 一个适当的组织\n\n## 1.1 目标架构\n首先，我们需要思考，我们如何划分所有微服务。例如我们可以在某些层中垂直划分我们的微服务：\n- `核心服务`：处理业务数据的持久性并应用业务规则和其他逻辑\n- `组合服务`：组合服务可以协调许多核心服务以执行常见任务或聚合来自多个核心服务的信息。\n- `API服务`：暴露允许外部使用的功能，例如：在系统环境中使用的第三方提供的基础功能。\n\n...横向，我们可以通过定义不同的域，然后根据不同的域进行分区。可形成类似下面的目标架构。\n![](./microservices-architecture.png)\nNote：这只是一个示例目标架构，您的架构可以完全不同。 这里的关键是，在开始扩展部署微服务之前，需要建立目标体系结构。 否则，您可能最终会进入一个看起来像一大碗意大利面条的系统环境（混乱不堪），其特性甚至比现有的单片应用程序更差。\n\n## 1.2 持续的交付\n我们还假设我们拥有某种连续交付工具链，以便我们能够以有效的可重复和质量驱动的方式推出我们的微服务，例如：\n![](./microservices-1-2.png)\nSource:（http://www.infoq.com/minibooks/emag-devops-toolchain)\n\n## 1.3 组织\n最后，我们假设我们采用我们的组织来避免康威定律的问题。 康威的法律规定：\n> Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure. \n\n![](./microservices-1-1.png)\nSource: (http://martinfowler.com/articles/microservices.html)\n\n# 2 扩大\n现在,提出本文关注的内容：\n> 当我们开始拆分一些单片应用程序并用大量微服务替换它们时，系统环境会发生什么？\n1. `大量的部署单元`,许多小型微服务而不是几个大型的单片应用程序，这将导致需要管理和跟踪的部署单元数量显著增加。\n2. `微服务同时是服务提供者和服务消费者`，这将导致系统环境中大多数微服务相互连接，服务调用关系更加复杂。\n3. `一些微服务将暴露外部API`，这些微服务将负责屏蔽其他微服务免受外部访问\n4. `系统环境将更加动态`，新的微服务被部署，旧的微服务被替换或移除，已有的微服务的新实例被启动以满足不断增加的负载。 这意味着服务将以前所未有的频率更替（新增，移除、替换、追加实例）。\n5. `MTBF（平均故障间隔时间）将减少`,例如:故障将在系统环境中更频繁地发生,软件组件会不时出现故障。与仅具有少量大型单片应用程序的系统环境相比，大量小型部署单元的系统环境，系统环境中的某些部件（即使很小）发生故障的可能性将会增加。\n\n# 3 问题\n这将在某些情况下会出现导致一些重要的与运行时相关的新问题：\n1. `如何配置我的微服务并且它是否正确？`处理配置不是少数应用程序的主要问题，例如 每个应用程序将自己的配置存储在磁盘上的属性文件或其自己的数据库中的配置表中。由于在多个服务器上的多个实例中部署了大量微服务，因此管理这种方法变得更加棘手。 这会导致很多小的配置文件/表遍布整个系统环境，很难以高效的方式保持良好的质量。\n2. `需要部署那些微服务，部署到哪里？`保持对少量应用程序主机和端口服务所显示的内容跟踪很简单，因为数量少且变化率低。由于大量的微服务彼此独立地部署，因此系统环境中会有或多或少的连续变化，如果手动处理，这很容易导致维护噩梦。\n3. `如果更新路由信息？`在动态系统环境中成为服务的消费者也可能具有挑战性。 特别是如果需要手动更新路由表（例如反向代理或消费者配置文件）。\n4. `如何防止连锁异常？`由于微服务将彼此互连，因此需要特别注意以避免系统环境中出现连锁的故障链。例如。 如果一些微服务依赖到一个运行失败的微服务，依赖的微服务也可能会失败等等。 如果处理不当，系统环境的大部分服务可能会受到单点故障微服务的影响，从而导致系统环境变得脆弱。\n5. `如何验证所有服务是否已启动并正在运行？`跟踪少量的应用程序的状态相当容易，但我们如何验证所有微服务是否健康并准备好接收请求？\n6. `如何跟踪服务之间的消息流动？`如果支持组织开始收到有关某些处理失败的投诉怎么办？那个微服务是发生问题的根本原因呢？如何找出发生问题的处理呢？例如：订单号12345因为微服务A无法访问或需要在微服务B发送有关该订单的确认消息之前需要手动批准而被卡住了？\n7. `如何确保只有API服务被外部公开？`例如，如何避免未经授权的外部请求访问内部服务。\n8. `如何保护API服务？`不是新的也不是微服务特有的问题，但对于保护实际暴露在外部的微服务仍然非常重要。\n\n# 4 必须的组件\n为了解决上面的问题，我们需要一下新的操作和管理方法，但是，并不是每个系统都需要这些，比如在一下仅仅运行少量应用的系统环境中，可以选用需要的功能。针对上面提出的问题的解决方案包括下面组件：\n1. `中心配置服务`，我们需要集中管理配置的中心配置服务，以替代部署单个本地配置（每个服务一个配置）。我们也需要一个用于微服务取得配置信息的配置API接口。\n2. `服务发现服务`， 我们需要一个服务发现功能，使用服务发现服务替代手工跟踪部署了的微服务当前的主机、端口。通过一个API，微服务可以再启动时自己注册微服务。\n3. `动态路由和负载均衡`， 动态路由和负载均衡器提供服务发现功能。路由组件可以使用服务发现API查找需要请求的被发布的服务，负载均衡组件可决定那个实例会被用于请求，如果有多个实例被发布用于服务请求。\n4. `熔断器`,断路器为了避免故障链问题，我们需要应用断路器模式，有关详细信息，请参阅“[Release It](https://pragprog.com/book/mnee/release-it)”一书！ 或者阅读博文[Fowler  -  Circuit Breaker](http://martinfowler.com/bliki/CircuitBreaker.html)。\n5. `监控`，我们已经安装了熔断器，我们可以监控其状态，并收集运行时统计信息，以获取系统的健康状况及其使用状况的图片。这些信息可以收集并展示在仪表盘，可以设置可配置阈值的自动警报。\n6. `集中日志分析`，集中日志分析能够跟踪消息和检测他们核实被卡住，我们需要能够链接到每个服务器并收集每个微服务产品的日志的集中日志分析功能。日志分析功能把这些日志存储到集中的数据库中并提供搜索和仪表盘功能。注意：为了能够找到相关消息，所有微服务在日志消息中使用关联的id是非常重要的。\n7. `边缘服务`，边缘服务用于在外部暴露API服务并防止未授权访问到内部服务，我们需要所有的外部流量都要通过的边缘服务。边缘服务可以基于上述服务发现组件重用代理路由和负载均衡功能。边缘服务器将充当动态和活动的反向代理，无论何时更改内部系统，都无需手动更新。\n8. `OAuth 2.0保护受保护的API`，为了保护公开的API服务，建议使用OAuth 2.0标准。 OAuth 2.0应用建议的解决方案：\n- 可用作OAuth授权服务器的新组件\n- API服务将充当OAuth资源服务\n- 外部API消费者将充当OAuth的客户端\n- 边缘服务将充当OAuth Token中继,意思是：\n    - 它将充当OAuth资源服务器\n    - 它将通过外部请求中的OAuth访问令牌传递给API服务\n注意：随着时间的推移，OAuth 2.0标准很可能会与OpenID Connect标准相辅相成，以提供改进的授权功能.\n\n# 5 参考模型\n总之，这意味着微服务需要具有如上所述的许多支持服务的基础设施，微服务使用它们的API进行交互。 这可以通过以下图片看到：\n![](./microservices-operations-reference-model.png)\n注意：为了降低图片中的复杂性，微服务和支持服务之间的交互不可视化。","slug":"微服务操作模型","published":1,"updated":"2019-03-05T02:38:59.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja39u001e44eihpsq9wnz","content":"<p>这里不仅仅是再次重复介绍一次微服务，有关微服务的介绍可以参考<a href=\"http://martinfowler.com/articles/microservices.htmlFowler-Microservices\" target=\"_blank\" rel=\"external\">Fowler - Microservices</a>.相反，这篇文章是基于我们已经开始使用微服务来分解我们的应用程序以期提高我们的应用的可部署下和可伸缩性。<br>当在系统环境中部署的微服务数量增加，单体式应用程序部署减少时，将遇到新的挑战，本文将重点关注这些新的挑战，并为使用大量微服务部署的系统环境定义操作模型。</p>\n<p>本文将分为下面几个部分：</p>\n<ol>\n<li>前提条件</li>\n<li>扩大</li>\n<li>问题</li>\n<li>必须的组件</li>\n<li>参考模型</li>\n</ol>\n<h1 id=\"1-前提条件\"><a href=\"#1-前提条件\" class=\"headerlink\" title=\"1 前提条件\"></a>1 前提条件</h1><p>首先，在系统环境中使用大量微服务需要什么？<br>更具Fowler的博客中介绍，这是我们想要实现的目标：<br><img src=\"./microservices-1.png\" alt=\"\"><br>Source: （<a href=\"http://martinfowler.com/articles/microservices.html\" target=\"_blank\" rel=\"external\">http://martinfowler.com/articles/microservices.html</a>)<br>但是，我们在我们的系统环境中大量使用微服务取代我们的单体式应用程序之前，需要满足一些先决条件（部分可能不是许）：</p>\n<ul>\n<li>目标架构</li>\n<li>一个持续的交付工具链</li>\n<li>一个适当的组织</li>\n</ul>\n<h2 id=\"1-1-目标架构\"><a href=\"#1-1-目标架构\" class=\"headerlink\" title=\"1.1 目标架构\"></a>1.1 目标架构</h2><p>首先，我们需要思考，我们如何划分所有微服务。例如我们可以在某些层中垂直划分我们的微服务：</p>\n<ul>\n<li><code>核心服务</code>：处理业务数据的持久性并应用业务规则和其他逻辑</li>\n<li><code>组合服务</code>：组合服务可以协调许多核心服务以执行常见任务或聚合来自多个核心服务的信息。</li>\n<li><code>API服务</code>：暴露允许外部使用的功能，例如：在系统环境中使用的第三方提供的基础功能。</li>\n</ul>\n<p>…横向，我们可以通过定义不同的域，然后根据不同的域进行分区。可形成类似下面的目标架构。<br><img src=\"./microservices-architecture.png\" alt=\"\"><br>Note：这只是一个示例目标架构，您的架构可以完全不同。 这里的关键是，在开始扩展部署微服务之前，需要建立目标体系结构。 否则，您可能最终会进入一个看起来像一大碗意大利面条的系统环境（混乱不堪），其特性甚至比现有的单片应用程序更差。</p>\n<h2 id=\"1-2-持续的交付\"><a href=\"#1-2-持续的交付\" class=\"headerlink\" title=\"1.2 持续的交付\"></a>1.2 持续的交付</h2><p>我们还假设我们拥有某种连续交付工具链，以便我们能够以有效的可重复和质量驱动的方式推出我们的微服务，例如：<br><img src=\"./microservices-1-2.png\" alt=\"\"><br>Source:（<a href=\"http://www.infoq.com/minibooks/emag-devops-toolchain\" target=\"_blank\" rel=\"external\">http://www.infoq.com/minibooks/emag-devops-toolchain</a>)</p>\n<h2 id=\"1-3-组织\"><a href=\"#1-3-组织\" class=\"headerlink\" title=\"1.3 组织\"></a>1.3 组织</h2><p>最后，我们假设我们采用我们的组织来避免康威定律的问题。 康威的法律规定：</p>\n<blockquote>\n<p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure. </p>\n</blockquote>\n<p><img src=\"./microservices-1-1.png\" alt=\"\"><br>Source: (<a href=\"http://martinfowler.com/articles/microservices.html\" target=\"_blank\" rel=\"external\">http://martinfowler.com/articles/microservices.html</a>)</p>\n<h1 id=\"2-扩大\"><a href=\"#2-扩大\" class=\"headerlink\" title=\"2 扩大\"></a>2 扩大</h1><p>现在,提出本文关注的内容：</p>\n<blockquote>\n<p>当我们开始拆分一些单片应用程序并用大量微服务替换它们时，系统环境会发生什么？</p>\n<ol>\n<li><code>大量的部署单元</code>,许多小型微服务而不是几个大型的单片应用程序，这将导致需要管理和跟踪的部署单元数量显著增加。</li>\n<li><code>微服务同时是服务提供者和服务消费者</code>，这将导致系统环境中大多数微服务相互连接，服务调用关系更加复杂。</li>\n<li><code>一些微服务将暴露外部API</code>，这些微服务将负责屏蔽其他微服务免受外部访问</li>\n<li><code>系统环境将更加动态</code>，新的微服务被部署，旧的微服务被替换或移除，已有的微服务的新实例被启动以满足不断增加的负载。 这意味着服务将以前所未有的频率更替（新增，移除、替换、追加实例）。</li>\n<li><code>MTBF（平均故障间隔时间）将减少</code>,例如:故障将在系统环境中更频繁地发生,软件组件会不时出现故障。与仅具有少量大型单片应用程序的系统环境相比，大量小型部署单元的系统环境，系统环境中的某些部件（即使很小）发生故障的可能性将会增加。</li>\n</ol>\n</blockquote>\n<h1 id=\"3-问题\"><a href=\"#3-问题\" class=\"headerlink\" title=\"3 问题\"></a>3 问题</h1><p>这将在某些情况下会出现导致一些重要的与运行时相关的新问题：</p>\n<ol>\n<li><code>如何配置我的微服务并且它是否正确？</code>处理配置不是少数应用程序的主要问题，例如 每个应用程序将自己的配置存储在磁盘上的属性文件或其自己的数据库中的配置表中。由于在多个服务器上的多个实例中部署了大量微服务，因此管理这种方法变得更加棘手。 这会导致很多小的配置文件/表遍布整个系统环境，很难以高效的方式保持良好的质量。</li>\n<li><code>需要部署那些微服务，部署到哪里？</code>保持对少量应用程序主机和端口服务所显示的内容跟踪很简单，因为数量少且变化率低。由于大量的微服务彼此独立地部署，因此系统环境中会有或多或少的连续变化，如果手动处理，这很容易导致维护噩梦。</li>\n<li><code>如果更新路由信息？</code>在动态系统环境中成为服务的消费者也可能具有挑战性。 特别是如果需要手动更新路由表（例如反向代理或消费者配置文件）。</li>\n<li><code>如何防止连锁异常？</code>由于微服务将彼此互连，因此需要特别注意以避免系统环境中出现连锁的故障链。例如。 如果一些微服务依赖到一个运行失败的微服务，依赖的微服务也可能会失败等等。 如果处理不当，系统环境的大部分服务可能会受到单点故障微服务的影响，从而导致系统环境变得脆弱。</li>\n<li><code>如何验证所有服务是否已启动并正在运行？</code>跟踪少量的应用程序的状态相当容易，但我们如何验证所有微服务是否健康并准备好接收请求？</li>\n<li><code>如何跟踪服务之间的消息流动？</code>如果支持组织开始收到有关某些处理失败的投诉怎么办？那个微服务是发生问题的根本原因呢？如何找出发生问题的处理呢？例如：订单号12345因为微服务A无法访问或需要在微服务B发送有关该订单的确认消息之前需要手动批准而被卡住了？</li>\n<li><code>如何确保只有API服务被外部公开？</code>例如，如何避免未经授权的外部请求访问内部服务。</li>\n<li><code>如何保护API服务？</code>不是新的也不是微服务特有的问题，但对于保护实际暴露在外部的微服务仍然非常重要。</li>\n</ol>\n<h1 id=\"4-必须的组件\"><a href=\"#4-必须的组件\" class=\"headerlink\" title=\"4 必须的组件\"></a>4 必须的组件</h1><p>为了解决上面的问题，我们需要一下新的操作和管理方法，但是，并不是每个系统都需要这些，比如在一下仅仅运行少量应用的系统环境中，可以选用需要的功能。针对上面提出的问题的解决方案包括下面组件：</p>\n<ol>\n<li><code>中心配置服务</code>，我们需要集中管理配置的中心配置服务，以替代部署单个本地配置（每个服务一个配置）。我们也需要一个用于微服务取得配置信息的配置API接口。</li>\n<li><code>服务发现服务</code>， 我们需要一个服务发现功能，使用服务发现服务替代手工跟踪部署了的微服务当前的主机、端口。通过一个API，微服务可以再启动时自己注册微服务。</li>\n<li><code>动态路由和负载均衡</code>， 动态路由和负载均衡器提供服务发现功能。路由组件可以使用服务发现API查找需要请求的被发布的服务，负载均衡组件可决定那个实例会被用于请求，如果有多个实例被发布用于服务请求。</li>\n<li><code>熔断器</code>,断路器为了避免故障链问题，我们需要应用断路器模式，有关详细信息，请参阅“<a href=\"https://pragprog.com/book/mnee/release-it\" target=\"_blank\" rel=\"external\">Release It</a>”一书！ 或者阅读博文<a href=\"http://martinfowler.com/bliki/CircuitBreaker.html\" target=\"_blank\" rel=\"external\">Fowler  -  Circuit Breaker</a>。</li>\n<li><code>监控</code>，我们已经安装了熔断器，我们可以监控其状态，并收集运行时统计信息，以获取系统的健康状况及其使用状况的图片。这些信息可以收集并展示在仪表盘，可以设置可配置阈值的自动警报。</li>\n<li><code>集中日志分析</code>，集中日志分析能够跟踪消息和检测他们核实被卡住，我们需要能够链接到每个服务器并收集每个微服务产品的日志的集中日志分析功能。日志分析功能把这些日志存储到集中的数据库中并提供搜索和仪表盘功能。注意：为了能够找到相关消息，所有微服务在日志消息中使用关联的id是非常重要的。</li>\n<li><code>边缘服务</code>，边缘服务用于在外部暴露API服务并防止未授权访问到内部服务，我们需要所有的外部流量都要通过的边缘服务。边缘服务可以基于上述服务发现组件重用代理路由和负载均衡功能。边缘服务器将充当动态和活动的反向代理，无论何时更改内部系统，都无需手动更新。</li>\n<li><code>OAuth 2.0保护受保护的API</code>，为了保护公开的API服务，建议使用OAuth 2.0标准。 OAuth 2.0应用建议的解决方案：</li>\n</ol>\n<ul>\n<li>可用作OAuth授权服务器的新组件</li>\n<li>API服务将充当OAuth资源服务</li>\n<li>外部API消费者将充当OAuth的客户端</li>\n<li>边缘服务将充当OAuth Token中继,意思是：<ul>\n<li>它将充当OAuth资源服务器</li>\n<li>它将通过外部请求中的OAuth访问令牌传递给API服务<br>注意：随着时间的推移，OAuth 2.0标准很可能会与OpenID Connect标准相辅相成，以提供改进的授权功能.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-参考模型\"><a href=\"#5-参考模型\" class=\"headerlink\" title=\"5 参考模型\"></a>5 参考模型</h1><p>总之，这意味着微服务需要具有如上所述的许多支持服务的基础设施，微服务使用它们的API进行交互。 这可以通过以下图片看到：<br><img src=\"./microservices-operations-reference-model.png\" alt=\"\"><br>注意：为了降低图片中的复杂性，微服务和支持服务之间的交互不可视化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里不仅仅是再次重复介绍一次微服务，有关微服务的介绍可以参考<a href=\"http://martinfowler.com/articles/microservices.htmlFowler-Microservices\" target=\"_blank\" rel=\"external\">Fowler - Microservices</a>.相反，这篇文章是基于我们已经开始使用微服务来分解我们的应用程序以期提高我们的应用的可部署下和可伸缩性。<br>当在系统环境中部署的微服务数量增加，单体式应用程序部署减少时，将遇到新的挑战，本文将重点关注这些新的挑战，并为使用大量微服务部署的系统环境定义操作模型。</p>\n<p>本文将分为下面几个部分：</p>\n<ol>\n<li>前提条件</li>\n<li>扩大</li>\n<li>问题</li>\n<li>必须的组件</li>\n<li>参考模型</li>\n</ol>\n<h1 id=\"1-前提条件\"><a href=\"#1-前提条件\" class=\"headerlink\" title=\"1 前提条件\"></a>1 前提条件</h1><p>首先，在系统环境中使用大量微服务需要什么？<br>更具Fowler的博客中介绍，这是我们想要实现的目标：<br><img src=\"./microservices-1.png\" alt=\"\"><br>Source: （<a href=\"http://martinfowler.com/articles/microservices.html\" target=\"_blank\" rel=\"external\">http://martinfowler.com/articles/microservices.html</a>)<br>但是，我们在我们的系统环境中大量使用微服务取代我们的单体式应用程序之前，需要满足一些先决条件（部分可能不是许）：</p>\n<ul>\n<li>目标架构</li>\n<li>一个持续的交付工具链</li>\n<li>一个适当的组织</li>\n</ul>\n<h2 id=\"1-1-目标架构\"><a href=\"#1-1-目标架构\" class=\"headerlink\" title=\"1.1 目标架构\"></a>1.1 目标架构</h2><p>首先，我们需要思考，我们如何划分所有微服务。例如我们可以在某些层中垂直划分我们的微服务：</p>\n<ul>\n<li><code>核心服务</code>：处理业务数据的持久性并应用业务规则和其他逻辑</li>\n<li><code>组合服务</code>：组合服务可以协调许多核心服务以执行常见任务或聚合来自多个核心服务的信息。</li>\n<li><code>API服务</code>：暴露允许外部使用的功能，例如：在系统环境中使用的第三方提供的基础功能。</li>\n</ul>\n<p>…横向，我们可以通过定义不同的域，然后根据不同的域进行分区。可形成类似下面的目标架构。<br><img src=\"./microservices-architecture.png\" alt=\"\"><br>Note：这只是一个示例目标架构，您的架构可以完全不同。 这里的关键是，在开始扩展部署微服务之前，需要建立目标体系结构。 否则，您可能最终会进入一个看起来像一大碗意大利面条的系统环境（混乱不堪），其特性甚至比现有的单片应用程序更差。</p>\n<h2 id=\"1-2-持续的交付\"><a href=\"#1-2-持续的交付\" class=\"headerlink\" title=\"1.2 持续的交付\"></a>1.2 持续的交付</h2><p>我们还假设我们拥有某种连续交付工具链，以便我们能够以有效的可重复和质量驱动的方式推出我们的微服务，例如：<br><img src=\"./microservices-1-2.png\" alt=\"\"><br>Source:（<a href=\"http://www.infoq.com/minibooks/emag-devops-toolchain\" target=\"_blank\" rel=\"external\">http://www.infoq.com/minibooks/emag-devops-toolchain</a>)</p>\n<h2 id=\"1-3-组织\"><a href=\"#1-3-组织\" class=\"headerlink\" title=\"1.3 组织\"></a>1.3 组织</h2><p>最后，我们假设我们采用我们的组织来避免康威定律的问题。 康威的法律规定：</p>\n<blockquote>\n<p>Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization’s communication structure. </p>\n</blockquote>\n<p><img src=\"./microservices-1-1.png\" alt=\"\"><br>Source: (<a href=\"http://martinfowler.com/articles/microservices.html\" target=\"_blank\" rel=\"external\">http://martinfowler.com/articles/microservices.html</a>)</p>\n<h1 id=\"2-扩大\"><a href=\"#2-扩大\" class=\"headerlink\" title=\"2 扩大\"></a>2 扩大</h1><p>现在,提出本文关注的内容：</p>\n<blockquote>\n<p>当我们开始拆分一些单片应用程序并用大量微服务替换它们时，系统环境会发生什么？</p>\n<ol>\n<li><code>大量的部署单元</code>,许多小型微服务而不是几个大型的单片应用程序，这将导致需要管理和跟踪的部署单元数量显著增加。</li>\n<li><code>微服务同时是服务提供者和服务消费者</code>，这将导致系统环境中大多数微服务相互连接，服务调用关系更加复杂。</li>\n<li><code>一些微服务将暴露外部API</code>，这些微服务将负责屏蔽其他微服务免受外部访问</li>\n<li><code>系统环境将更加动态</code>，新的微服务被部署，旧的微服务被替换或移除，已有的微服务的新实例被启动以满足不断增加的负载。 这意味着服务将以前所未有的频率更替（新增，移除、替换、追加实例）。</li>\n<li><code>MTBF（平均故障间隔时间）将减少</code>,例如:故障将在系统环境中更频繁地发生,软件组件会不时出现故障。与仅具有少量大型单片应用程序的系统环境相比，大量小型部署单元的系统环境，系统环境中的某些部件（即使很小）发生故障的可能性将会增加。</li>\n</ol>\n</blockquote>\n<h1 id=\"3-问题\"><a href=\"#3-问题\" class=\"headerlink\" title=\"3 问题\"></a>3 问题</h1><p>这将在某些情况下会出现导致一些重要的与运行时相关的新问题：</p>\n<ol>\n<li><code>如何配置我的微服务并且它是否正确？</code>处理配置不是少数应用程序的主要问题，例如 每个应用程序将自己的配置存储在磁盘上的属性文件或其自己的数据库中的配置表中。由于在多个服务器上的多个实例中部署了大量微服务，因此管理这种方法变得更加棘手。 这会导致很多小的配置文件/表遍布整个系统环境，很难以高效的方式保持良好的质量。</li>\n<li><code>需要部署那些微服务，部署到哪里？</code>保持对少量应用程序主机和端口服务所显示的内容跟踪很简单，因为数量少且变化率低。由于大量的微服务彼此独立地部署，因此系统环境中会有或多或少的连续变化，如果手动处理，这很容易导致维护噩梦。</li>\n<li><code>如果更新路由信息？</code>在动态系统环境中成为服务的消费者也可能具有挑战性。 特别是如果需要手动更新路由表（例如反向代理或消费者配置文件）。</li>\n<li><code>如何防止连锁异常？</code>由于微服务将彼此互连，因此需要特别注意以避免系统环境中出现连锁的故障链。例如。 如果一些微服务依赖到一个运行失败的微服务，依赖的微服务也可能会失败等等。 如果处理不当，系统环境的大部分服务可能会受到单点故障微服务的影响，从而导致系统环境变得脆弱。</li>\n<li><code>如何验证所有服务是否已启动并正在运行？</code>跟踪少量的应用程序的状态相当容易，但我们如何验证所有微服务是否健康并准备好接收请求？</li>\n<li><code>如何跟踪服务之间的消息流动？</code>如果支持组织开始收到有关某些处理失败的投诉怎么办？那个微服务是发生问题的根本原因呢？如何找出发生问题的处理呢？例如：订单号12345因为微服务A无法访问或需要在微服务B发送有关该订单的确认消息之前需要手动批准而被卡住了？</li>\n<li><code>如何确保只有API服务被外部公开？</code>例如，如何避免未经授权的外部请求访问内部服务。</li>\n<li><code>如何保护API服务？</code>不是新的也不是微服务特有的问题，但对于保护实际暴露在外部的微服务仍然非常重要。</li>\n</ol>\n<h1 id=\"4-必须的组件\"><a href=\"#4-必须的组件\" class=\"headerlink\" title=\"4 必须的组件\"></a>4 必须的组件</h1><p>为了解决上面的问题，我们需要一下新的操作和管理方法，但是，并不是每个系统都需要这些，比如在一下仅仅运行少量应用的系统环境中，可以选用需要的功能。针对上面提出的问题的解决方案包括下面组件：</p>\n<ol>\n<li><code>中心配置服务</code>，我们需要集中管理配置的中心配置服务，以替代部署单个本地配置（每个服务一个配置）。我们也需要一个用于微服务取得配置信息的配置API接口。</li>\n<li><code>服务发现服务</code>， 我们需要一个服务发现功能，使用服务发现服务替代手工跟踪部署了的微服务当前的主机、端口。通过一个API，微服务可以再启动时自己注册微服务。</li>\n<li><code>动态路由和负载均衡</code>， 动态路由和负载均衡器提供服务发现功能。路由组件可以使用服务发现API查找需要请求的被发布的服务，负载均衡组件可决定那个实例会被用于请求，如果有多个实例被发布用于服务请求。</li>\n<li><code>熔断器</code>,断路器为了避免故障链问题，我们需要应用断路器模式，有关详细信息，请参阅“<a href=\"https://pragprog.com/book/mnee/release-it\" target=\"_blank\" rel=\"external\">Release It</a>”一书！ 或者阅读博文<a href=\"http://martinfowler.com/bliki/CircuitBreaker.html\" target=\"_blank\" rel=\"external\">Fowler  -  Circuit Breaker</a>。</li>\n<li><code>监控</code>，我们已经安装了熔断器，我们可以监控其状态，并收集运行时统计信息，以获取系统的健康状况及其使用状况的图片。这些信息可以收集并展示在仪表盘，可以设置可配置阈值的自动警报。</li>\n<li><code>集中日志分析</code>，集中日志分析能够跟踪消息和检测他们核实被卡住，我们需要能够链接到每个服务器并收集每个微服务产品的日志的集中日志分析功能。日志分析功能把这些日志存储到集中的数据库中并提供搜索和仪表盘功能。注意：为了能够找到相关消息，所有微服务在日志消息中使用关联的id是非常重要的。</li>\n<li><code>边缘服务</code>，边缘服务用于在外部暴露API服务并防止未授权访问到内部服务，我们需要所有的外部流量都要通过的边缘服务。边缘服务可以基于上述服务发现组件重用代理路由和负载均衡功能。边缘服务器将充当动态和活动的反向代理，无论何时更改内部系统，都无需手动更新。</li>\n<li><code>OAuth 2.0保护受保护的API</code>，为了保护公开的API服务，建议使用OAuth 2.0标准。 OAuth 2.0应用建议的解决方案：</li>\n</ol>\n<ul>\n<li>可用作OAuth授权服务器的新组件</li>\n<li>API服务将充当OAuth资源服务</li>\n<li>外部API消费者将充当OAuth的客户端</li>\n<li>边缘服务将充当OAuth Token中继,意思是：<ul>\n<li>它将充当OAuth资源服务器</li>\n<li>它将通过外部请求中的OAuth访问令牌传递给API服务<br>注意：随着时间的推移，OAuth 2.0标准很可能会与OpenID Connect标准相辅相成，以提供改进的授权功能.</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"5-参考模型\"><a href=\"#5-参考模型\" class=\"headerlink\" title=\"5 参考模型\"></a>5 参考模型</h1><p>总之，这意味着微服务需要具有如上所述的许多支持服务的基础设施，微服务使用它们的API进行交互。 这可以通过以下图片看到：<br><img src=\"./microservices-operations-reference-model.png\" alt=\"\"><br>注意：为了降低图片中的复杂性，微服务和支持服务之间的交互不可视化。</p>\n"},{"title":"软件架构","date":"2018-03-11T06:05:32.000Z","_content":"\n# 什么是软件架构\n要理解什么是软件架构，首先需要知道架构是什么，架构一词其实是来自英文单词Architecture，表示建筑，体系结构的意思。这里引用了其体系结构的意思，维基百科英文版里对 Architecture 的解释是：规划、设计和建造建筑物的过程及产物。在计算机软件领域，软件架构就成为了描述软件规划设计技术的专有名词。\n虽然我们对‘架构’做了解释。但是对于软件架构的概念定义并不那么简单，而且也没有一个统一的定义。\n现在对于软件架构的定义分为两大流派，组成派和决策派：\n## 组成派\n>  软件系统的架构将系统描述为计算机组件及组件之间的交互。（The architecture of a software system defined that system in terms of computational components and interactions among those components.）\n\n这个是Mary Shaw在《软件体系结构：一门初露端倪学科的展望》中为“软件架构”给出定义。这个定义是把系统划分为以组件为单位的一个集合。而软件架构就是用于描述组成整个系统中的组件集合中组件与组件之间相互交互。这里的组件可以是一个类、库、模块、框架、一个子系统等等，每个组件负责一个职责。组件可以是粗粒度的也可以是细粒度的，不同的场景描述的组将粒度可能不一样。\n组成派的软件架构定义的特点：\n1. 关注架构实践中的客体---软件，以软件本身为描述对象；\n2. 软件是由承担不同职责的组件组成，这些组件通过相互交互组成一个系统或者说另外一个组件。\n\n## 决策派\n> 软件架构包含了关于一下问题的重要决策： \n> * 软件系统的组织；\n> * 选择组成系统的结构元素和同门之间的接口，以及当这些元素相互协作是所体现的行为\n> * 如何组合这些元素，使它们逐渐合成为更大的子系统；\n> * 用于指导这个系统组织的架构风格：这些元素以及它们的结构、协作和组合。\n> * 软件架构并不仅仅注重软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解性、经济和技术的限制及权衡，以及美学等。\n\n这是“决策派”软件架构概念的典型代表，决策派的软件架构定义特点： \n1. 关注架构实践中的主体--人，一人的决策为描述对象。\n2. 归纳了架构决策的类型，指出架构决策不仅包括关于软件系统的组织、元素、子系统和架构风格等。还包括关于众多非功能需求的决策。\n\n## 著名软件架构定义\n我们知道软架构没有一个统一的定义，且分为为组件派和决策派。这只是站在不同角度看问题的不同理解。下面我就列举几个著名的软件架构定义。从这些定义，我们也能看出提出者的思考方向，我们也可以结合这些定义和我们自己工作实践自己体会软件架构的意义。\n1. Booch、Rumbaugh和Jacobson对软件架构的定义：\n架构是一系列重要决策的集合，这些决策与一下内容有关：软件的组织，构成系统的结构元素及其接口的选择，这些元素在相互协作中明确表现出的行为，这些结构元素和行为元素进一步组合所构成的更大更一抹的子系统，以及指导这一组织--包括这些元素及及其接口、他们的协作和他们的组合--架构风格。\n2. Garlan和Shaw的定义：\n架构包括组件（Component）、连接件（Connector）和约束（Constrain）三大要素。组件可以是一组代码（例如：一个代码块、一个库、一个模块），也可以是独立的程序（例如：数据库程序，一个独立的子系统）。连接件可以是过程调用、管道和消息等，用于表示组件之间的相互关系。约束，一般为组件连接时的条件。\n3. Perry和Wolf的定义：\n架构是一组具有特定形式的架构元素，这些元素分为三类：负责完成数据加工的处理元素（Processing Elements）、作为被加工的信息数据元素（Data Elements）及孕育吧架构不同部分组合在一起的连接元素（Connecting Elements）。\n\n# 软件架构解析\n## 软件架构关注分割与交互\n软件设计其实就是一个分与合的过程。软件架构其实就是设计组件与组件之间的交互，同时也是一系列决策的结果。我们需要决定模块如何划分，每个模块的职责，模块接口如何定义，模块与模块采用何种交互机制(RPC,Massage..),开发技术选型，如何满足质量属性和约束的要求，如何适应变化，等等。","source":"_posts/软件架构.md","raw":"---\ntitle: 软件架构\ndate: 2018-03-11 14:05:32\ncategories:\n  软件架构设计 \ntags:\n  - 架构设计\n---\n\n# 什么是软件架构\n要理解什么是软件架构，首先需要知道架构是什么，架构一词其实是来自英文单词Architecture，表示建筑，体系结构的意思。这里引用了其体系结构的意思，维基百科英文版里对 Architecture 的解释是：规划、设计和建造建筑物的过程及产物。在计算机软件领域，软件架构就成为了描述软件规划设计技术的专有名词。\n虽然我们对‘架构’做了解释。但是对于软件架构的概念定义并不那么简单，而且也没有一个统一的定义。\n现在对于软件架构的定义分为两大流派，组成派和决策派：\n## 组成派\n>  软件系统的架构将系统描述为计算机组件及组件之间的交互。（The architecture of a software system defined that system in terms of computational components and interactions among those components.）\n\n这个是Mary Shaw在《软件体系结构：一门初露端倪学科的展望》中为“软件架构”给出定义。这个定义是把系统划分为以组件为单位的一个集合。而软件架构就是用于描述组成整个系统中的组件集合中组件与组件之间相互交互。这里的组件可以是一个类、库、模块、框架、一个子系统等等，每个组件负责一个职责。组件可以是粗粒度的也可以是细粒度的，不同的场景描述的组将粒度可能不一样。\n组成派的软件架构定义的特点：\n1. 关注架构实践中的客体---软件，以软件本身为描述对象；\n2. 软件是由承担不同职责的组件组成，这些组件通过相互交互组成一个系统或者说另外一个组件。\n\n## 决策派\n> 软件架构包含了关于一下问题的重要决策： \n> * 软件系统的组织；\n> * 选择组成系统的结构元素和同门之间的接口，以及当这些元素相互协作是所体现的行为\n> * 如何组合这些元素，使它们逐渐合成为更大的子系统；\n> * 用于指导这个系统组织的架构风格：这些元素以及它们的结构、协作和组合。\n> * 软件架构并不仅仅注重软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解性、经济和技术的限制及权衡，以及美学等。\n\n这是“决策派”软件架构概念的典型代表，决策派的软件架构定义特点： \n1. 关注架构实践中的主体--人，一人的决策为描述对象。\n2. 归纳了架构决策的类型，指出架构决策不仅包括关于软件系统的组织、元素、子系统和架构风格等。还包括关于众多非功能需求的决策。\n\n## 著名软件架构定义\n我们知道软架构没有一个统一的定义，且分为为组件派和决策派。这只是站在不同角度看问题的不同理解。下面我就列举几个著名的软件架构定义。从这些定义，我们也能看出提出者的思考方向，我们也可以结合这些定义和我们自己工作实践自己体会软件架构的意义。\n1. Booch、Rumbaugh和Jacobson对软件架构的定义：\n架构是一系列重要决策的集合，这些决策与一下内容有关：软件的组织，构成系统的结构元素及其接口的选择，这些元素在相互协作中明确表现出的行为，这些结构元素和行为元素进一步组合所构成的更大更一抹的子系统，以及指导这一组织--包括这些元素及及其接口、他们的协作和他们的组合--架构风格。\n2. Garlan和Shaw的定义：\n架构包括组件（Component）、连接件（Connector）和约束（Constrain）三大要素。组件可以是一组代码（例如：一个代码块、一个库、一个模块），也可以是独立的程序（例如：数据库程序，一个独立的子系统）。连接件可以是过程调用、管道和消息等，用于表示组件之间的相互关系。约束，一般为组件连接时的条件。\n3. Perry和Wolf的定义：\n架构是一组具有特定形式的架构元素，这些元素分为三类：负责完成数据加工的处理元素（Processing Elements）、作为被加工的信息数据元素（Data Elements）及孕育吧架构不同部分组合在一起的连接元素（Connecting Elements）。\n\n# 软件架构解析\n## 软件架构关注分割与交互\n软件设计其实就是一个分与合的过程。软件架构其实就是设计组件与组件之间的交互，同时也是一系列决策的结果。我们需要决定模块如何划分，每个模块的职责，模块接口如何定义，模块与模块采用何种交互机制(RPC,Massage..),开发技术选型，如何满足质量属性和约束的要求，如何适应变化，等等。","slug":"软件架构","published":1,"updated":"2019-01-24T09:38:32.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8ja39w001h44eizhtg04ub","content":"<h1 id=\"什么是软件架构\"><a href=\"#什么是软件架构\" class=\"headerlink\" title=\"什么是软件架构\"></a>什么是软件架构</h1><p>要理解什么是软件架构，首先需要知道架构是什么，架构一词其实是来自英文单词Architecture，表示建筑，体系结构的意思。这里引用了其体系结构的意思，维基百科英文版里对 Architecture 的解释是：规划、设计和建造建筑物的过程及产物。在计算机软件领域，软件架构就成为了描述软件规划设计技术的专有名词。<br>虽然我们对‘架构’做了解释。但是对于软件架构的概念定义并不那么简单，而且也没有一个统一的定义。<br>现在对于软件架构的定义分为两大流派，组成派和决策派：</p>\n<h2 id=\"组成派\"><a href=\"#组成派\" class=\"headerlink\" title=\"组成派\"></a>组成派</h2><blockquote>\n<p> 软件系统的架构将系统描述为计算机组件及组件之间的交互。（The architecture of a software system defined that system in terms of computational components and interactions among those components.）</p>\n</blockquote>\n<p>这个是Mary Shaw在《软件体系结构：一门初露端倪学科的展望》中为“软件架构”给出定义。这个定义是把系统划分为以组件为单位的一个集合。而软件架构就是用于描述组成整个系统中的组件集合中组件与组件之间相互交互。这里的组件可以是一个类、库、模块、框架、一个子系统等等，每个组件负责一个职责。组件可以是粗粒度的也可以是细粒度的，不同的场景描述的组将粒度可能不一样。<br>组成派的软件架构定义的特点：</p>\n<ol>\n<li>关注架构实践中的客体—软件，以软件本身为描述对象；</li>\n<li>软件是由承担不同职责的组件组成，这些组件通过相互交互组成一个系统或者说另外一个组件。</li>\n</ol>\n<h2 id=\"决策派\"><a href=\"#决策派\" class=\"headerlink\" title=\"决策派\"></a>决策派</h2><blockquote>\n<p>软件架构包含了关于一下问题的重要决策： </p>\n<ul>\n<li>软件系统的组织；</li>\n<li>选择组成系统的结构元素和同门之间的接口，以及当这些元素相互协作是所体现的行为</li>\n<li>如何组合这些元素，使它们逐渐合成为更大的子系统；</li>\n<li>用于指导这个系统组织的架构风格：这些元素以及它们的结构、协作和组合。</li>\n<li>软件架构并不仅仅注重软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解性、经济和技术的限制及权衡，以及美学等。</li>\n</ul>\n</blockquote>\n<p>这是“决策派”软件架构概念的典型代表，决策派的软件架构定义特点： </p>\n<ol>\n<li>关注架构实践中的主体–人，一人的决策为描述对象。</li>\n<li>归纳了架构决策的类型，指出架构决策不仅包括关于软件系统的组织、元素、子系统和架构风格等。还包括关于众多非功能需求的决策。</li>\n</ol>\n<h2 id=\"著名软件架构定义\"><a href=\"#著名软件架构定义\" class=\"headerlink\" title=\"著名软件架构定义\"></a>著名软件架构定义</h2><p>我们知道软架构没有一个统一的定义，且分为为组件派和决策派。这只是站在不同角度看问题的不同理解。下面我就列举几个著名的软件架构定义。从这些定义，我们也能看出提出者的思考方向，我们也可以结合这些定义和我们自己工作实践自己体会软件架构的意义。</p>\n<ol>\n<li>Booch、Rumbaugh和Jacobson对软件架构的定义：<br>架构是一系列重要决策的集合，这些决策与一下内容有关：软件的组织，构成系统的结构元素及其接口的选择，这些元素在相互协作中明确表现出的行为，这些结构元素和行为元素进一步组合所构成的更大更一抹的子系统，以及指导这一组织–包括这些元素及及其接口、他们的协作和他们的组合–架构风格。</li>\n<li>Garlan和Shaw的定义：<br>架构包括组件（Component）、连接件（Connector）和约束（Constrain）三大要素。组件可以是一组代码（例如：一个代码块、一个库、一个模块），也可以是独立的程序（例如：数据库程序，一个独立的子系统）。连接件可以是过程调用、管道和消息等，用于表示组件之间的相互关系。约束，一般为组件连接时的条件。</li>\n<li>Perry和Wolf的定义：<br>架构是一组具有特定形式的架构元素，这些元素分为三类：负责完成数据加工的处理元素（Processing Elements）、作为被加工的信息数据元素（Data Elements）及孕育吧架构不同部分组合在一起的连接元素（Connecting Elements）。</li>\n</ol>\n<h1 id=\"软件架构解析\"><a href=\"#软件架构解析\" class=\"headerlink\" title=\"软件架构解析\"></a>软件架构解析</h1><h2 id=\"软件架构关注分割与交互\"><a href=\"#软件架构关注分割与交互\" class=\"headerlink\" title=\"软件架构关注分割与交互\"></a>软件架构关注分割与交互</h2><p>软件设计其实就是一个分与合的过程。软件架构其实就是设计组件与组件之间的交互，同时也是一系列决策的结果。我们需要决定模块如何划分，每个模块的职责，模块接口如何定义，模块与模块采用何种交互机制(RPC,Massage..),开发技术选型，如何满足质量属性和约束的要求，如何适应变化，等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是软件架构\"><a href=\"#什么是软件架构\" class=\"headerlink\" title=\"什么是软件架构\"></a>什么是软件架构</h1><p>要理解什么是软件架构，首先需要知道架构是什么，架构一词其实是来自英文单词Architecture，表示建筑，体系结构的意思。这里引用了其体系结构的意思，维基百科英文版里对 Architecture 的解释是：规划、设计和建造建筑物的过程及产物。在计算机软件领域，软件架构就成为了描述软件规划设计技术的专有名词。<br>虽然我们对‘架构’做了解释。但是对于软件架构的概念定义并不那么简单，而且也没有一个统一的定义。<br>现在对于软件架构的定义分为两大流派，组成派和决策派：</p>\n<h2 id=\"组成派\"><a href=\"#组成派\" class=\"headerlink\" title=\"组成派\"></a>组成派</h2><blockquote>\n<p> 软件系统的架构将系统描述为计算机组件及组件之间的交互。（The architecture of a software system defined that system in terms of computational components and interactions among those components.）</p>\n</blockquote>\n<p>这个是Mary Shaw在《软件体系结构：一门初露端倪学科的展望》中为“软件架构”给出定义。这个定义是把系统划分为以组件为单位的一个集合。而软件架构就是用于描述组成整个系统中的组件集合中组件与组件之间相互交互。这里的组件可以是一个类、库、模块、框架、一个子系统等等，每个组件负责一个职责。组件可以是粗粒度的也可以是细粒度的，不同的场景描述的组将粒度可能不一样。<br>组成派的软件架构定义的特点：</p>\n<ol>\n<li>关注架构实践中的客体—软件，以软件本身为描述对象；</li>\n<li>软件是由承担不同职责的组件组成，这些组件通过相互交互组成一个系统或者说另外一个组件。</li>\n</ol>\n<h2 id=\"决策派\"><a href=\"#决策派\" class=\"headerlink\" title=\"决策派\"></a>决策派</h2><blockquote>\n<p>软件架构包含了关于一下问题的重要决策： </p>\n<ul>\n<li>软件系统的组织；</li>\n<li>选择组成系统的结构元素和同门之间的接口，以及当这些元素相互协作是所体现的行为</li>\n<li>如何组合这些元素，使它们逐渐合成为更大的子系统；</li>\n<li>用于指导这个系统组织的架构风格：这些元素以及它们的结构、协作和组合。</li>\n<li>软件架构并不仅仅注重软件本身的结构和行为，还注重其他特性：使用、功能性、性能、弹性、重用、可理解性、经济和技术的限制及权衡，以及美学等。</li>\n</ul>\n</blockquote>\n<p>这是“决策派”软件架构概念的典型代表，决策派的软件架构定义特点： </p>\n<ol>\n<li>关注架构实践中的主体–人，一人的决策为描述对象。</li>\n<li>归纳了架构决策的类型，指出架构决策不仅包括关于软件系统的组织、元素、子系统和架构风格等。还包括关于众多非功能需求的决策。</li>\n</ol>\n<h2 id=\"著名软件架构定义\"><a href=\"#著名软件架构定义\" class=\"headerlink\" title=\"著名软件架构定义\"></a>著名软件架构定义</h2><p>我们知道软架构没有一个统一的定义，且分为为组件派和决策派。这只是站在不同角度看问题的不同理解。下面我就列举几个著名的软件架构定义。从这些定义，我们也能看出提出者的思考方向，我们也可以结合这些定义和我们自己工作实践自己体会软件架构的意义。</p>\n<ol>\n<li>Booch、Rumbaugh和Jacobson对软件架构的定义：<br>架构是一系列重要决策的集合，这些决策与一下内容有关：软件的组织，构成系统的结构元素及其接口的选择，这些元素在相互协作中明确表现出的行为，这些结构元素和行为元素进一步组合所构成的更大更一抹的子系统，以及指导这一组织–包括这些元素及及其接口、他们的协作和他们的组合–架构风格。</li>\n<li>Garlan和Shaw的定义：<br>架构包括组件（Component）、连接件（Connector）和约束（Constrain）三大要素。组件可以是一组代码（例如：一个代码块、一个库、一个模块），也可以是独立的程序（例如：数据库程序，一个独立的子系统）。连接件可以是过程调用、管道和消息等，用于表示组件之间的相互关系。约束，一般为组件连接时的条件。</li>\n<li>Perry和Wolf的定义：<br>架构是一组具有特定形式的架构元素，这些元素分为三类：负责完成数据加工的处理元素（Processing Elements）、作为被加工的信息数据元素（Data Elements）及孕育吧架构不同部分组合在一起的连接元素（Connecting Elements）。</li>\n</ol>\n<h1 id=\"软件架构解析\"><a href=\"#软件架构解析\" class=\"headerlink\" title=\"软件架构解析\"></a>软件架构解析</h1><h2 id=\"软件架构关注分割与交互\"><a href=\"#软件架构关注分割与交互\" class=\"headerlink\" title=\"软件架构关注分割与交互\"></a>软件架构关注分割与交互</h2><p>软件设计其实就是一个分与合的过程。软件架构其实就是设计组件与组件之间的交互，同时也是一系列决策的结果。我们需要决定模块如何划分，每个模块的职责，模块接口如何定义，模块与模块采用何种交互机制(RPC,Massage..),开发技术选型，如何满足质量属性和约束的要求，如何适应变化，等等。</p>\n"},{"title":"Part 1:Building microservices with Spring Cloud and Netflix OSS","date":"2018-05-01T11:28:43.000Z","_content":"在前面的文章中我们定义了一个`微服务应用操作模型`。现在我们将开始研究怎样使用Spring Cloud和Netflix OSS实现这个模型。通过实施这个模型，我们将覆盖最核心的部分：服务发现、动态路由、负载均衡、以及一些边缘服务。\n我们将使用Spring Cloud 和 Netflix OSS的一些核心组件，允许单独部署的微服务相互通信，无需手动管理。例如：跟踪每个微服务使用的端口或路由规则的手动配置。为避免端口冲突问题，我们的微服务在启动是将动态分配空闲端口从一个端口范围。为了允许对微服务的简单访问，我们将使用边缘服务器，它为微服务系统提供了一个众所周知的入口点。\n在简单介绍 Spring Cloud 和 Netflix OSS组件后，我们将展示一个我们将在整个博客系列中使用的系统架构。我们将介绍如何访问源代码并构建它。我们还将简要介绍并指出最重要部分的源代码。最后，我们通过运行一些关于如何访问服务的测试用例进行总结，并演示了如何简单地启动微服务的新实例并让负载均衡器开始使用它，同样无需任何手动配置。\n\n# 1 Spring Cloud 和 Netflix OSS\nSpring Cloud是Spring.io家族的一个想项目，它包含一组可以帮助我们实现我们的操作模型的组件。很大程度上Spring Cloud 1.0是基于Netflix OSS组件。Spring Cloud通过非常好的方法将Netflix组件集成到Spring环境中，使用类似于Spring Boot工作方式的自动配置和约定配置。\n下表是在微服务操作模型中通用组件和我们在博客中将要使用实际组件对照：\n![](./mapping-table.png)\n这篇文章讲覆盖Eureka、Ribbon和Zuul:\n- `Netflix Eureka` - 服务发现服务Netflix Eureka允许微服务在运行注册自己，因为他们出现在系统环境中。\n- `Netflix Ribbon` - 动态路由和负载均衡，服务消费者可以使用Netflix Ribbon在运行时查找服务。Ribbon使用Eureka中提供的信息来查找适当的服务实例。如果超过一个实例被发现，Ribbon将应用负载均衡在可用的实例上均衡请求。Ribbon不能作为一个独立的服务运行，它作为一个组件嵌入到每个服务消费这中。\n- `Netflix Zuul` - 边缘服务Zuul是我们对外界的看门人，不允许任何未被授权的外部请求通过。Zuul同时也提供一个众所周知的入口给系统环境中的微服务。使用动态分配端口可以方便的避免端口冲突并最大限度的减小管理，当然这对于一个给定的服务使用者更加困难了。Zuul使用Ribbon查找可用的服务并路由外部请求到一个适当的服务实例。本文我们将唯一使用Zuul提供入口，安全问题将在后面的文章介绍.\n注意：允许通过边缘服务器从外部访问的微服务可以看作是系统环境的API。\n\n2. 系统架构\n为了能够测试组件，我们需要一个系统架构来进行测试。 对于本文的范围，我们开发了一个类似于以下内容的架构：\n![](./system-landscape.png)\n它包含四个业务服务（绿色框）：\n- 三个核心服务，分布负责处理产品相关信息、推荐、评论。\n- 一种复合服务，即product-composite，可以汇总来自三种核心服务的信息，并构成产品信息视图以及产品的评论和建议。\n为了支撑业务服务，我们使用下面基础服务和组件（蓝色框）：\n- 服务发现服务（Netflix Eureka）\n- 动态路由和负责均衡器（(Netflix Ribbon）\n- 边缘服务（Netflix Zuul）\n> 为了强调微服务和单体应用之间的不同，我们将在单独的微服务中运行每个微服务，即在单独的进程中运行。在一个大规模的系统架构中，在大规模的系统架构中，使用这种细粒度微服务可能会非常不方便。相反，一些相关的服务可能会被分组在一个和同一个微服务中，以使微服务的数量保持在可管理的水平。但仍然没有回到巨大的单体应用程序中…\n\n# 3 基于源码构建\n如果你想checke out源码并自己测试它，你需要安装Java SE 8和Git，然后执行：\n```sh\n$ git clone https://github.com/zhakui/microservices-architecture.git\n```\n\n","source":"_posts/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS.md","raw":"---\ntitle: Part 1:Building microservices with Spring Cloud and Netflix OSS\ndate: 2018-05-1 19:28:43\ncategories:\n  【微服务-Java】\ntags: \n  - Microservices\n  - Java\n  - Netflix\n  - Eureka\n  - Ribbon\n  - Zuul\n---\n在前面的文章中我们定义了一个`微服务应用操作模型`。现在我们将开始研究怎样使用Spring Cloud和Netflix OSS实现这个模型。通过实施这个模型，我们将覆盖最核心的部分：服务发现、动态路由、负载均衡、以及一些边缘服务。\n我们将使用Spring Cloud 和 Netflix OSS的一些核心组件，允许单独部署的微服务相互通信，无需手动管理。例如：跟踪每个微服务使用的端口或路由规则的手动配置。为避免端口冲突问题，我们的微服务在启动是将动态分配空闲端口从一个端口范围。为了允许对微服务的简单访问，我们将使用边缘服务器，它为微服务系统提供了一个众所周知的入口点。\n在简单介绍 Spring Cloud 和 Netflix OSS组件后，我们将展示一个我们将在整个博客系列中使用的系统架构。我们将介绍如何访问源代码并构建它。我们还将简要介绍并指出最重要部分的源代码。最后，我们通过运行一些关于如何访问服务的测试用例进行总结，并演示了如何简单地启动微服务的新实例并让负载均衡器开始使用它，同样无需任何手动配置。\n\n# 1 Spring Cloud 和 Netflix OSS\nSpring Cloud是Spring.io家族的一个想项目，它包含一组可以帮助我们实现我们的操作模型的组件。很大程度上Spring Cloud 1.0是基于Netflix OSS组件。Spring Cloud通过非常好的方法将Netflix组件集成到Spring环境中，使用类似于Spring Boot工作方式的自动配置和约定配置。\n下表是在微服务操作模型中通用组件和我们在博客中将要使用实际组件对照：\n![](./mapping-table.png)\n这篇文章讲覆盖Eureka、Ribbon和Zuul:\n- `Netflix Eureka` - 服务发现服务Netflix Eureka允许微服务在运行注册自己，因为他们出现在系统环境中。\n- `Netflix Ribbon` - 动态路由和负载均衡，服务消费者可以使用Netflix Ribbon在运行时查找服务。Ribbon使用Eureka中提供的信息来查找适当的服务实例。如果超过一个实例被发现，Ribbon将应用负载均衡在可用的实例上均衡请求。Ribbon不能作为一个独立的服务运行，它作为一个组件嵌入到每个服务消费这中。\n- `Netflix Zuul` - 边缘服务Zuul是我们对外界的看门人，不允许任何未被授权的外部请求通过。Zuul同时也提供一个众所周知的入口给系统环境中的微服务。使用动态分配端口可以方便的避免端口冲突并最大限度的减小管理，当然这对于一个给定的服务使用者更加困难了。Zuul使用Ribbon查找可用的服务并路由外部请求到一个适当的服务实例。本文我们将唯一使用Zuul提供入口，安全问题将在后面的文章介绍.\n注意：允许通过边缘服务器从外部访问的微服务可以看作是系统环境的API。\n\n2. 系统架构\n为了能够测试组件，我们需要一个系统架构来进行测试。 对于本文的范围，我们开发了一个类似于以下内容的架构：\n![](./system-landscape.png)\n它包含四个业务服务（绿色框）：\n- 三个核心服务，分布负责处理产品相关信息、推荐、评论。\n- 一种复合服务，即product-composite，可以汇总来自三种核心服务的信息，并构成产品信息视图以及产品的评论和建议。\n为了支撑业务服务，我们使用下面基础服务和组件（蓝色框）：\n- 服务发现服务（Netflix Eureka）\n- 动态路由和负责均衡器（(Netflix Ribbon）\n- 边缘服务（Netflix Zuul）\n> 为了强调微服务和单体应用之间的不同，我们将在单独的微服务中运行每个微服务，即在单独的进程中运行。在一个大规模的系统架构中，在大规模的系统架构中，使用这种细粒度微服务可能会非常不方便。相反，一些相关的服务可能会被分组在一个和同一个微服务中，以使微服务的数量保持在可管理的水平。但仍然没有回到巨大的单体应用程序中…\n\n# 3 基于源码构建\n如果你想checke out源码并自己测试它，你需要安装Java SE 8和Git，然后执行：\n```sh\n$ git clone https://github.com/zhakui/microservices-architecture.git\n```\n\n","slug":"【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS","published":1,"updated":"2019-03-14T11:10:01.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjt8je0b40000ayeil33r6gbu","content":"<p>在前面的文章中我们定义了一个<code>微服务应用操作模型</code>。现在我们将开始研究怎样使用Spring Cloud和Netflix OSS实现这个模型。通过实施这个模型，我们将覆盖最核心的部分：服务发现、动态路由、负载均衡、以及一些边缘服务。<br>我们将使用Spring Cloud 和 Netflix OSS的一些核心组件，允许单独部署的微服务相互通信，无需手动管理。例如：跟踪每个微服务使用的端口或路由规则的手动配置。为避免端口冲突问题，我们的微服务在启动是将动态分配空闲端口从一个端口范围。为了允许对微服务的简单访问，我们将使用边缘服务器，它为微服务系统提供了一个众所周知的入口点。<br>在简单介绍 Spring Cloud 和 Netflix OSS组件后，我们将展示一个我们将在整个博客系列中使用的系统架构。我们将介绍如何访问源代码并构建它。我们还将简要介绍并指出最重要部分的源代码。最后，我们通过运行一些关于如何访问服务的测试用例进行总结，并演示了如何简单地启动微服务的新实例并让负载均衡器开始使用它，同样无需任何手动配置。</p>\n<h1 id=\"1-Spring-Cloud-和-Netflix-OSS\"><a href=\"#1-Spring-Cloud-和-Netflix-OSS\" class=\"headerlink\" title=\"1 Spring Cloud 和 Netflix OSS\"></a>1 Spring Cloud 和 Netflix OSS</h1><p>Spring Cloud是Spring.io家族的一个想项目，它包含一组可以帮助我们实现我们的操作模型的组件。很大程度上Spring Cloud 1.0是基于Netflix OSS组件。Spring Cloud通过非常好的方法将Netflix组件集成到Spring环境中，使用类似于Spring Boot工作方式的自动配置和约定配置。<br>下表是在微服务操作模型中通用组件和我们在博客中将要使用实际组件对照：<br><img src=\"./mapping-table.png\" alt=\"\"><br>这篇文章讲覆盖Eureka、Ribbon和Zuul:</p>\n<ul>\n<li><code>Netflix Eureka</code> - 服务发现服务Netflix Eureka允许微服务在运行注册自己，因为他们出现在系统环境中。</li>\n<li><code>Netflix Ribbon</code> - 动态路由和负载均衡，服务消费者可以使用Netflix Ribbon在运行时查找服务。Ribbon使用Eureka中提供的信息来查找适当的服务实例。如果超过一个实例被发现，Ribbon将应用负载均衡在可用的实例上均衡请求。Ribbon不能作为一个独立的服务运行，它作为一个组件嵌入到每个服务消费这中。</li>\n<li><code>Netflix Zuul</code> - 边缘服务Zuul是我们对外界的看门人，不允许任何未被授权的外部请求通过。Zuul同时也提供一个众所周知的入口给系统环境中的微服务。使用动态分配端口可以方便的避免端口冲突并最大限度的减小管理，当然这对于一个给定的服务使用者更加困难了。Zuul使用Ribbon查找可用的服务并路由外部请求到一个适当的服务实例。本文我们将唯一使用Zuul提供入口，安全问题将在后面的文章介绍.<br>注意：允许通过边缘服务器从外部访问的微服务可以看作是系统环境的API。</li>\n</ul>\n<ol>\n<li>系统架构<br>为了能够测试组件，我们需要一个系统架构来进行测试。 对于本文的范围，我们开发了一个类似于以下内容的架构：<br><img src=\"./system-landscape.png\" alt=\"\"><br>它包含四个业务服务（绿色框）：</li>\n</ol>\n<ul>\n<li>三个核心服务，分布负责处理产品相关信息、推荐、评论。</li>\n<li>一种复合服务，即product-composite，可以汇总来自三种核心服务的信息，并构成产品信息视图以及产品的评论和建议。<br>为了支撑业务服务，我们使用下面基础服务和组件（蓝色框）：</li>\n<li>服务发现服务（Netflix Eureka）</li>\n<li>动态路由和负责均衡器（(Netflix Ribbon）</li>\n<li>边缘服务（Netflix Zuul）<blockquote>\n<p>为了强调微服务和单体应用之间的不同，我们将在单独的微服务中运行每个微服务，即在单独的进程中运行。在一个大规模的系统架构中，在大规模的系统架构中，使用这种细粒度微服务可能会非常不方便。相反，一些相关的服务可能会被分组在一个和同一个微服务中，以使微服务的数量保持在可管理的水平。但仍然没有回到巨大的单体应用程序中…</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"3-基于源码构建\"><a href=\"#3-基于源码构建\" class=\"headerlink\" title=\"3 基于源码构建\"></a>3 基于源码构建</h1><p>如果你想checke out源码并自己测试它，你需要安装Java SE 8和Git，然后执行：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/zhakui/microservices-architecture.git</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前面的文章中我们定义了一个<code>微服务应用操作模型</code>。现在我们将开始研究怎样使用Spring Cloud和Netflix OSS实现这个模型。通过实施这个模型，我们将覆盖最核心的部分：服务发现、动态路由、负载均衡、以及一些边缘服务。<br>我们将使用Spring Cloud 和 Netflix OSS的一些核心组件，允许单独部署的微服务相互通信，无需手动管理。例如：跟踪每个微服务使用的端口或路由规则的手动配置。为避免端口冲突问题，我们的微服务在启动是将动态分配空闲端口从一个端口范围。为了允许对微服务的简单访问，我们将使用边缘服务器，它为微服务系统提供了一个众所周知的入口点。<br>在简单介绍 Spring Cloud 和 Netflix OSS组件后，我们将展示一个我们将在整个博客系列中使用的系统架构。我们将介绍如何访问源代码并构建它。我们还将简要介绍并指出最重要部分的源代码。最后，我们通过运行一些关于如何访问服务的测试用例进行总结，并演示了如何简单地启动微服务的新实例并让负载均衡器开始使用它，同样无需任何手动配置。</p>\n<h1 id=\"1-Spring-Cloud-和-Netflix-OSS\"><a href=\"#1-Spring-Cloud-和-Netflix-OSS\" class=\"headerlink\" title=\"1 Spring Cloud 和 Netflix OSS\"></a>1 Spring Cloud 和 Netflix OSS</h1><p>Spring Cloud是Spring.io家族的一个想项目，它包含一组可以帮助我们实现我们的操作模型的组件。很大程度上Spring Cloud 1.0是基于Netflix OSS组件。Spring Cloud通过非常好的方法将Netflix组件集成到Spring环境中，使用类似于Spring Boot工作方式的自动配置和约定配置。<br>下表是在微服务操作模型中通用组件和我们在博客中将要使用实际组件对照：<br><img src=\"./mapping-table.png\" alt=\"\"><br>这篇文章讲覆盖Eureka、Ribbon和Zuul:</p>\n<ul>\n<li><code>Netflix Eureka</code> - 服务发现服务Netflix Eureka允许微服务在运行注册自己，因为他们出现在系统环境中。</li>\n<li><code>Netflix Ribbon</code> - 动态路由和负载均衡，服务消费者可以使用Netflix Ribbon在运行时查找服务。Ribbon使用Eureka中提供的信息来查找适当的服务实例。如果超过一个实例被发现，Ribbon将应用负载均衡在可用的实例上均衡请求。Ribbon不能作为一个独立的服务运行，它作为一个组件嵌入到每个服务消费这中。</li>\n<li><code>Netflix Zuul</code> - 边缘服务Zuul是我们对外界的看门人，不允许任何未被授权的外部请求通过。Zuul同时也提供一个众所周知的入口给系统环境中的微服务。使用动态分配端口可以方便的避免端口冲突并最大限度的减小管理，当然这对于一个给定的服务使用者更加困难了。Zuul使用Ribbon查找可用的服务并路由外部请求到一个适当的服务实例。本文我们将唯一使用Zuul提供入口，安全问题将在后面的文章介绍.<br>注意：允许通过边缘服务器从外部访问的微服务可以看作是系统环境的API。</li>\n</ul>\n<ol>\n<li>系统架构<br>为了能够测试组件，我们需要一个系统架构来进行测试。 对于本文的范围，我们开发了一个类似于以下内容的架构：<br><img src=\"./system-landscape.png\" alt=\"\"><br>它包含四个业务服务（绿色框）：</li>\n</ol>\n<ul>\n<li>三个核心服务，分布负责处理产品相关信息、推荐、评论。</li>\n<li>一种复合服务，即product-composite，可以汇总来自三种核心服务的信息，并构成产品信息视图以及产品的评论和建议。<br>为了支撑业务服务，我们使用下面基础服务和组件（蓝色框）：</li>\n<li>服务发现服务（Netflix Eureka）</li>\n<li>动态路由和负责均衡器（(Netflix Ribbon）</li>\n<li>边缘服务（Netflix Zuul）<blockquote>\n<p>为了强调微服务和单体应用之间的不同，我们将在单独的微服务中运行每个微服务，即在单独的进程中运行。在一个大规模的系统架构中，在大规模的系统架构中，使用这种细粒度微服务可能会非常不方便。相反，一些相关的服务可能会被分组在一个和同一个微服务中，以使微服务的数量保持在可管理的水平。但仍然没有回到巨大的单体应用程序中…</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"3-基于源码构建\"><a href=\"#3-基于源码构建\" class=\"headerlink\" title=\"3 基于源码构建\"></a>3 基于源码构建</h1><p>如果你想checke out源码并自己测试它，你需要安装Java SE 8和Git，然后执行：<br><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/zhakui/microservices-architecture.git</div></pre></td></tr></table></figure></p>\n"}],"PostAsset":[{"_id":"source/_posts/微服务操作模型/microservices-architecture.png","slug":"microservices-architecture.png","post":"cjt8ja39u001e44eihpsq9wnz","modified":0,"renderable":0},{"_id":"source/_posts/Good-Code-vs-Bad-Code-in-Golang/1-yh90bW8jL4f8pOTZTvbzqw.png","slug":"1-yh90bW8jL4f8pOTZTvbzqw.png","post":"cjt8ja38r000744eidybqpir0","modified":0,"renderable":0},{"_id":"source/_posts/Good-Code-vs-Bad-Code-in-Golang/1-yh90bW8jL4f8pOTZTvbzqw.png:Zone.Identifier","slug":"1-yh90bW8jL4f8pOTZTvbzqw.png:Zone.Identifier","post":"cjt8ja38r000744eidybqpir0","modified":0,"renderable":0},{"_id":"source/_posts/微服务操作模型/microservices-1-1.png","slug":"microservices-1-1.png","post":"cjt8ja39u001e44eihpsq9wnz","modified":0,"renderable":0},{"_id":"source/_posts/微服务操作模型/microservices-1-2.png","slug":"microservices-1-2.png","post":"cjt8ja39u001e44eihpsq9wnz","modified":0,"renderable":0},{"_id":"source/_posts/微服务操作模型/microservices-1.png","slug":"microservices-1.png","post":"cjt8ja39u001e44eihpsq9wnz","modified":0,"renderable":0},{"_id":"source/_posts/微服务操作模型/microservices-operations-reference-model.png","slug":"microservices-operations-reference-model.png","post":"cjt8ja39u001e44eihpsq9wnz","modified":0,"renderable":0},{"_id":"source/_posts/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/system-landscape.png","slug":"system-landscape.png","post":"cjt8je0b40000ayeil33r6gbu","modified":1,"renderable":0},{"_id":"source/_posts/【微服务-Java】-Part-1: Building-microservices-with-Spring-Cloud-and-Netflix-OSS/mapping-table.png","post":"cjt8je0b40000ayeil33r6gbu","slug":"mapping-table.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjt8ja389000044eik16m6yqo","category_id":"cjt8ja38l000444eicovjtl5y","_id":"cjt8ja38x000c44eity5e6yvp"},{"post_id":"cjt8ja38i000244ei1akj5jud","category_id":"cjt8ja38l000444eicovjtl5y","_id":"cjt8ja391000i44eipd4lt38j"},{"post_id":"cjt8ja38o000644eino97qway","category_id":"cjt8ja38y000e44eicttnvcsw","_id":"cjt8ja396000p44eiaa61h6du"},{"post_id":"cjt8ja391000j44eiutuyoiqo","category_id":"cjt8ja38l000444eicovjtl5y","_id":"cjt8ja39f000t44eib2nb3bn4"},{"post_id":"cjt8ja393000n44eisx4nxz9x","category_id":"cjt8ja38l000444eicovjtl5y","_id":"cjt8ja39i000w44ei7bu6e61z"},{"post_id":"cjt8ja38r000744eidybqpir0","category_id":"cjt8ja392000l44eifegyfsxw","_id":"cjt8ja39p001144eieayxa9ff"},{"post_id":"cjt8ja396000o44eirrrd5rn0","category_id":"cjt8ja38l000444eicovjtl5y","_id":"cjt8ja39q001444eiwm86q1et"},{"post_id":"cjt8ja38s000844ein0s4vhz0","category_id":"cjt8ja38y000e44eicttnvcsw","_id":"cjt8ja39s001944eieuxx7sl1"},{"post_id":"cjt8ja39i000v44ei3ip2p3fa","category_id":"cjt8ja38l000444eicovjtl5y","_id":"cjt8ja39t001b44ei7w8m6pg8"},{"post_id":"cjt8ja38v000b44ei9grhlcqi","category_id":"cjt8ja38y000e44eicttnvcsw","_id":"cjt8ja39v001f44eiilfs8qwp"},{"post_id":"cjt8ja38x000d44eikzziqfln","category_id":"cjt8ja39q001544eigb4z8adp","_id":"cjt8ja39x001i44ei63de7s2l"},{"post_id":"cjt8ja390000g44eilw1b506a","category_id":"cjt8ja39u001c44eizlmyfava","_id":"cjt8ja39y001n44eifgre4fyf"},{"post_id":"cjt8ja39e000s44eij5wlhka8","category_id":"cjt8ja39x001k44eiu6c0vsyb","_id":"cjt8ja39z001r44ei57o2rjl7"},{"post_id":"cjt8ja39o001044eii2yxndiz","category_id":"cjt8ja39y001o44eignyoifz5","_id":"cjt8ja3a0001v44ei1ubxlmag"},{"post_id":"cjt8ja39p001344eizzswgyqo","category_id":"cjt8ja3a0001u44eizdu4gaf4","_id":"cjt8ja3a1001z44eil026qp68"},{"post_id":"cjt8ja39s001a44eipjbunf2z","category_id":"cjt8ja3a2002044eijub4j8xn","_id":"cjt8ja3a4002844eio9ci69ve"},{"post_id":"cjt8ja39u001e44eihpsq9wnz","category_id":"cjt8ja3a2002644eie0h0hgmh","_id":"cjt8ja3a4002b44eifrbp7ceo"},{"post_id":"cjt8ja39w001h44eizhtg04ub","category_id":"cjt8ja3a4002944eiy3d2kbdm","_id":"cjt8ja3a5002g44ei4md4v9fi"},{"post_id":"cjt8je0b40000ayeil33r6gbu","category_id":"cjt8ja3a1001x44eifcmm09in","_id":"cjt8je0bn0002ayeir2dregjd"}],"PostTag":[{"post_id":"cjt8ja389000044eik16m6yqo","tag_id":"cjt8ja38o000544eixu1yytki","_id":"cjt8ja391000h44eiyhpbauov"},{"post_id":"cjt8ja389000044eik16m6yqo","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja392000k44eivfmimmep"},{"post_id":"cjt8ja38i000244ei1akj5jud","tag_id":"cjt8ja38o000544eixu1yytki","_id":"cjt8ja39f000u44eifbluql18"},{"post_id":"cjt8ja38i000244ei1akj5jud","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja39i000x44ei1na3koz4"},{"post_id":"cjt8ja39i000v44ei3ip2p3fa","tag_id":"cjt8ja38o000544eixu1yytki","_id":"cjt8ja39p001244eiklb3fpnd"},{"post_id":"cjt8ja39i000v44ei3ip2p3fa","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja39q001644eiegbkwz12"},{"post_id":"cjt8ja38o000644eino97qway","tag_id":"cjt8ja397000q44eiqcqpkjjc","_id":"cjt8ja39w001g44ei2svao0ug"},{"post_id":"cjt8ja38o000644eino97qway","tag_id":"cjt8ja39o000z44eih4zyjnuq","_id":"cjt8ja39x001j44eicnpg0uis"},{"post_id":"cjt8ja38o000644eino97qway","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja39x001m44eilryfrcus"},{"post_id":"cjt8ja38r000744eidybqpir0","tag_id":"cjt8ja39u001d44eiit1zbd3o","_id":"cjt8ja39z001q44eihlsb0upi"},{"post_id":"cjt8ja38r000744eidybqpir0","tag_id":"cjt8ja39x001l44eilq6yva0p","_id":"cjt8ja39z001s44ei9zt73yhc"},{"post_id":"cjt8ja38s000844ein0s4vhz0","tag_id":"cjt8ja397000q44eiqcqpkjjc","_id":"cjt8ja3a2002144eizgb8y1oe"},{"post_id":"cjt8ja38s000844ein0s4vhz0","tag_id":"cjt8ja39o000z44eih4zyjnuq","_id":"cjt8ja3a2002244eiqt5w64a7"},{"post_id":"cjt8ja38s000844ein0s4vhz0","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja3a2002544eiaa3i20q3"},{"post_id":"cjt8ja38v000b44ei9grhlcqi","tag_id":"cjt8ja397000q44eiqcqpkjjc","_id":"cjt8ja3a4002c44eixezkh0cp"},{"post_id":"cjt8ja38v000b44ei9grhlcqi","tag_id":"cjt8ja3a2002344eiv6v4644n","_id":"cjt8ja3a4002d44eij6zacj0n"},{"post_id":"cjt8ja38v000b44ei9grhlcqi","tag_id":"cjt8ja39o000z44eih4zyjnuq","_id":"cjt8ja3a5002f44eibqso9qzm"},{"post_id":"cjt8ja38v000b44ei9grhlcqi","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja3a5002h44eiauwm6dlx"},{"post_id":"cjt8ja38x000d44eikzziqfln","tag_id":"cjt8ja3a4002a44eivesbyqdc","_id":"cjt8ja3a5002j44eiprsi2n4j"},{"post_id":"cjt8ja390000g44eilw1b506a","tag_id":"cjt8ja3a4002e44ei9otwiko6","_id":"cjt8ja3a5002k44ei0qpnje9z"},{"post_id":"cjt8ja391000j44eiutuyoiqo","tag_id":"cjt8ja3a5002i44eiqv54ifta","_id":"cjt8ja3a6002n44eixguz3eer"},{"post_id":"cjt8ja391000j44eiutuyoiqo","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja3a6002o44eitz7ea0fq"},{"post_id":"cjt8ja391000j44eiutuyoiqo","tag_id":"cjt8ja39o000z44eih4zyjnuq","_id":"cjt8ja3a6002q44eid59d0pni"},{"post_id":"cjt8ja393000n44eisx4nxz9x","tag_id":"cjt8ja3a5002i44eiqv54ifta","_id":"cjt8ja3a7002s44ei067usbb0"},{"post_id":"cjt8ja393000n44eisx4nxz9x","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja3a7002t44eidms4ggkd"},{"post_id":"cjt8ja393000n44eisx4nxz9x","tag_id":"cjt8ja39o000z44eih4zyjnuq","_id":"cjt8ja3a7002v44eignz8m6pm"},{"post_id":"cjt8ja396000o44eirrrd5rn0","tag_id":"cjt8ja3a5002i44eiqv54ifta","_id":"cjt8ja3a7002x44eil4lwen16"},{"post_id":"cjt8ja396000o44eirrrd5rn0","tag_id":"cjt8ja38t000a44ei9xge5vro","_id":"cjt8ja3a7002y44eicz83x1gs"},{"post_id":"cjt8ja396000o44eirrrd5rn0","tag_id":"cjt8ja39o000z44eih4zyjnuq","_id":"cjt8ja3a8003044eibdkzfcpf"},{"post_id":"cjt8ja39e000s44eij5wlhka8","tag_id":"cjt8ja3a7002w44eizbp9p1ur","_id":"cjt8ja3a8003144eikdd6mbad"},{"post_id":"cjt8ja39o001044eii2yxndiz","tag_id":"cjt8ja3a7002z44eiss07mr2p","_id":"cjt8ja3a8003344eilxbval46"},{"post_id":"cjt8ja39p001344eizzswgyqo","tag_id":"cjt8ja3a8003244eigyxqi4x4","_id":"cjt8ja3a8003544eil8dqkvit"},{"post_id":"cjt8ja39s001a44eipjbunf2z","tag_id":"cjt8ja3a4002e44ei9otwiko6","_id":"cjt8ja3ac003k44eizg51fvti"},{"post_id":"cjt8ja39u001e44eihpsq9wnz","tag_id":"cjt8ja3a8003444ei2whfyohx","_id":"cjt8ja3ac003l44ei9ssipf9v"},{"post_id":"cjt8ja39w001h44eizhtg04ub","tag_id":"cjt8ja3ab003h44eixy9455f7","_id":"cjt8ja3ac003m44ei5kc2pg9x"},{"post_id":"cjt8je0b40000ayeil33r6gbu","tag_id":"cjt8ja3a8003444ei2whfyohx","_id":"cjt8je0bh0001ayei37nwlrsm"},{"post_id":"cjt8je0b40000ayeil33r6gbu","tag_id":"cjt8ja3a8003644ei8z22ikqa","_id":"cjt8je0bn0003ayeilmffmstu"},{"post_id":"cjt8je0b40000ayeil33r6gbu","tag_id":"cjt8ja3a9003744ei9i9lmicj","_id":"cjt8je0bo0004ayeilip5z3mo"},{"post_id":"cjt8je0b40000ayeil33r6gbu","tag_id":"cjt8ja3a9003844eiyg4o9sew","_id":"cjt8je0bo0005ayeivgs1afvi"},{"post_id":"cjt8je0b40000ayeil33r6gbu","tag_id":"cjt8ja3a9003944ei8jvg643b","_id":"cjt8je0bo0006ayei2pstrw9y"},{"post_id":"cjt8je0b40000ayeil33r6gbu","tag_id":"cjt8ja3a9003a44eipbhylcl8","_id":"cjt8je0bo0007ayein7ml5q71"}],"Tag":[{"name":"Docker","_id":"cjt8ja38o000544eixu1yytki"},{"name":"Technology","_id":"cjt8ja38t000a44ei9xge5vro"},{"name":"Hadoop","_id":"cjt8ja397000q44eiqcqpkjjc"},{"name":"Server","_id":"cjt8ja39o000z44eih4zyjnuq"},{"name":"Golang","_id":"cjt8ja39u001d44eiit1zbd3o"},{"name":"Go","_id":"cjt8ja39x001l44eilq6yva0p"},{"name":"Hive","_id":"cjt8ja3a2002344eiv6v4644n"},{"name":"JavaScript","_id":"cjt8ja3a4002a44eivesbyqdc"},{"name":"算法","_id":"cjt8ja3a4002e44ei9otwiko6"},{"name":"Rides","_id":"cjt8ja3a5002i44eiqv54ifta"},{"name":"SpringCloud","_id":"cjt8ja3a7002w44eizbp9p1ur"},{"name":"Hexo","_id":"cjt8ja3a7002z44eiss07mr2p"},{"name":"Maven","_id":"cjt8ja3a8003244eigyxqi4x4"},{"name":"Microservices","_id":"cjt8ja3a8003444ei2whfyohx"},{"name":"Java","_id":"cjt8ja3a8003644ei8z22ikqa"},{"name":"Netflix","_id":"cjt8ja3a9003744ei9i9lmicj"},{"name":"Eureka","_id":"cjt8ja3a9003844eiyg4o9sew"},{"name":"Ribbon","_id":"cjt8ja3a9003944ei8jvg643b"},{"name":"Zuul","_id":"cjt8ja3a9003a44eipbhylcl8"},{"name":"架构设计","_id":"cjt8ja3ab003h44eixy9455f7"}]}}